/*define datapoint ruleset DMIDCheckRegex (variable OBS_VALUE, REP_COUNTRY, CURRENCY) is
    DF1:
        when
        REP_COUNTRY in{"CY"} and
        CURRENCY in {"TO1"}
        then
        match_characters (OBS_VALUE, "^\d{4}\-(0[1-9]|1[012])\-(0[1-9]|[12][0-9]|3[01])")
        and length(OBS_VALUE) > 0
         and length(OBS_VALUE) < 20
        errorcode "DF1"
        errorlevel "1"    
end datapoint ruleset;

INPUT_NULL_CHECK :=
	check(
        isnull(BIS_LOC_STATS # OBS_VALUE)
        errorcode "not_null"
        errorlevel 1
        invalid
        );
// I would always use the check operator for validating.
// It is simply a wrapper, but helps to get a common structure
// And to add important info as the errorcode and the level (if used).

test_result_2 := INPUT_NULL_CHECK
			[drop bool_var, 'imbalance'];

test_result := INPUT_NULL_CHECK
            [drop bool_var, 'imbalance'];
test_result_2 := INPUT_NULL_CHECK
			[drop bool_var, errorcode];

DF1 := check_datapoint (BIS_LOC_STATS,DMIDCheckRegex);

validation_result <-
    union(
        INPUT_NULL_CHECK
            [drop bool_var, 'imbalance'],
        DF1[drop OBS_VALUE]);*/

define datapoint ruleset DMIDCheckRegex (variable OBS_VALUE, REP_COUNTRY, CURRENCY) is
    DF1:
        when
        REP_COUNTRY in{"CY"} and
        CURRENCY in {"TO1"}
        then
        match_characters (OBS_VALUE, "^\d{4}\-(0[1-9]|1[012])\-(0[1-9]|[12][0-9]|3[01])")
        and length(OBS_VALUE) > 0
         and length(OBS_VALUE) < 20
        errorcode "DF1"
        errorlevel 1  
end datapoint ruleset;

INPUT_NULL_CHECK :=
	check(
        isnull(BIS_LOC_STATS # OBS_VALUE)
        errorcode "not_null"
        errorlevel 1
        invalid
        );
DF1 := check_datapoint (BIS_LOC_STATS,DMIDCheckRegex);

test_result := INPUT_NULL_CHECK
            [drop bool_var, 'imbalance'];
test_result_2 := DF1
			[rename 'errorcode' to errc, 'errorlevel' to errl];