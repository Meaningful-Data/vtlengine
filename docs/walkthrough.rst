########################
10 minutes to VTL Engine
########################

Summarizes the main functions of the VTL Engine

The VTL Engine API implements five basic methods:

* **Semantic Analysis**: aimed at validating the correctness of a script and computing the data
  structures of the data sets created in the script.
* **Run**: aimed at executing the provided input on the provided input datasets.
* **Run_sdmx**: as part of the compatibility with pysdmx, this method is used to run a VTL script by using the pysdmx `PandasDataset`.
  It allows the use of SDMX datasets as input to run the given script.
* **Generate_sdmx**: as part of the compatibility with pysdmx, this method is used to generate a `TransformationScheme` object from a
  VTL script.
* **Prettify**: aimed at formatting the VTL script to make it more readable.

Any action with VTL requires the following elements as input:

* **VTL Script**: Is the VTL to be executed, which includes the transformation scheme, as well as de
  User Defined Operators, Hierarchical Rulesets and Datapoint Rulesets. It is provided as a string
  or as a Path object to a vtl file.
* **Data structures** : Provides the structure of the input artifacts of the VTL script, according to
  the VTL Information model. Given that the current version doesn't prescribe a standard format for
  providing the information, the VTL Engine is implementing a JSON format that can be found here.
  Data Structures can be provided as Dictionaries or as Paths to JSON files. It is possible to have
* **External routines**: The VTL Engine allows using SQL (SQLite) with the eval operator. Can be
  provided as a string with the SQL or as a path object to an SQL file. Its default value is `None`,
  which shall be used if external routines are not applicable to the VTL script.
* **Value domains**: Provides the value domains that are used in the VTL script, normally with an in
  operator. Can be provided as a dictionary or as a path to a JSON file. Its default value
  is `None`, which shall be used if value domains are not applicable to the VTL script.

*****************
Semantic Analysis
*****************
The `semantic_analysis` method serves to validate the correctness of a VTL script, as well as to
calculate the data structures of the datasets generated by the VTL script itself (that calculation
is a pre-requisite for the semantic analysis).

* If the VTL script is correct, the method returns a dictionary with the data structures of all the
  datasets generated by the script.
* If the VTL script is incorrect, raises a VTL Engine custom error Explaining the error.

======================
Example 1: Correct VTL
======================

.. code-block:: python

    from vtlengine import semantic_analysis

    script = """
        DS_A := DS_1 * 10;
    """

    data_structures = {
        'datasets': [
            {'name': 'DS_1',
             'DataStructure': [
                 {'name': 'Id_1',
                  'type':
                      'Integer',
                  'role': 'Identifier',
                  'nullable': False},
                 {'name': 'Me_1',
                  'type': 'Number',
                  'role': 'Measure',
                  'nullable': True}
             ]
             }
        ]
    }

    sa_result = semantic_analysis(script=script, data_structures=data_structures)

    print(sa_result)

```

Returns:

.. code-block:: python

    {'DS_A': Dataset(name='DS_A', components={'Id_1': Component(name='Id_1', data_type="Integer", role="Identifier", nullable=False), 'Me_1': Component(name='Me_1', data_type="Number", role="Measure", nullable=True)}, data=None)}

========================
Example 2: Incorrect VTL
========================

Note that, as compared to Example 1, the only change is that Me_1 is of the String
data type, instead of Number.

.. code-block:: python

    from vtlengine import semantic_analysis

    script = """
        DS_A := DS_1 * 10;
    """

    data_structures = {
        'datasets': [
            {'name': 'DS_1',
             'DataStructure': [
                 {'name': 'Id_1',
                  'type':
                      'Integer',
                  'role': 'Identifier',
                  'nullable': False},
                 {'name': 'Me_1',
                  'type': 'String',
                  'role': 'Measure',
                  'nullable': True}
             ]
             }
        ]
    }

    sa_result = semantic_analysis(script=script, data_structures=data_structures)

    print(sa_result)


Will raise the following Error:

.. code-block:: python

    raise SemanticError(code="1-1-1-2",
    vtlengine.Exceptions.SemanticError: ('Invalid implicit cast from String and Integer to Number.', '1-1-1-2')


*****************
Run VTL Scripts
*****************

The `run` method serves to execute a VTL script with input datapoints.

Returns a dictionary with all the generated Datasets.
When the output parameter is set, the engine will write the result of the computation to the output
folder, else it will include the data in the dictionary of the computed datasets.

Two validations are performed before running, which can raise errors:

* Semantic analysis: Equivalent to running the `semantic_analysis` method
* Data load analysis: Basic check of the data structure (names and types)

=====================
Example 3: Simple run
=====================

.. code-block:: python

    from vtlengine import run
    import pandas as pd

    script = """
        DS_A := DS_1 * 10;
    """

    data_structures = {
        'datasets': [
            {'name': 'DS_1',
             'DataStructure': [
                 {'name': 'Id_1',
                  'type':
                      'Integer',
                  'role': 'Identifier',
                  'nullable': False},
                 {'name': 'Me_1',
                  'type': 'Number',
                  'role': 'Measure',
                  'nullable': True}
             ]
             }
        ]
    }

    data_df = pd.DataFrame(
        {"Id_1": [1, 2, 3],
         "Me_1": [10, 20, 30]})

    datapoints = {"DS_1": data_df}

    run_result = run(script=script, data_structures=data_structures,
                     datapoints=datapoints)

    print(run_result)


returns:

.. code-block:: python

    {'DS_A': Dataset(name='DS_A', components={'Id_1': Component(name='Id_1', data_type="Integer", role="Identifier", nullable=False), 'Me_1': Component(name='Me_1', data_type="Number", role="Measure", nullable=True)}, data=  Id_1   Me_1
    0    1  100.0
    1    2  200.0
    2    3  300.0)}

================================
Example 4: Run from SDMX Dataset
================================

The `run_sdmx` method serves to execute a VTL script with input SDMX files, using get_datasets function from pysdmx.
Executes a VTL script using one or more `PandasDataset` instances from the `pysdmx` library.

This function prepares the required VTL data structures and datapoints, handles mapping from dataset structures to VTL identifiers,
and delegates execution to the VTL engine. It performs internal validation of dataset structures and the VTL script's input dependencies using DAG analysis.

Taking as input a xml file with the Dataflow and a metadata file with the DataStructureDefinition,
the function will create a dataset with the same structure as the input dataset.
.. code-block:: python

    from pathlib import Path

    from pysdmx.io import get_datasets

    from vtlengine import run_sdmx

    data = Path("Docs/_static/dataflow.xml")
    structure = Path("Docs/_static/metadata_minimal.xml")
    datasets = get_datasets(data, structure)
    script = "DS_r := DS_1 [calc Me_4 := OBS_VALUE];"
    print(run_sdmx(script, datasets))


Data contains the Dataflow as it is shown in this example:

.. code-block:: xml
    <?xml version="1.0" encoding="UTF-8"?>
    <message:GenericData xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                         xmlns:message="http://www.sdmx.org/resources/sdmxml/schemas/v2_1/message"
                         xmlns:generic="http://www.sdmx.org/resources/sdmxml/schemas/v2_1/data/generic"
                         xmlns:common="http://www.sdmx.org/resources/sdmxml/schemas/v2_1/common"
                         xsi:schemaLocation="http://www.sdmx.org/resources/sdmxml/schemas/v2_1/message https://registry.sdmx.org/schemas/v2_1/SDMXMessage.xsd">
        <message:Header>
            <message:ID>test</message:ID>
            <message:Test>true</message:Test>
            <message:Prepared>2021-03-08T17:05:06</message:Prepared>
            <message:Sender id="Unknown"/>
            <message:Receiver id="Not_supplied"/>
            <message:Structure structureID="BIS_DER" dimensionAtObservation="AllDimensions">
                <common:Structure>
                    <Ref agencyID="BIS" id="BIS_DER" version="1.0" class="DataStructure"/>
                </common:Structure>
            </message:Structure>
        </message:Header>
        <message:DataSet structureRef="BIS_DER" action="Replace">
            <generic:Attributes>
                <generic:Value id="DECIMALS" value="3"/>
                <generic:Value id="UNIT_MULT" value="6"/>
                <generic:Value id="UNIT_MEASURE" value="USD"/>
            </generic:Attributes>
            <generic:Obs>
                <generic:ObsKey>
                    <generic:Value id="FREQ" value="A"/>
                    <generic:Value id="DER_TYPE" value="U"/>
                    ...
                    <generic:Value id="TIME_PERIOD" value="2011"/>
                </generic:ObsKey>
            </generic:Obs>
        </message:DataSet>
    </message:GenericData>

Structure contains the metadata of the dataset, which is the same as the one used in the example above:

.. code-block:: xml
    <?xml version='1.0' encoding='UTF-8'?>
    <mes:Structure xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xml="http://www.w3.org/XML/1998/namespace"
                   xmlns:mes="http://www.sdmx.org/resources/sdmxml/schemas/v2_1/message"
                   xmlns:str="http://www.sdmx.org/resources/sdmxml/schemas/v2_1/structure"
                   xmlns:com="http://www.sdmx.org/resources/sdmxml/schemas/v2_1/common"
                   xsi:schemaLocation="http://www.sdmx.org/resources/sdmxml/schemas/v2_1/message https://registry.sdmx.org/schemas/v2_1/SDMXMessage.xsd">
        <mes:Header>
            <mes:ID>IREF534795</mes:ID>
            <mes:Test>false</mes:Test>
            <mes:Prepared>2021-03-05T14:11:16Z</mes:Prepared>
            <mes:Sender id="Unknown"/>
            <mes:Receiver id="not_supplied"/>
        </mes:Header>
        <mes:Structures>
            <str:DataStructures>
                <str:DataStructure urn="urn:sdmx:org.sdmx.infomodel.datastructure.DataStructure=BIS:BIS_DER(1.0)"
                                   isExternalReference="false" agencyID="BIS" id="BIS_DER" isFinal="false" version="1.0">
                    <com:Name xml:lang="en">BIS derivatives statistics</com:Name>
                    <str:DataStructureComponents>
                        <str:DimensionList>
                            <str:Dimension id="FREQ" position="1">...</str:Dimension>
                            <str:Dimension id="DER_TYPE" position="2">...</str:Dimension>
                            <str:Dimension id="DER_INSTR" position="3">...</str:Dimension>
                            <str:TimeDimension id="TIME_PERIOD" position="15">...</str:TimeDimension>
                        </str:DimensionList>
                        <str:MeasureList>
                            <str:PrimaryMeasure id="OBS_VALUE">...</str:PrimaryMeasure>
                        </str:MeasureList>
                    </str:DataStructureComponents>
                </str:DataStructure>
            </str:DataStructures>
        </mes:Structures>
    </mes:Structure>


As part with the compatibility with pysdmx, the function can also be used by taking as input a
TransformationScheme object:

.. code-block:: python

    from pysdmx.io import get_datasets
    from pysdmx.model.vtl import TransformationScheme, Transformation
    from vtlengine import run_sdmx

    data = Path("Docs/_static/dataflow.xml")
    structure = Path("Docs/_static/metadata_minimal.xml")
    datasets = get_datasets(data, structure)
    script = TransformationScheme(
        id="TS1",
        version="1.0",
        agency="BIS",
        vtl_version="2.1",
        items=[
            Transformation(
                id="T1",
                uri=None,
                urn=None,
                name=None,
                description=None,
                expression="BIS_DER [calc Me_4 := OBS_VALUE]",
                is_persistent=False,
                result="DS_r",
                annotations=(),
            )
        ],
    )
    print(run_sdmx(script, datasets))

Finally, the function can also map the input dataset to the output dataset, by using the VTLDataflowMapping
object from pysdmx:

.. code-block:: python

    from pysdmx.io import get_datasets
    from pysdmx.model.vtl import TransformationScheme, Transformation
    from pysdmx.model.vtl import VTLDataflowMapping
    from vtlengine import run_sdmx

    data = Path("Docs/_static/dataflow.xml")
    structure = Path("Docs/_static/metadata_minimal.xml")
    datasets = get_datasets(data, structure)
    script = TransformationScheme(
        id="TS1",
        version="1.0",
        agency="BIS",
        vtl_version="2.1",
        items=[
            Transformation(
                id="T1",
                uri=None,
                urn=None,
                name=None,
                description=None,
                expression="BIS_DER [calc Me_4 := OBS_VALUE]",
                is_persistent=False,
                result="DS_r",
                annotations=(),
            )
        ],
    )
    mapping = VtlDataflowMapping(
            dataflow="urn:sdmx:org.sdmx.infomodel.datastructure.Dataflow=MD:TEST_DF(1.0)",
            dataflow_alias="DS_1",
            id="VTL_MAP_1",
        )
    print(run_sdmx(script, datasets, mapping=mapping))


returns:

.. code-block:: python
    {'DS_r': Dataset(name='DS_r', components={'FREQ': {"name": "FREQ", "data_type": "String", "role": "Identifier", "nullable": false}, 'DER_TYPE': {"name": "DER_TYPE", "data_type": "String", "role": "Identifier", "nullable": false}, 'DER_INSTR': {"name": "DER_INSTR", "data_type": "String", "role": "Identifier", "nullable": false}, 'DER_RISK': {"name": "DER_RISK", "data_type": "String", "role": "Identifier", "nullable": false}, 'DER_REP_CTY': {"name": "DER_REP_CTY", "data_type": "String", "role": "Identifier", "nullable": false}, 'TIME_PERIOD': {"name": "TIME_PERIOD", "data_type": "Time_Period", "role": "Identifier", "nullable": false}, 'OBS_VALUE': {"name": "OBS_VALUE", "data_type": "String", "role": "Measure", "nullable": true}, 'Me_4': {"name": "Me_4", "data_type": "String", "role": "Measure", "nullable": true}}, data=  FREQ DER_TYPE DER_INSTR  ... TIME_PERIOD     OBS_VALUE          Me_4
    0    A        U         A  ...        2002
    1    A        U         A  ...        2003
    2    A        U         A  ...        2004  14206.490766  14206.490766
    3    A        U         A  ...        2005
    4    A        U         A  ...        2006
    5    A        U         A  ...        2007  29929.036014  29929.036014
    6    A        U         A  ...        2008
    7    A        U         A  ...        2009
    8    A        U         A  ...        2010  31040.395041  31040.395041
    9    A        U         A  ...        2011


Files used in the example can be found in the `Docs/_static` folder:

- :download:`dataflow.xml <_static/dataflow.xml>`
- :download:`metadata.xml <_static/metadata.xml>`

********
Prettify
********

The `prettify` method serves to format a VTL script to make it more readable.

.. code-block:: python

    from vtlengine import prettify
    script = """
        define hierarchical ruleset accountingEntry (variable rule ACCOUNTING_ENTRY) is
                        B = C - D errorcode "Balance (credit-debit)" errorlevel 4;
                        N = A - L errorcode "Net (assets-liabilities)" errorlevel 4
                    end hierarchical ruleset;

        DS_r := check_hierarchy(BOP, accountingEntry rule ACCOUNTING_ENTRY dataset);
        """
    prettified_script = prettify(script)
    print(prettified_script)

returns:

.. code-block:: python

    """
    define hierarchical ruleset accountingEntry(variable rule ACCOUNTING_ENTRY) is
        B = C - D
	    errorcode "Balance (credit-debit)"
	    errorlevel 4;

	    N = A - L
	    errorcode "Net (assets-liabilities)"
	    errorlevel 4
    end hierarchical ruleset;

    DS_r :=
	    check_hierarchy(
		    BOP,
		    accountingEntry,
		    rule ACCOUNTING_ENTRY);
    """

For more information on usage, please refer to the `API documentation <https://docs.vtlengine.meaningfuldata.eu/api.html>`_
