# Generated from Vtl.g4 by ANTLR 4.9.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys

if sys.version_info[1] > 5:
    from typing import TextIO
else:
    from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\u0109")
        buf.write("\u0784\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write('\4\37\t\37\4 \t \4!\t!\4"\t"\4#\t#\4$\t$\4%\t%\4&\t')
        buf.write("&\4'\t'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\49\t9\4:\t:\4;\t")
        buf.write(";\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C\tC\4D\t")
        buf.write("D\4E\tE\4F\tF\4G\tG\4H\tH\4I\tI\4J\tJ\4K\tK\4L\tL\4M\t")
        buf.write("M\4N\tN\4O\tO\4P\tP\4Q\tQ\4R\tR\4S\tS\4T\tT\4U\tU\4V\t")
        buf.write("V\4W\tW\4X\tX\4Y\tY\4Z\tZ\4[\t[\4\\\t\\\4]\t]\4^\t^\4")
        buf.write("_\t_\4`\t`\4a\ta\4b\tb\4c\tc\4d\td\4e\te\4f\tf\4g\tg\4")
        buf.write("h\th\4i\ti\4j\tj\4k\tk\4l\tl\4m\tm\4n\tn\4o\to\4p\tp\4")
        buf.write("q\tq\4r\tr\4s\ts\4t\tt\4u\tu\4v\tv\4w\tw\4x\tx\4y\ty\4")
        buf.write("z\tz\4{\t{\4|\t|\4}\t}\4~\t~\4\177\t\177\4\u0080\t\u0080")
        buf.write("\4\u0081\t\u0081\4\u0082\t\u0082\3\2\5\2\u0106\n\2\3\2")
        buf.write("\7\2\u0109\n\2\f\2\16\2\u010c\13\2\3\2\7\2\u010f\n\2\f")
        buf.write("\2\16\2\u0112\13\2\3\2\7\2\u0115\n\2\f\2\16\2\u0118\13")
        buf.write("\2\3\2\5\2\u011b\n\2\3\2\3\2\3\2\5\2\u0120\n\2\3\3\3\3")
        buf.write("\3\3\5\3\u0125\n\3\3\3\3\3\5\3\u0129\n\3\3\4\3\4\3\4\3")
        buf.write("\4\3\5\3\5\5\5\u0131\n\5\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3")
        buf.write("\6\5\6\u013b\n\6\3\6\3\6\7\6\u013f\n\6\f\6\16\6\u0142")
        buf.write("\13\6\3\6\3\6\5\6\u0146\n\6\3\6\3\6\3\6\3\6\3\6\3\6\3")
        buf.write("\6\3\6\3\6\5\6\u0151\n\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3")
        buf.write("\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\7\6\u0166")
        buf.write("\n\6\f\6\16\6\u0169\13\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\5")
        buf.write("\6\u0172\n\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3")
        buf.write("\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6")
        buf.write("\3\6\5\6\u018d\n\6\3\6\3\6\3\6\3\6\5\6\u0193\n\6\7\6\u0195")
        buf.write("\n\6\f\6\16\6\u0198\13\6\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3")
        buf.write("\7\3\7\3\7\3\7\5\7\u01a5\n\7\3\b\3\b\3\b\3\b\5\b\u01ab")
        buf.write("\n\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3")
        buf.write("\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b")
        buf.write("\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3")
        buf.write("\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b")
        buf.write("\3\b\3\b\3\b\3\b\3\b\3\b\5\b\u01e8\n\b\3\t\3\t\3\t\3\t")
        buf.write("\3\t\3\t\3\t\3\t\3\t\3\n\3\n\3\n\7\n\u01f6\n\n\f\n\16")
        buf.write("\n\u01f9\13\n\3\13\3\13\5\13\u01fd\n\13\3\13\3\13\5\13")
        buf.write("\u0201\n\13\3\13\5\13\u0204\n\13\3\f\3\f\5\f\u0208\n\f")
        buf.write("\3\f\3\f\3\f\3\r\3\r\3\r\3\r\5\r\u0211\n\r\3\r\3\r\3\r")
        buf.write("\3\r\5\r\u0217\n\r\7\r\u0219\n\r\f\r\16\r\u021c\13\r\3")
        buf.write("\16\3\16\3\16\3\16\5\16\u0222\n\16\3\16\3\16\3\16\7\16")
        buf.write("\u0227\n\16\f\16\16\16\u022a\13\16\3\17\5\17\u022d\n\17")
        buf.write("\3\17\3\17\3\17\3\17\3\17\5\17\u0234\n\17\3\20\3\20\5")
        buf.write("\20\u0238\n\20\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21")
        buf.write("\3\21\3\22\3\22\3\22\7\22\u0246\n\22\f\22\16\22\u0249")
        buf.write("\13\22\3\23\3\23\5\23\u024d\n\23\3\23\3\23\3\23\3\23\5")
        buf.write("\23\u0253\n\23\3\23\3\23\5\23\u0257\n\23\3\23\5\23\u025a")
        buf.write("\n\23\3\24\3\24\3\24\3\24\7\24\u0260\n\24\f\24\16\24\u0263")
        buf.write("\13\24\3\25\3\25\3\25\5\25\u0268\n\25\3\26\3\26\3\26\5")
        buf.write("\26\u026d\n\26\3\27\3\27\3\27\3\27\3\27\3\27\3\27\7\27")
        buf.write("\u0276\n\27\f\27\16\27\u0279\13\27\5\27\u027b\n\27\3\27")
        buf.write("\3\27\3\27\5\27\u0280\n\27\3\27\3\27\3\27\3\27\3\27\3")
        buf.write("\30\3\30\3\30\3\30\5\30\u028b\n\30\3\31\3\31\3\31\3\31")
        buf.write("\5\31\u0291\n\31\3\31\3\31\3\31\5\31\u0296\n\31\7\31\u0298")
        buf.write("\n\31\f\31\16\31\u029b\13\31\5\31\u029d\n\31\3\31\3\31")
        buf.write("\3\32\3\32\3\32\3\32\3\32\5\32\u02a6\n\32\3\32\3\32\3")
        buf.write("\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32")
        buf.write("\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32")
        buf.write("\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32")
        buf.write("\3\32\3\32\3\32\3\32\5\32\u02cf\n\32\3\32\3\32\3\32\3")
        buf.write("\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32")
        buf.write("\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32")
        buf.write("\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32")
        buf.write("\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32")
        buf.write("\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32")
        buf.write("\5\32\u030b\n\32\3\32\3\32\5\32\u030f\n\32\3\32\3\32\3")
        buf.write("\32\3\32\3\32\3\32\3\32\3\32\3\32\5\32\u031a\n\32\3\32")
        buf.write("\3\32\5\32\u031e\n\32\3\32\3\32\3\32\3\32\3\32\3\32\3")
        buf.write("\32\3\32\3\32\5\32\u0329\n\32\3\32\3\32\3\32\3\32\3\32")
        buf.write("\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32")
        buf.write("\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32")
        buf.write("\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32")
        buf.write("\3\32\3\32\3\32\3\32\3\32\3\32\3\32\5\32\u0358\n\32\3")
        buf.write("\33\3\33\3\33\3\33\3\33\3\33\5\33\u0360\n\33\3\34\3\34")
        buf.write("\3\34\3\34\7\34\u0366\n\34\f\34\16\34\u0369\13\34\3\34")
        buf.write("\3\34\3\35\3\35\3\35\3\35\7\35\u0371\n\35\f\35\16\35\u0374")
        buf.write("\13\35\3\35\3\35\3\36\3\36\3\36\3\36\3\36\3\36\5\36\u037e")
        buf.write("\n\36\3\36\3\36\3\36\5\36\u0383\n\36\7\36\u0385\n\36\f")
        buf.write("\36\16\36\u0388\13\36\3\36\3\36\3\36\5\36\u038d\n\36\3")
        buf.write("\36\3\36\5\36\u0391\n\36\3\36\3\36\3\37\3\37\3\37\3\37")
        buf.write("\3\37\3\37\5\37\u039b\n\37\3\37\3\37\5\37\u039f\n\37\3")
        buf.write("\37\3\37\3 \3 \3 \5 \u03a6\n \3 \3 \3!\3!\3!\3!\3!\3!")
        buf.write('\3!\3"\3"\3"\3"\3"\5"\u03b6\n"\3"\3"\3#\3#\3')
        buf.write("#\3#\3#\5#\u03bf\n#\3#\3#\3#\5#\u03c4\n#\5#\u03c6\n#\3")
        buf.write("#\3#\5#\u03ca\n#\3#\3#\3$\3$\3$\3$\5$\u03d2\n$\3$\5$\u03d5")
        buf.write("\n$\3$\3$\5$\u03d9\n$\3$\5$\u03dc\n$\3$\3$\3%\3%\3%\3")
        buf.write("%\3%\3%\3%\3%\3%\7%\u03e9\n%\f%\16%\u03ec\13%\5%\u03ee")
        buf.write("\n%\3%\5%\u03f1\n%\3%\3%\3&\3&\3&\3&\3&\3&\3&\3&\3&\7")
        buf.write("&\u03fe\n&\f&\16&\u0401\13&\5&\u0403\n&\3&\3&\5&\u0407")
        buf.write("\n&\3&\5&\u040a\n&\3&\5&\u040d\n&\3&\5&\u0410\n&\3&\3")
        buf.write("&\3'\3'\3'\3(\3(\3(\3)\3)\3)\3)\3)\3)\3)\3)\3)\7)\u0423")
        buf.write("\n)\f)\16)\u0426\13)\5)\u0428\n)\3)\3)\5)\u042c\n)\3)")
        buf.write("\3)\5)\u0430\n)\3)\3)\5)\u0434\n)\3)\3)\5)\u0438\n)\3")
        buf.write(")\3)\3*\3*\3*\3*\3*\3*\3*\3*\3*\3*\5*\u0446\n*\3+\3+\5")
        buf.write("+\u044a\n+\3+\3+\5+\u044e\n+\3+\3+\7+\u0452\n+\f+\16+")
        buf.write("\u0455\13+\3+\3+\3+\5+\u045a\n+\3+\5+\u045d\n+\3+\5+\u0460")
        buf.write("\n+\3+\3+\3+\3,\3,\3,\3,\3,\7,\u046a\n,\f,\16,\u046d\13")
        buf.write(",\3-\3-\3-\3-\5-\u0473\n-\3-\3-\3-\5-\u0478\n-\7-\u047a")
        buf.write("\n-\f-\16-\u047d\13-\3.\3.\3.\5.\u0482\n.\3.\3.\3.\3.")
        buf.write("\3.\3/\3/\3/\3/\3/\3/\3/\3/\3/\3/\3/\5/\u0494\n/\3\60")
        buf.write("\3\60\3\60\3\60\5\60\u049a\n\60\3\60\3\60\3\61\3\61\3")
        buf.write("\61\5\61\u04a1\n\61\3\61\3\61\3\61\3\61\5\61\u04a7\n\61")
        buf.write("\7\61\u04a9\n\61\f\61\16\61\u04ac\13\61\3\61\3\61\3\61")
        buf.write("\3\61\7\61\u04b2\n\61\f\61\16\61\u04b5\13\61\5\61\u04b7")
        buf.write("\n\61\3\62\5\62\u04ba\n\62\3\62\3\62\3\62\5\62\u04bf\n")
        buf.write("\62\3\62\3\62\5\62\u04c3\n\62\3\62\5\62\u04c6\n\62\3\63")
        buf.write("\5\63\u04c9\n\63\3\63\3\63\3\63\7\63\u04ce\n\63\f\63\16")
        buf.write("\63\u04d1\13\63\3\64\3\64\5\64\u04d5\n\64\3\64\3\64\3")
        buf.write("\64\5\64\u04da\n\64\3\64\7\64\u04dd\n\64\f\64\16\64\u04e0")
        buf.write("\13\64\3\65\3\65\3\65\3\65\3\66\5\66\u04e7\n\66\3\66\3")
        buf.write("\66\3\66\3\66\7\66\u04ed\n\66\f\66\16\66\u04f0\13\66\3")
        buf.write("\66\5\66\u04f3\n\66\3\66\5\66\u04f6\n\66\3\67\5\67\u04f9")
        buf.write("\n\67\3\67\3\67\3\67\7\67\u04fe\n\67\f\67\16\67\u0501")
        buf.write("\13\67\38\38\38\38\39\39\39\39\79\u050b\n9\f9\169\u050e")
        buf.write("\139\3:\3:\3:\3:\7:\u0514\n:\f:\16:\u0517\13:\3;\3;\3")
        buf.write(";\5;\u051c\n;\3<\3<\3<\3<\5<\u0522\n<\3<\3<\3<\3<\3<\5")
        buf.write("<\u0529\n<\3<\3<\3<\3<\3<\5<\u0530\n<\3<\3<\3<\3<\3<\5")
        buf.write("<\u0537\n<\3<\3<\7<\u053b\n<\f<\16<\u053e\13<\3=\3=\3")
        buf.write("=\3>\3>\3?\3?\3?\7?\u0548\n?\f?\16?\u054b\13?\3@\5@\u054e")
        buf.write("\n@\3@\3@\3@\3@\3A\3A\3A\7A\u0557\nA\fA\16A\u055a\13A")
        buf.write("\3B\5B\u055d\nB\3B\3B\3C\3C\3C\5C\u0564\nC\3C\5C\u0567")
        buf.write("\nC\3D\3D\3D\3E\3E\3E\3E\3E\3E\3E\3E\7E\u0574\nE\fE\16")
        buf.write("E\u0577\13E\3F\3F\3F\3F\3F\3F\3F\3F\3F\3F\3F\3F\3F\5F")
        buf.write("\u0586\nF\3F\3F\3F\3F\3F\3F\3F\3F\3F\3F\3F\3F\3F\3F\3")
        buf.write("F\3F\3F\3F\3F\3F\3F\3F\3F\3F\3F\3F\3F\3F\3F\3F\3F\3F\3")
        buf.write("F\3F\3F\3F\3F\3F\3F\3F\3F\5F\u05b1\nF\3G\3G\3G\3G\7G\u05b7")
        buf.write("\nG\fG\16G\u05ba\13G\3H\5H\u05bd\nH\3H\3H\3H\3H\3I\3I")
        buf.write("\3I\3I\3I\3I\5I\u05c9\nI\3J\3J\3J\3J\7J\u05cf\nJ\fJ\16")
        buf.write("J\u05d2\13J\3K\3K\3K\3K\3K\5K\u05d9\nK\3L\3L\3L\3L\7L")
        buf.write("\u05df\nL\fL\16L\u05e2\13L\3M\3M\3M\3M\3M\5M\u05e9\nM")
        buf.write("\3N\3N\3N\3N\3N\3O\3O\3O\3O\3O\3P\3P\3P\3P\3P\3P\3P\3")
        buf.write("P\3P\7P\u05fe\nP\fP\16P\u0601\13P\3Q\3Q\3Q\5Q\u0606\n")
        buf.write("Q\3Q\3Q\3Q\5Q\u060b\nQ\5Q\u060d\nQ\3R\3R\3R\3R\3R\7R\u0614")
        buf.write("\nR\fR\16R\u0617\13R\3R\3R\3R\3R\3R\3R\3R\3R\3R\3R\3R")
        buf.write("\3R\3R\3R\3R\3R\3R\3R\3R\3R\3R\7R\u062e\nR\fR\16R\u0631")
        buf.write("\13R\3R\3R\5R\u0635\nR\3S\3S\3S\3S\3S\3S\3S\3T\3T\3T\3")
        buf.write("T\3T\3T\3T\3T\3T\3T\5T\u0648\nT\3T\3T\3U\3U\3U\3U\3U\5")
        buf.write("U\u0651\nU\3U\3U\3U\3U\5U\u0657\nU\7U\u0659\nU\fU\16U")
        buf.write("\u065c\13U\3U\5U\u065f\nU\3U\5U\u0662\nU\3U\3U\3V\3V\3")
        buf.write("V\3V\3V\5V\u066b\nV\3V\3V\3V\3V\5V\u0671\nV\7V\u0673\n")
        buf.write("V\fV\16V\u0676\13V\3V\3V\5V\u067a\nV\3V\5V\u067d\nV\3")
        buf.write("W\3W\3X\3X\3X\3X\7X\u0685\nX\fX\16X\u0688\13X\3X\5X\u068b")
        buf.write("\nX\3Y\3Y\5Y\u068f\nY\3Y\5Y\u0692\nY\3Y\3Y\5Y\u0696\n")
        buf.write("Y\3Z\3Z\3Z\3Z\3Z\3[\3[\3[\3[\3[\5[\u06a2\n[\3\\\3\\\3")
        buf.write("\\\3]\3]\3^\3^\3_\3_\3`\3`\3a\3a\3b\3b\3c\3c\3d\3d\3e")
        buf.write("\3e\3f\3f\3g\3g\3g\3g\3g\3g\5g\u06c1\ng\3h\3h\3i\3i\3")
        buf.write("j\3j\3j\5j\u06ca\nj\3j\5j\u06cd\nj\3j\5j\u06d0\nj\3j\5")
        buf.write("j\u06d3\nj\3k\3k\3l\3l\3m\3m\3n\3n\3n\3n\3n\3n\3n\3n\7")
        buf.write("n\u06e3\nn\fn\16n\u06e6\13n\3n\3n\5n\u06ea\nn\3o\3o\3")
        buf.write("o\3o\3o\3o\5o\u06f2\no\3p\3p\3p\3p\3p\5p\u06f9\np\3q\3")
        buf.write("q\3q\3q\3q\7q\u0700\nq\fq\16q\u0703\13q\3q\3q\5q\u0707")
        buf.write("\nq\3r\3r\3r\5r\u070c\nr\3s\3s\5s\u0710\ns\3t\3t\3t\5")
        buf.write("t\u0715\nt\3u\3u\3u\3u\3u\3u\3u\3u\3u\3u\3u\5u\u0722\n")
        buf.write("u\3v\3v\3v\3v\3v\3v\3v\3v\5v\u072c\nv\3v\5v\u072f\nv\3")
        buf.write("v\3v\3v\3v\3v\3v\3v\5v\u0738\nv\3v\3v\5v\u073c\nv\5v\u073e")
        buf.write("\nv\3w\3w\3w\7w\u0743\nw\fw\16w\u0746\13w\3x\3x\3x\7x")
        buf.write("\u074b\nx\fx\16x\u074e\13x\3y\3y\3y\7y\u0753\ny\fy\16")
        buf.write("y\u0756\13y\3y\3y\3y\3z\3z\3z\5z\u075e\nz\3{\3{\3{\3{")
        buf.write("\3{\5{\u0765\n{\3|\3|\3|\3|\3|\5|\u076c\n|\3}\3}\3~\3")
        buf.write("~\3~\3~\3\177\3\177\3\177\3\177\3\u0080\3\u0080\3\u0080")
        buf.write("\3\u0080\3\u0081\3\u0081\3\u0081\3\u0081\3\u0082\3\u0082")
        buf.write("\3\u0082\3\u0082\3\u0082\3\u053c\3\n\u0083\2\4\6\b\n\f")
        buf.write('\16\20\22\24\26\30\32\34\36 "$&(*,.\60\62\64\668:<>@')
        buf.write("BDFHJLNPRTVXZ\\^`bdfhjlnprtvxz|~\u0080\u0082\u0084\u0086")
        buf.write("\u0088\u008a\u008c\u008e\u0090\u0092\u0094\u0096\u0098")
        buf.write("\u009a\u009c\u009e\u00a0\u00a2\u00a4\u00a6\u00a8\u00aa")
        buf.write("\u00ac\u00ae\u00b0\u00b2\u00b4\u00b6\u00b8\u00ba\u00bc")
        buf.write("\u00be\u00c0\u00c2\u00c4\u00c6\u00c8\u00ca\u00cc\u00ce")
        buf.write("\u00d0\u00d2\u00d4\u00d6\u00d8\u00da\u00dc\u00de\u00e0")
        buf.write("\u00e2\u00e4\u00e6\u00e8\u00ea\u00ec\u00ee\u00f0\u00f2")
        buf.write("\u00f4\u00f6\u00f8\u00fa\u00fc\u00fe\u0100\u0102\2\36")
        buf.write("\4\2\5\6\63\63\3\2\7\b\3\2\5\6\3\2\t\16\3\2\r\16\3\2\61")
        buf.write("\62\3\2\65\66\3\2vw\3\2\t\r\4\2II\u00d0\u00d0\4\2tt\u00f6")
        buf.write("\u00f6\3\2ST\4\2IIuu\5\2IIuu\u00e7\u00e7\3\2\u00e0\u00e5")
        buf.write("\4\2zz\u00db\u00db\5\2zz\u0081\u0081\u00da\u00da\4\2I")
        buf.write("I\u00df\u00df\3\2OP\4\2NN\u0094\u0098\5\2QRdg\u008d\u0090")
        buf.write("\4\2\u00f0\u00f0\u00f3\u00f3\3\2\u00c1\u00c4\4\2\u00f0")
        buf.write("\u00f0\u00f3\u00f6\4\2\u00a9\u00aa\u00ad\u00af\6\2\u00a9")
        buf.write("\u00ae\u00d1\u00d1\u00e8\u00e8\u0103\u0103\4\2\5\5\7\7")
        buf.write("\4\2II\u00f4\u00f4\2\u083f\2\u011f\3\2\2\2\4\u0128\3\2")
        buf.write("\2\2\6\u012a\3\2\2\2\b\u0130\3\2\2\2\n\u0171\3\2\2\2\f")
        buf.write("\u01a4\3\2\2\2\16\u01e7\3\2\2\2\20\u01e9\3\2\2\2\22\u01f2")
        buf.write("\3\2\2\2\24\u01fc\3\2\2\2\26\u0205\3\2\2\2\30\u020c\3")
        buf.write("\2\2\2\32\u0221\3\2\2\2\34\u022c\3\2\2\2\36\u0235\3\2")
        buf.write('\2\2 \u0239\3\2\2\2"\u0242\3\2\2\2$\u024c\3\2\2\2&\u025b')
        buf.write("\3\2\2\2(\u0264\3\2\2\2*\u026c\3\2\2\2,\u026e\3\2\2\2")
        buf.write(".\u0286\3\2\2\2\60\u028c\3\2\2\2\62\u0357\3\2\2\2\64\u035f")
        buf.write("\3\2\2\2\66\u0361\3\2\2\28\u036c\3\2\2\2:\u0377\3\2\2")
        buf.write("\2<\u0394\3\2\2\2>\u03a2\3\2\2\2@\u03a9\3\2\2\2B\u03b0")
        buf.write("\3\2\2\2D\u03b9\3\2\2\2F\u03cd\3\2\2\2H\u03df\3\2\2\2")
        buf.write("J\u03f4\3\2\2\2L\u0413\3\2\2\2N\u0416\3\2\2\2P\u0419\3")
        buf.write("\2\2\2R\u0445\3\2\2\2T\u0449\3\2\2\2V\u0464\3\2\2\2X\u046e")
        buf.write("\3\2\2\2Z\u0481\3\2\2\2\\\u0493\3\2\2\2^\u0495\3\2\2\2")
        buf.write("`\u049d\3\2\2\2b\u04b9\3\2\2\2d\u04c8\3\2\2\2f\u04d2\3")
        buf.write("\2\2\2h\u04e1\3\2\2\2j\u04e6\3\2\2\2l\u04f8\3\2\2\2n\u0502")
        buf.write("\3\2\2\2p\u0506\3\2\2\2r\u050f\3\2\2\2t\u051b\3\2\2\2")
        buf.write("v\u051d\3\2\2\2x\u053f\3\2\2\2z\u0542\3\2\2\2|\u0544\3")
        buf.write("\2\2\2~\u054d\3\2\2\2\u0080\u0553\3\2\2\2\u0082\u055c")
        buf.write("\3\2\2\2\u0084\u0560\3\2\2\2\u0086\u0568\3\2\2\2\u0088")
        buf.write("\u056b\3\2\2\2\u008a\u05b0\3\2\2\2\u008c\u05b2\3\2\2\2")
        buf.write("\u008e\u05bc\3\2\2\2\u0090\u05c8\3\2\2\2\u0092\u05ca\3")
        buf.write("\2\2\2\u0094\u05d8\3\2\2\2\u0096\u05da\3\2\2\2\u0098\u05e8")
        buf.write("\3\2\2\2\u009a\u05ea\3\2\2\2\u009c\u05ef\3\2\2\2\u009e")
        buf.write("\u05f4\3\2\2\2\u00a0\u060c\3\2\2\2\u00a2\u0634\3\2\2\2")
        buf.write("\u00a4\u0636\3\2\2\2\u00a6\u063d\3\2\2\2\u00a8\u064b\3")
        buf.write("\2\2\2\u00aa\u0665\3\2\2\2\u00ac\u067e\3\2\2\2\u00ae\u0680")
        buf.write("\3\2\2\2\u00b0\u068c\3\2\2\2\u00b2\u0697\3\2\2\2\u00b4")
        buf.write("\u06a1\3\2\2\2\u00b6\u06a3\3\2\2\2\u00b8\u06a6\3\2\2\2")
        buf.write("\u00ba\u06a8\3\2\2\2\u00bc\u06aa\3\2\2\2\u00be\u06ac\3")
        buf.write("\2\2\2\u00c0\u06ae\3\2\2\2\u00c2\u06b0\3\2\2\2\u00c4\u06b2")
        buf.write("\3\2\2\2\u00c6\u06b4\3\2\2\2\u00c8\u06b6\3\2\2\2\u00ca")
        buf.write("\u06b8\3\2\2\2\u00cc\u06c0\3\2\2\2\u00ce\u06c2\3\2\2\2")
        buf.write("\u00d0\u06c4\3\2\2\2\u00d2\u06c9\3\2\2\2\u00d4\u06d4\3")
        buf.write("\2\2\2\u00d6\u06d6\3\2\2\2\u00d8\u06d8\3\2\2\2\u00da\u06e9")
        buf.write("\3\2\2\2\u00dc\u06f1\3\2\2\2\u00de\u06f3\3\2\2\2\u00e0")
        buf.write("\u06fa\3\2\2\2\u00e2\u0708\3\2\2\2\u00e4\u070d\3\2\2\2")
        buf.write("\u00e6\u0714\3\2\2\2\u00e8\u0721\3\2\2\2\u00ea\u073d\3")
        buf.write("\2\2\2\u00ec\u073f\3\2\2\2\u00ee\u0747\3\2\2\2\u00f0\u074f")
        buf.write("\3\2\2\2\u00f2\u075d\3\2\2\2\u00f4\u0764\3\2\2\2\u00f6")
        buf.write("\u0766\3\2\2\2\u00f8\u076d\3\2\2\2\u00fa\u076f\3\2\2\2")
        buf.write("\u00fc\u0773\3\2\2\2\u00fe\u0777\3\2\2\2\u0100\u077b\3")
        buf.write("\2\2\2\u0102\u077f\3\2\2\2\u0104\u0106\5\4\3\2\u0105\u0104")
        buf.write("\3\2\2\2\u0105\u0106\3\2\2\2\u0106\u010a\3\2\2\2\u0107")
        buf.write("\u0109\7\u0106\2\2\u0108\u0107\3\2\2\2\u0109\u010c\3\2")
        buf.write("\2\2\u010a\u0108\3\2\2\2\u010a\u010b\3\2\2\2\u010b\u0110")
        buf.write("\3\2\2\2\u010c\u010a\3\2\2\2\u010d\u010f\7\u0107\2\2\u010e")
        buf.write("\u010d\3\2\2\2\u010f\u0112\3\2\2\2\u0110\u010e\3\2\2\2")
        buf.write("\u0110\u0111\3\2\2\2\u0111\u0113\3\2\2\2\u0112\u0110\3")
        buf.write("\2\2\2\u0113\u0115\7\u0105\2\2\u0114\u0105\3\2\2\2\u0115")
        buf.write("\u0118\3\2\2\2\u0116\u0114\3\2\2\2\u0116\u0117\3\2\2\2")
        buf.write("\u0117\u011a\3\2\2\2\u0118\u0116\3\2\2\2\u0119\u011b\5")
        buf.write("\4\3\2\u011a\u0119\3\2\2\2\u011a\u011b\3\2\2\2\u011b\u011c")
        buf.write("\3\2\2\2\u011c\u0120\7\2\2\3\u011d\u0120\7\u0106\2\2\u011e")
        buf.write("\u0120\7\u0107\2\2\u011f\u0116\3\2\2\2\u011f\u011d\3\2")
        buf.write("\2\2\u011f\u011e\3\2\2\2\u0120\3\3\2\2\2\u0121\u0122\5")
        buf.write("\u00c2b\2\u0122\u0123\7\25\2\2\u0123\u0125\3\2\2\2\u0124")
        buf.write("\u0121\3\2\2\2\u0124\u0125\3\2\2\2\u0125\u0126\3\2\2\2")
        buf.write("\u0126\u0129\5\n\6\2\u0127\u0129\5\6\4\2\u0128\u0124\3")
        buf.write("\2\2\2\u0128\u0127\3\2\2\2\u0129\5\3\2\2\2\u012a\u012b")
        buf.write("\5\u00c2b\2\u012b\u012c\7}\2\2\u012c\u012d\5\n\6\2\u012d")
        buf.write("\7\3\2\2\2\u012e\u0131\5\n\6\2\u012f\u0131\7t\2\2\u0130")
        buf.write("\u012e\3\2\2\2\u0130\u012f\3\2\2\2\u0131\t\3\2\2\2\u0132")
        buf.write("\u0133\b\6\1\2\u0133\u0140\5\62\32\2\u0134\u013a\7\3\2")
        buf.write("\2\u0135\u013b\5R*\2\u0136\u0137\5\n\6\2\u0137\u0138\7")
        buf.write("\25\2\2\u0138\u0139\5\n\6\2\u0139\u013b\3\2\2\2\u013a")
        buf.write("\u0135\3\2\2\2\u013a\u0136\3\2\2\2\u013b\u013c\3\2\2\2")
        buf.write("\u013c\u013d\7\4\2\2\u013d\u013f\3\2\2\2\u013e\u0134\3")
        buf.write("\2\2\2\u013f\u0142\3\2\2\2\u0140\u013e\3\2\2\2\u0140\u0141")
        buf.write("\3\2\2\2\u0141\u0145\3\2\2\2\u0142\u0140\3\2\2\2\u0143")
        buf.write("\u0144\7\26\2\2\u0144\u0146\5\u00c4c\2\u0145\u0143\3\2")
        buf.write("\2\2\u0145\u0146\3\2\2\2\u0146\u0172\3\2\2\2\u0147\u0148")
        buf.write("\t\2\2\2\u0148\u0172\5\n\6\23\u0149\u014a\7D\2\2\u014a")
        buf.write("\u014b\7\17\2\2\u014b\u014c\5\n\6\2\u014c\u014d\7?\2\2")
        buf.write("\u014d\u0150\5\n\6\2\u014e\u014f\7?\2\2\u014f\u0151\5")
        buf.write("\u00f8}\2\u0150\u014e\3\2\2\2\u0150\u0151\3\2\2\2\u0151")
        buf.write("\u0152\3\2\2\2\u0152\u0153\7\20\2\2\u0153\u0172\3\2\2")
        buf.write("\2\u0154\u0155\7\30\2\2\u0155\u0156\5\n\6\2\u0156\u0157")
        buf.write("\7\32\2\2\u0157\u0158\5\n\6\2\u0158\u0159\7\33\2\2\u0159")
        buf.write("\u015a\5\n\6\t\u015a\u0172\3\2\2\2\u015b\u015c\7\31\2")
        buf.write("\2\u015c\u015d\7\u00b9\2\2\u015d\u015e\5\n\6\2\u015e\u015f")
        buf.write("\7\32\2\2\u015f\u0167\5\n\6\2\u0160\u0161\7\u00b9\2\2")
        buf.write("\u0161\u0162\5\n\6\2\u0162\u0163\7\32\2\2\u0163\u0164")
        buf.write("\5\n\6\2\u0164\u0166\3\2\2\2\u0165\u0160\3\2\2\2\u0166")
        buf.write("\u0169\3\2\2\2\u0167\u0165\3\2\2\2\u0167\u0168\3\2\2\2")
        buf.write("\u0168\u016a\3\2\2\2\u0169\u0167\3\2\2\2\u016a\u016b\7")
        buf.write("\33\2\2\u016b\u016c\5\n\6\b\u016c\u0172\3\2\2\2\u016d")
        buf.write("\u0172\5\f\7\2\u016e\u0172\5\62\32\2\u016f\u0172\5\u00ce")
        buf.write("h\2\u0170\u0172\7\u00f7\2\2\u0171\u0132\3\2\2\2\u0171")
        buf.write("\u0147\3\2\2\2\u0171\u0149\3\2\2\2\u0171\u0154\3\2\2\2")
        buf.write("\u0171\u015b\3\2\2\2\u0171\u016d\3\2\2\2\u0171\u016e\3")
        buf.write("\2\2\2\u0171\u016f\3\2\2\2\u0171\u0170\3\2\2\2\u0172\u0196")
        buf.write("\3\2\2\2\u0173\u0174\f\22\2\2\u0174\u0175\t\3\2\2\u0175")
        buf.write("\u0195\5\n\6\23\u0176\u0177\f\21\2\2\u0177\u0178\t\4\2")
        buf.write("\2\u0178\u0195\5\n\6\22\u0179\u017a\f\20\2\2\u017a\u017b")
        buf.write("\t\5\2\2\u017b\u0195\5\n\6\21\u017c\u017d\f\f\2\2\u017d")
        buf.write("\u017e\t\6\2\2\u017e\u0195\5\n\6\r\u017f\u0180\f\13\2")
        buf.write("\2\u0180\u0181\7\60\2\2\u0181\u0195\5\n\6\f\u0182\u0183")
        buf.write("\f\n\2\2\u0183\u0184\t\7\2\2\u0184\u0195\5\n\6\13\u0185")
        buf.write("\u0186\f\5\2\2\u0186\u0187\7_\2\2\u0187\u0195\5\n\6\6")
        buf.write("\u0188\u0189\f\17\2\2\u0189\u018c\t\b\2\2\u018a\u018d")
        buf.write("\58\35\2\u018b\u018d\7\u00f7\2\2\u018c\u018a\3\2\2\2\u018c")
        buf.write("\u018b\3\2\2\2\u018d\u0195\3\2\2\2\u018e\u018f\f\16\2")
        buf.write("\2\u018f\u0190\7D\2\2\u0190\u0192\5\n\6\2\u0191\u0193")
        buf.write("\7I\2\2\u0192\u0191\3\2\2\2\u0192\u0193\3\2\2\2\u0193")
        buf.write("\u0195\3\2\2\2\u0194\u0173\3\2\2\2\u0194\u0176\3\2\2\2")
        buf.write("\u0194\u0179\3\2\2\2\u0194\u017c\3\2\2\2\u0194\u017f\3")
        buf.write("\2\2\2\u0194\u0182\3\2\2\2\u0194\u0185\3\2\2\2\u0194\u0188")
        buf.write("\3\2\2\2\u0194\u018e\3\2\2\2\u0195\u0198\3\2\2\2\u0196")
        buf.write("\u0194\3\2\2\2\u0196\u0197\3\2\2\2\u0197\13\3\2\2\2\u0198")
        buf.write("\u0196\3\2\2\2\u0199\u01a5\5F$\2\u019a\u01a5\5*\26\2\u019b")
        buf.write("\u01a5\5\u00a8U\2\u019c\u01a5\5\u00aaV\2\u019d\u01a5\5")
        buf.write("T+\2\u019e\u01a5\5\u008aF\2\u019f\u01a5\5\16\b\2\u01a0")
        buf.write("\u01a5\5\u00a2R\2\u01a1\u01a5\5\u00a4S\2\u01a2\u01a5\5")
        buf.write("\60\31\2\u01a3\u01a5\5^\60\2\u01a4\u0199\3\2\2\2\u01a4")
        buf.write("\u019a\3\2\2\2\u01a4\u019b\3\2\2\2\u01a4\u019c\3\2\2\2")
        buf.write("\u01a4\u019d\3\2\2\2\u01a4\u019e\3\2\2\2\u01a4\u019f\3")
        buf.write("\2\2\2\u01a4\u01a0\3\2\2\2\u01a4\u01a1\3\2\2\2\u01a4\u01a2")
        buf.write("\3\2\2\2\u01a4\u01a3\3\2\2\2\u01a5\r\3\2\2\2\u01a6\u01e8")
        buf.write('\5B"\2\u01a7\u01aa\5> \2\u01a8\u01a9\t\5\2\2\u01a9\u01ab')
        buf.write("\5\n\6\2\u01aa\u01a8\3\2\2\2\u01aa\u01ab\3\2\2\2\u01ab")
        buf.write("\u01e8\3\2\2\2\u01ac\u01e8\5@!\2\u01ad\u01e8\5D#\2\u01ae")
        buf.write("\u01af\7\37\2\2\u01af\u01b0\7\17\2\2\u01b0\u01b1\5\n\6")
        buf.write("\2\u01b1\u01b2\7?\2\2\u01b2\u01b3\5\n\6\2\u01b3\u01b4")
        buf.write("\7\20\2\2\u01b4\u01e8\3\2\2\2\u01b5\u01b6\7 \2\2\u01b6")
        buf.write("\u01b7\7\17\2\2\u01b7\u01b8\5\n\6\2\u01b8\u01b9\7?\2\2")
        buf.write("\u01b9\u01ba\5\n\6\2\u01ba\u01bb\7?\2\2\u01bb\u01bc\5")
        buf.write("\n\6\2\u01bc\u01bd\7\20\2\2\u01bd\u01e8\3\2\2\2\u01be")
        buf.write("\u01bf\7!\2\2\u01bf\u01c0\7\17\2\2\u01c0\u01c1\5\n\6\2")
        buf.write("\u01c1\u01c2\7\20\2\2\u01c2\u01e8\3\2\2\2\u01c3\u01c4")
        buf.write('\7"\2\2\u01c4\u01c5\7\17\2\2\u01c5\u01c6\5\n\6\2\u01c6')
        buf.write("\u01c7\7\20\2\2\u01c7\u01e8\3\2\2\2\u01c8\u01c9\7#\2\2")
        buf.write("\u01c9\u01ca\7\17\2\2\u01ca\u01cb\5\n\6\2\u01cb\u01cc")
        buf.write("\7\20\2\2\u01cc\u01e8\3\2\2\2\u01cd\u01ce\7$\2\2\u01ce")
        buf.write("\u01cf\7\17\2\2\u01cf\u01d0\5\n\6\2\u01d0\u01d1\7\20\2")
        buf.write("\2\u01d1\u01e8\3\2\2\2\u01d2\u01d3\7%\2\2\u01d3\u01d4")
        buf.write("\7\17\2\2\u01d4\u01d5\5\n\6\2\u01d5\u01d6\7\20\2\2\u01d6")
        buf.write("\u01e8\3\2\2\2\u01d7\u01d8\7&\2\2\u01d8\u01d9\7\17\2\2")
        buf.write("\u01d9\u01da\5\n\6\2\u01da\u01db\7\20\2\2\u01db\u01e8")
        buf.write("\3\2\2\2\u01dc\u01dd\7'\2\2\u01dd\u01de\7\17\2\2\u01de")
        buf.write("\u01df\5\n\6\2\u01df\u01e0\7\20\2\2\u01e0\u01e8\3\2\2")
        buf.write("\2\u01e1\u01e2\7(\2\2\u01e2\u01e3\7\17\2\2\u01e3\u01e4")
        buf.write("\5\n\6\2\u01e4\u01e5\7\20\2\2\u01e5\u01e8\3\2\2\2\u01e6")
        buf.write("\u01e8\7\36\2\2\u01e7\u01a6\3\2\2\2\u01e7\u01a7\3\2\2")
        buf.write("\2\u01e7\u01ac\3\2\2\2\u01e7\u01ad\3\2\2\2\u01e7\u01ae")
        buf.write("\3\2\2\2\u01e7\u01b5\3\2\2\2\u01e7\u01be\3\2\2\2\u01e7")
        buf.write("\u01c3\3\2\2\2\u01e7\u01c8\3\2\2\2\u01e7\u01cd\3\2\2\2")
        buf.write("\u01e7\u01d2\3\2\2\2\u01e7\u01d7\3\2\2\2\u01e7\u01dc\3")
        buf.write("\2\2\2\u01e7\u01e1\3\2\2\2\u01e7\u01e6\3\2\2\2\u01e8\17")
        buf.write("\3\2\2\2\u01e9\u01ea\5\u00fc\177\2\u01ea\u01eb\5\u00c0")
        buf.write("a\2\u01eb\u01ec\7\17\2\2\u01ec\u01ed\5\26\f\2\u01ed\u01ee")
        buf.write("\7\20\2\2\u01ee\u01ef\7\u00b8\2\2\u01ef\u01f0\5\22\n\2")
        buf.write("\u01f0\u01f1\5\u0100\u0081\2\u01f1\21\3\2\2\2\u01f2\u01f7")
        buf.write("\5\24\13\2\u01f3\u01f4\7\u0105\2\2\u01f4\u01f6\5\24\13")
        buf.write("\2\u01f5\u01f3\3\2\2\2\u01f6\u01f9\3\2\2\2\u01f7\u01f5")
        buf.write("\3\2\2\2\u01f7\u01f8\3\2\2\2\u01f8\23\3\2\2\2\u01f9\u01f7")
        buf.write("\3\2\2\2\u01fa\u01fb\7\u00f7\2\2\u01fb\u01fd\7\21\2\2")
        buf.write("\u01fc\u01fa\3\2\2\2\u01fc\u01fd\3\2\2\2\u01fd\u01fe\3")
        buf.write("\2\2\2\u01fe\u0200\5\32\16\2\u01ff\u0201\5L'\2\u0200")
        buf.write("\u01ff\3\2\2\2\u0200\u0201\3\2\2\2\u0201\u0203\3\2\2\2")
        buf.write("\u0202\u0204\5N(\2\u0203\u0202\3\2\2\2\u0203\u0204\3\2")
        buf.write("\2\2\u0204\25\3\2\2\2\u0205\u0207\t\t\2\2\u0206\u0208")
        buf.write("\5\30\r\2\u0207\u0206\3\2\2\2\u0207\u0208\3\2\2\2\u0208")
        buf.write("\u0209\3\2\2\2\u0209\u020a\7\u0081\2\2\u020a\u020b\7\u00f7")
        buf.write("\2\2\u020b\27\3\2\2\2\u020c\u020d\7\u00a8\2\2\u020d\u0210")
        buf.write("\7\u00f7\2\2\u020e\u020f\7/\2\2\u020f\u0211\7\u00f7\2")
        buf.write("\2\u0210\u020e\3\2\2\2\u0210\u0211\3\2\2\2\u0211\u021a")
        buf.write("\3\2\2\2\u0212\u0213\7?\2\2\u0213\u0216\7\u00f7\2\2\u0214")
        buf.write("\u0215\7/\2\2\u0215\u0217\7\u00f7\2\2\u0216\u0214\3\2")
        buf.write("\2\2\u0216\u0217\3\2\2\2\u0217\u0219\3\2\2\2\u0218\u0212")
        buf.write("\3\2\2\2\u0219\u021c\3\2\2\2\u021a\u0218\3\2\2\2\u021a")
        buf.write("\u021b\3\2\2\2\u021b\31\3\2\2\2\u021c\u021a\3\2\2\2\u021d")
        buf.write("\u021e\7\u00b9\2\2\u021e\u021f\5\n\6\2\u021f\u0220\7\32")
        buf.write("\2\2\u0220\u0222\3\2\2\2\u0221\u021d\3\2\2\2\u0221\u0222")
        buf.write("\3\2\2\2\u0222\u0223\3\2\2\2\u0223\u0224\5\36\20\2\u0224")
        buf.write("\u0228\5\34\17\2\u0225\u0227\5\34\17\2\u0226\u0225\3\2")
        buf.write("\2\2\u0227\u022a\3\2\2\2\u0228\u0226\3\2\2\2\u0228\u0229")
        buf.write("\3\2\2\2\u0229\33\3\2\2\2\u022a\u0228\3\2\2\2\u022b\u022d")
        buf.write("\t\4\2\2\u022c\u022b\3\2\2\2\u022c\u022d\3\2\2\2\u022d")
        buf.write("\u022e\3\2\2\2\u022e\u0233\7\u00f7\2\2\u022f\u0230\7\3")
        buf.write("\2\2\u0230\u0231\5\n\6\2\u0231\u0232\7\4\2\2\u0232\u0234")
        buf.write("\3\2\2\2\u0233\u022f\3\2\2\2\u0233\u0234\3\2\2\2\u0234")
        buf.write("\35\3\2\2\2\u0235\u0237\7\u00f7\2\2\u0236\u0238\t\n\2")
        buf.write("\2\u0237\u0236\3\2\2\2\u0237\u0238\3\2\2\2\u0238\37\3")
        buf.write("\2\2\2\u0239\u023a\5\u00fa~\2\u023a\u023b\5\u00c0a\2\u023b")
        buf.write("\u023c\7\17\2\2\u023c\u023d\5&\24\2\u023d\u023e\7\20\2")
        buf.write('\2\u023e\u023f\7\u00b8\2\2\u023f\u0240\5"\22\2\u0240')
        buf.write("\u0241\5\u00fe\u0080\2\u0241!\3\2\2\2\u0242\u0247\5$\23")
        buf.write("\2\u0243\u0244\7\u0105\2\2\u0244\u0246\5$\23\2\u0245\u0243")
        buf.write("\3\2\2\2\u0246\u0249\3\2\2\2\u0247\u0245\3\2\2\2\u0247")
        buf.write("\u0248\3\2\2\2\u0248#\3\2\2\2\u0249\u0247\3\2\2\2\u024a")
        buf.write("\u024b\7\u00f7\2\2\u024b\u024d\7\21\2\2\u024c\u024a\3")
        buf.write("\2\2\2\u024c\u024d\3\2\2\2\u024d\u0252\3\2\2\2\u024e\u024f")
        buf.write("\7\u00b9\2\2\u024f\u0250\5\n\6\2\u0250\u0251\7\32\2\2")
        buf.write("\u0251\u0253\3\2\2\2\u0252\u024e\3\2\2\2\u0252\u0253\3")
        buf.write("\2\2\2\u0253\u0254\3\2\2\2\u0254\u0256\5\n\6\2\u0255\u0257")
        buf.write("\5L'\2\u0256\u0255\3\2\2\2\u0256\u0257\3\2\2\2\u0257")
        buf.write("\u0259\3\2\2\2\u0258\u025a\5N(\2\u0259\u0258\3\2\2\2\u0259")
        buf.write("\u025a\3\2\2\2\u025a%\3\2\2\2\u025b\u025c\t\t\2\2\u025c")
        buf.write("\u0261\5(\25\2\u025d\u025e\7?\2\2\u025e\u0260\5(\25\2")
        buf.write("\u025f\u025d\3\2\2\2\u0260\u0263\3\2\2\2\u0261\u025f\3")
        buf.write("\2\2\2\u0261\u0262\3\2\2\2\u0262'\3\2\2\2\u0263\u0261")
        buf.write("\3\2\2\2\u0264\u0267\5\u00c2b\2\u0265\u0266\7/\2\2\u0266")
        buf.write("\u0268\7\u00f7\2\2\u0267\u0265\3\2\2\2\u0267\u0268\3\2")
        buf.write("\2\2\u0268)\3\2\2\2\u0269\u026d\5,\27\2\u026a\u026d\5")
        buf.write(" \21\2\u026b\u026d\5\20\t\2\u026c\u0269\3\2\2\2\u026c")
        buf.write("\u026a\3\2\2\2\u026c\u026b\3\2\2\2\u026d+\3\2\2\2\u026e")
        buf.write("\u026f\7|\2\2\u026f\u0270\7{\2\2\u0270\u0271\5\u00c6d")
        buf.write("\2\u0271\u027a\7\17\2\2\u0272\u0277\5.\30\2\u0273\u0274")
        buf.write("\7?\2\2\u0274\u0276\5.\30\2\u0275\u0273\3\2\2\2\u0276")
        buf.write("\u0279\3\2\2\2\u0277\u0275\3\2\2\2\u0277\u0278\3\2\2\2")
        buf.write("\u0278\u027b\3\2\2\2\u0279\u0277\3\2\2\2\u027a\u0272\3")
        buf.write("\2\2\2\u027a\u027b\3\2\2\2\u027b\u027c\3\2\2\2\u027c\u027f")
        buf.write("\7\20\2\2\u027d\u027e\7\u00c9\2\2\u027e\u0280\5\u00dc")
        buf.write("o\2\u027f\u027d\3\2\2\2\u027f\u0280\3\2\2\2\u0280\u0281")
        buf.write("\3\2\2\2\u0281\u0282\7\u00b8\2\2\u0282\u0283\5\n\6\2\u0283")
        buf.write("\u0284\7\u0082\2\2\u0284\u0285\7{\2\2\u0285-\3\2\2\2\u0286")
        buf.write("\u0287\5\u00c2b\2\u0287\u028a\5\u00dco\2\u0288\u0289\7")
        buf.write("\u00dc\2\2\u0289\u028b\5\u00ceh\2\u028a\u0288\3\2\2\2")
        buf.write("\u028a\u028b\3\2\2\2\u028b/\3\2\2\2\u028c\u028d\5\u00c6")
        buf.write("d\2\u028d\u029c\7\17\2\2\u028e\u0291\5\u00ceh\2\u028f")
        buf.write("\u0291\7t\2\2\u0290\u028e\3\2\2\2\u0290\u028f\3\2\2\2")
        buf.write("\u0291\u0299\3\2\2\2\u0292\u0295\7?\2\2\u0293\u0296\5")
        buf.write("\u00ceh\2\u0294\u0296\7t\2\2\u0295\u0293\3\2\2\2\u0295")
        buf.write("\u0294\3\2\2\2\u0296\u0298\3\2\2\2\u0297\u0292\3\2\2\2")
        buf.write("\u0298\u029b\3\2\2\2\u0299\u0297\3\2\2\2\u0299\u029a\3")
        buf.write("\2\2\2\u029a\u029d\3\2\2\2\u029b\u0299\3\2\2\2\u029c\u0290")
        buf.write("\3\2\2\2\u029c\u029d\3\2\2\2\u029d\u029e\3\2\2\2\u029e")
        buf.write("\u029f\7\20\2\2\u029f\61\3\2\2\2\u02a0\u02a1\7[\2\2\u02a1")
        buf.write("\u02a2\7\17\2\2\u02a2\u02a5\5\n\6\2\u02a3\u02a4\7?\2\2")
        buf.write("\u02a4\u02a6\5\b\5\2\u02a5\u02a3\3\2\2\2\u02a5\u02a6\3")
        buf.write("\2\2\2\u02a6\u02a7\3\2\2\2\u02a7\u02a8\7\20\2\2\u02a8")
        buf.write("\u0358\3\2\2\2\u02a9\u02aa\7\u0088\2\2\u02aa\u02ab\7\17")
        buf.write("\2\2\u02ab\u02ac\5\n\6\2\u02ac\u02ad\7\20\2\2\u02ad\u0358")
        buf.write("\3\2\2\2\u02ae\u02af\7\u0089\2\2\u02af\u02b0\7\17\2\2")
        buf.write("\u02b0\u02b1\5\n\6\2\u02b1\u02b2\7\20\2\2\u02b2\u0358")
        buf.write("\3\2\2\2\u02b3\u02b4\7V\2\2\u02b4\u02b5\7\17\2\2\u02b5")
        buf.write("\u02b6\5\n\6\2\u02b6\u02b7\7\20\2\2\u02b7\u0358\3\2\2")
        buf.write("\2\u02b8\u02b9\7m\2\2\u02b9\u02ba\7\17\2\2\u02ba\u02bb")
        buf.write("\5\n\6\2\u02bb\u02bc\7\20\2\2\u02bc\u0358\3\2\2\2\u02bd")
        buf.write("\u02be\7X\2\2\u02be\u02bf\7\17\2\2\u02bf\u02c0\5\n\6\2")
        buf.write("\u02c0\u02c1\7\20\2\2\u02c1\u0358\3\2\2\2\u02c2\u02c3")
        buf.write("\7Y\2\2\u02c3\u02c4\7\17\2\2\u02c4\u02c5\5\n\6\2\u02c5")
        buf.write("\u02c6\7?\2\2\u02c6\u02c7\5\n\6\2\u02c7\u02c8\7\20\2\2")
        buf.write("\u02c8\u0358\3\2\2\2\u02c9\u02ca\7Z\2\2\u02ca\u02cb\7")
        buf.write("\17\2\2\u02cb\u02ce\5\n\6\2\u02cc\u02cd\7?\2\2\u02cd\u02cf")
        buf.write("\5\b\5\2\u02ce\u02cc\3\2\2\2\u02ce\u02cf\3\2\2\2\u02cf")
        buf.write("\u02d0\3\2\2\2\u02d0\u02d1\7\20\2\2\u02d1\u0358\3\2\2")
        buf.write("\2\u02d2\u02d3\7\\\2\2\u02d3\u02d4\7\17\2\2\u02d4\u02d5")
        buf.write("\5\n\6\2\u02d5\u02d6\7?\2\2\u02d6\u02d7\5\n\6\2\u02d7")
        buf.write("\u02d8\7\20\2\2\u02d8\u0358\3\2\2\2\u02d9\u02da\7\u008a")
        buf.write("\2\2\u02da\u02db\7\17\2\2\u02db\u02dc\5\n\6\2\u02dc\u02dd")
        buf.write("\7\20\2\2\u02dd\u0358\3\2\2\2\u02de\u02df\7^\2\2\u02df")
        buf.write("\u02e0\7\17\2\2\u02e0\u02e1\5\n\6\2\u02e1\u02e2\7\20\2")
        buf.write("\2\u02e2\u0358\3\2\2\2\u02e3\u02e4\7\64\2\2\u02e4\u02e5")
        buf.write("\7\17\2\2\u02e5\u02e6\5\n\6\2\u02e6\u02e7\7?\2\2\u02e7")
        buf.write("\u02e8\5\n\6\2\u02e8\u02e9\7?\2\2\u02e9\u02ea\5\n\6\2")
        buf.write("\u02ea\u02eb\7\20\2\2\u02eb\u0358\3\2\2\2\u02ec\u02ed")
        buf.write("\7`\2\2\u02ed\u02ee\7\17\2\2\u02ee\u02ef\5\n\6\2\u02ef")
        buf.write("\u02f0\7\20\2\2\u02f0\u0358\3\2\2\2\u02f1\u02f2\7\u0084")
        buf.write("\2\2\u02f2\u02f3\7\17\2\2\u02f3\u02f4\5\n\6\2\u02f4\u02f5")
        buf.write("\7\20\2\2\u02f5\u0358\3\2\2\2\u02f6\u02f7\7\u0085\2\2")
        buf.write("\u02f7\u02f8\7\17\2\2\u02f8\u02f9\5\n\6\2\u02f9\u02fa")
        buf.write("\7\20\2\2\u02fa\u0358\3\2\2\2\u02fb\u02fc\7a\2\2\u02fc")
        buf.write("\u02fd\7\17\2\2\u02fd\u02fe\5\n\6\2\u02fe\u02ff\7\20\2")
        buf.write("\2\u02ff\u0358\3\2\2\2\u0300\u0301\7b\2\2\u0301\u0302")
        buf.write("\7\17\2\2\u0302\u0303\5\n\6\2\u0303\u0304\7\20\2\2\u0304")
        buf.write("\u0358\3\2\2\2\u0305\u0306\7c\2\2\u0306\u0307\7\17\2\2")
        buf.write("\u0307\u030a\5\n\6\2\u0308\u0309\7?\2\2\u0309\u030b\5")
        buf.write("\b\5\2\u030a\u0308\3\2\2\2\u030a\u030b\3\2\2\2\u030b\u030e")
        buf.write("\3\2\2\2\u030c\u030d\7?\2\2\u030d\u030f\5\b\5\2\u030e")
        buf.write("\u030c\3\2\2\2\u030e\u030f\3\2\2\2\u030f\u0310\3\2\2\2")
        buf.write("\u0310\u0311\7\20\2\2\u0311\u0358\3\2\2\2\u0312\u0313")
        buf.write("\7\u0086\2\2\u0313\u0314\7\17\2\2\u0314\u0315\5\n\6\2")
        buf.write("\u0315\u0316\7?\2\2\u0316\u0319\5\n\6\2\u0317\u0318\7")
        buf.write("?\2\2\u0318\u031a\5\b\5\2\u0319\u0317\3\2\2\2\u0319\u031a")
        buf.write("\3\2\2\2\u031a\u031d\3\2\2\2\u031b\u031c\7?\2\2\u031c")
        buf.write("\u031e\5\b\5\2\u031d\u031b\3\2\2\2\u031d\u031e\3\2\2\2")
        buf.write("\u031e\u031f\3\2\2\2\u031f\u0320\7\20\2\2\u0320\u0358")
        buf.write("\3\2\2\2\u0321\u0322\7\u0087\2\2\u0322\u0323\7\17\2\2")
        buf.write("\u0323\u0324\5\n\6\2\u0324\u0325\7?\2\2\u0325\u0328\5")
        buf.write("\n\6\2\u0326\u0327\7?\2\2\u0327\u0329\5\b\5\2\u0328\u0326")
        buf.write("\3\2\2\2\u0328\u0329\3\2\2\2\u0329\u032a\3\2\2\2\u032a")
        buf.write("\u032b\7\20\2\2\u032b\u0358\3\2\2\2\u032c\u032d\7p\2\2")
        buf.write("\u032d\u032e\7\17\2\2\u032e\u032f\5\n\6\2\u032f\u0330")
        buf.write("\7?\2\2\u0330\u0331\5\n\6\2\u0331\u0332\7\20\2\2\u0332")
        buf.write("\u0358\3\2\2\2\u0333\u0334\7\67\2\2\u0334\u0335\7\17\2")
        buf.write("\2\u0335\u0336\5\n\6\2\u0336\u0337\7\20\2\2\u0337\u0358")
        buf.write("\3\2\2\2\u0338\u0339\7r\2\2\u0339\u033a\7\17\2\2\u033a")
        buf.write("\u033b\5\n\6\2\u033b\u033c\7?\2\2\u033c\u033d\5\n\6\2")
        buf.write("\u033d\u033e\7\20\2\2\u033e\u0358\3\2\2\2\u033f\u0340")
        buf.write("\7]\2\2\u0340\u0341\7\17\2\2\u0341\u0342\5\n\6\2\u0342")
        buf.write("\u0343\7?\2\2\u0343\u0344\5\n\6\2\u0344\u0345\7\20\2\2")
        buf.write("\u0345\u0358\3\2\2\2\u0346\u0358\5\64\33\2\u0347\u0358")
        buf.write("\5:\36\2\u0348\u0358\5<\37\2\u0349\u0358\5P)\2\u034a\u034b")
        buf.write("\7\u00a3\2\2\u034b\u034c\7\17\2\2\u034c\u034d\5\n\6\2")
        buf.write("\u034d\u034e\7\20\2\2\u034e\u0358\3\2\2\2\u034f\u0350")
        buf.write("\7\u00a4\2\2\u0350\u0351\7\17\2\2\u0351\u0352\5\n\6\2")
        buf.write("\u0352\u0353\7\20\2\2\u0353\u0358\3\2\2\2\u0354\u0358")
        buf.write("\5H%\2\u0355\u0358\5J&\2\u0356\u0358\5F$\2\u0357\u02a0")
        buf.write("\3\2\2\2\u0357\u02a9\3\2\2\2\u0357\u02ae\3\2\2\2\u0357")
        buf.write("\u02b3\3\2\2\2\u0357\u02b8\3\2\2\2\u0357\u02bd\3\2\2\2")
        buf.write("\u0357\u02c2\3\2\2\2\u0357\u02c9\3\2\2\2\u0357\u02d2\3")
        buf.write("\2\2\2\u0357\u02d9\3\2\2\2\u0357\u02de\3\2\2\2\u0357\u02e3")
        buf.write("\3\2\2\2\u0357\u02ec\3\2\2\2\u0357\u02f1\3\2\2\2\u0357")
        buf.write("\u02f6\3\2\2\2\u0357\u02fb\3\2\2\2\u0357\u0300\3\2\2\2")
        buf.write("\u0357\u0305\3\2\2\2\u0357\u0312\3\2\2\2\u0357\u0321\3")
        buf.write("\2\2\2\u0357\u032c\3\2\2\2\u0357\u0333\3\2\2\2\u0357\u0338")
        buf.write("\3\2\2\2\u0357\u033f\3\2\2\2\u0357\u0346\3\2\2\2\u0357")
        buf.write("\u0347\3\2\2\2\u0357\u0348\3\2\2\2\u0357\u0349\3\2\2\2")
        buf.write("\u0357\u034a\3\2\2\2\u0357\u034f\3\2\2\2\u0357\u0354\3")
        buf.write("\2\2\2\u0357\u0355\3\2\2\2\u0357\u0356\3\2\2\2\u0358\63")
        buf.write("\3\2\2\2\u0359\u035a\7\17\2\2\u035a\u035b\5\n\6\2\u035b")
        buf.write("\u035c\7\20\2\2\u035c\u0360\3\2\2\2\u035d\u0360\5\u00c2")
        buf.write("b\2\u035e\u0360\5\u00ceh\2\u035f\u0359\3\2\2\2\u035f\u035d")
        buf.write("\3\2\2\2\u035f\u035e\3\2\2\2\u0360\65\3\2\2\2\u0361\u0362")
        buf.write("\7\3\2\2\u0362\u0367\7\u00f7\2\2\u0363\u0364\7?\2\2\u0364")
        buf.write("\u0366\7\u00f7\2\2\u0365\u0363\3\2\2\2\u0366\u0369\3\2")
        buf.write("\2\2\u0367\u0365\3\2\2\2\u0367\u0368\3\2\2\2\u0368\u036a")
        buf.write("\3\2\2\2\u0369\u0367\3\2\2\2\u036a\u036b\7\4\2\2\u036b")
        buf.write("\67\3\2\2\2\u036c\u036d\7\22\2\2\u036d\u0372\5\u00ceh")
        buf.write("\2\u036e\u036f\7?\2\2\u036f\u0371\5\u00ceh\2\u0370\u036e")
        buf.write("\3\2\2\2\u0371\u0374\3\2\2\2\u0372\u0370\3\2\2\2\u0372")
        buf.write("\u0373\3\2\2\2\u0373\u0375\3\2\2\2\u0374\u0372\3\2\2\2")
        buf.write("\u0375\u0376\7\23\2\2\u03769\3\2\2\2\u0377\u0378\7\27")
        buf.write("\2\2\u0378\u0379\7\17\2\2\u0379\u037a\5\u00c8e\2\u037a")
        buf.write("\u037d\7\17\2\2\u037b\u037e\5\u00c4c\2\u037c\u037e\5\u00ce")
        buf.write("h\2\u037d\u037b\3\2\2\2\u037d\u037c\3\2\2\2\u037d\u037e")
        buf.write("\3\2\2\2\u037e\u0386\3\2\2\2\u037f\u0382\7?\2\2\u0380")
        buf.write("\u0383\5\u00c4c\2\u0381\u0383\5\u00ceh\2\u0382\u0380\3")
        buf.write("\2\2\2\u0382\u0381\3\2\2\2\u0383\u0385\3\2\2\2\u0384\u037f")
        buf.write("\3\2\2\2\u0385\u0388\3\2\2\2\u0386\u0384\3\2\2\2\u0386")
        buf.write("\u0387\3\2\2\2\u0387\u0389\3\2\2\2\u0388\u0386\3\2\2\2")
        buf.write("\u0389\u038c\7\20\2\2\u038a\u038b\7\u00ef\2\2\u038b\u038d")
        buf.write("\7\u00f6\2\2\u038c\u038a\3\2\2\2\u038c\u038d\3\2\2\2\u038d")
        buf.write("\u0390\3\2\2\2\u038e\u038f\7\u00c9\2\2\u038f\u0391\5\u00f4")
        buf.write("{\2\u0390\u038e\3\2\2\2\u0390\u0391\3\2\2\2\u0391\u0392")
        buf.write("\3\2\2\2\u0392\u0393\7\20\2\2\u0393;\3\2\2\2\u0394\u0395")
        buf.write("\7\u00d9\2\2\u0395\u0396\7\17\2\2\u0396\u0397\5\n\6\2")
        buf.write("\u0397\u039a\7?\2\2\u0398\u039b\5\u00d4k\2\u0399\u039b")
        buf.write("\5\u00d6l\2\u039a\u0398\3\2\2\2\u039a\u0399\3\2\2\2\u039b")
        buf.write("\u039e\3\2\2\2\u039c\u039d\7?\2\2\u039d\u039f\7\u00f6")
        buf.write("\2\2\u039e\u039c\3\2\2\2\u039e\u039f\3\2\2\2\u039f\u03a0")
        buf.write("\3\2\2\2\u03a0\u03a1\7\20\2\2\u03a1=\3\2\2\2\u03a2\u03a3")
        buf.write("\7\u00cf\2\2\u03a3\u03a5\7\17\2\2\u03a4\u03a6\5\n\6\2")
        buf.write("\u03a5\u03a4\3\2\2\2\u03a5\u03a6\3\2\2\2\u03a6\u03a7\3")
        buf.write("\2\2\2\u03a7\u03a8\7\20\2\2\u03a8?\3\2\2\2\u03a9\u03aa")
        buf.write("\7\u00a5\2\2\u03aa\u03ab\7\17\2\2\u03ab\u03ac\5\n\6\2")
        buf.write("\u03ac\u03ad\7?\2\2\u03ad\u03ae\7\u00f0\2\2\u03ae\u03af")
        buf.write("\7\20\2\2\u03afA\3\2\2\2\u03b0\u03b1\7\u00a2\2\2\u03b1")
        buf.write("\u03b2\7\17\2\2\u03b2\u03b5\5\n\6\2\u03b3\u03b4\7?\2\2")
        buf.write("\u03b4\u03b6\t\13\2\2\u03b5\u03b3\3\2\2\2\u03b5\u03b6")
        buf.write("\3\2\2\2\u03b6\u03b7\3\2\2\2\u03b7\u03b8\7\20\2\2\u03b8")
        buf.write("C\3\2\2\2\u03b9\u03ba\7\u00d2\2\2\u03ba\u03bb\7\17\2\2")
        buf.write("\u03bb\u03be\7\u00f6\2\2\u03bc\u03bd\7?\2\2\u03bd\u03bf")
        buf.write("\t\f\2\2\u03be\u03bc\3\2\2\2\u03be\u03bf\3\2\2\2\u03bf")
        buf.write("\u03c5\3\2\2\2\u03c0\u03c3\7?\2\2\u03c1\u03c4\5\n\6\2")
        buf.write("\u03c2\u03c4\7t\2\2\u03c3\u03c1\3\2\2\2\u03c3\u03c2\3")
        buf.write("\2\2\2\u03c4\u03c6\3\2\2\2\u03c5\u03c0\3\2\2\2\u03c5\u03c6")
        buf.write("\3\2\2\2\u03c6\u03c9\3\2\2\2\u03c7\u03c8\7?\2\2\u03c8")
        buf.write("\u03ca\t\r\2\2\u03c9\u03c7\3\2\2\2\u03c9\u03ca\3\2\2\2")
        buf.write("\u03ca\u03cb\3\2\2\2\u03cb\u03cc\7\20\2\2\u03ccE\3\2\2")
        buf.write("\2\u03cd\u03ce\7C\2\2\u03ce\u03cf\7\17\2\2\u03cf\u03d1")
        buf.write("\5\n\6\2\u03d0\u03d2\5L'\2\u03d1\u03d0\3\2\2\2\u03d1")
        buf.write("\u03d2\3\2\2\2\u03d2\u03d4\3\2\2\2\u03d3\u03d5\5N(\2\u03d4")
        buf.write("\u03d3\3\2\2\2\u03d4\u03d5\3\2\2\2\u03d5\u03d8\3\2\2\2")
        buf.write("\u03d6\u03d7\7G\2\2\u03d7\u03d9\5\n\6\2\u03d8\u03d6\3")
        buf.write("\2\2\2\u03d8\u03d9\3\2\2\2\u03d9\u03db\3\2\2\2\u03da\u03dc")
        buf.write("\t\16\2\2\u03db\u03da\3\2\2\2\u03db\u03dc\3\2\2\2\u03dc")
        buf.write("\u03dd\3\2\2\2\u03dd\u03de\7\20\2\2\u03deG\3\2\2\2\u03df")
        buf.write("\u03e0\7\u00dd\2\2\u03e0\u03e1\7\17\2\2\u03e1\u03e2\5")
        buf.write("\n\6\2\u03e2\u03e3\7?\2\2\u03e3\u03ed\7\u00f7\2\2\u03e4")
        buf.write("\u03e5\7\u00e6\2\2\u03e5\u03ea\5\u00c4c\2\u03e6\u03e7")
        buf.write("\7?\2\2\u03e7\u03e9\5\u00c4c\2\u03e8\u03e6\3\2\2\2\u03e9")
        buf.write("\u03ec\3\2\2\2\u03ea\u03e8\3\2\2\2\u03ea\u03eb\3\2\2\2")
        buf.write("\u03eb\u03ee\3\2\2\2\u03ec\u03ea\3\2\2\2\u03ed\u03e4\3")
        buf.write("\2\2\2\u03ed\u03ee\3\2\2\2\u03ee\u03f0\3\2\2\2\u03ef\u03f1")
        buf.write("\t\17\2\2\u03f0\u03ef\3\2\2\2\u03f0\u03f1\3\2\2\2\u03f1")
        buf.write("\u03f2\3\2\2\2\u03f2\u03f3\7\20\2\2\u03f3I\3\2\2\2\u03f4")
        buf.write("\u03f5\7\u00de\2\2\u03f5\u03f6\7\17\2\2\u03f6\u03f7\5")
        buf.write("\n\6\2\u03f7\u03f8\7?\2\2\u03f8\u0402\7\u00f7\2\2\u03f9")
        buf.write("\u03fa\7\u00a8\2\2\u03fa\u03ff\5\u00c4c\2\u03fb\u03fc")
        buf.write("\7?\2\2\u03fc\u03fe\5\u00c4c\2\u03fd\u03fb\3\2\2\2\u03fe")
        buf.write("\u0401\3\2\2\2\u03ff\u03fd\3\2\2\2\u03ff\u0400\3\2\2\2")
        buf.write("\u0400\u0403\3\2\2\2\u0401\u03ff\3\2\2\2\u0402\u03f9\3")
        buf.write("\2\2\2\u0402\u0403\3\2\2\2\u0403\u0406\3\2\2\2\u0404\u0405")
        buf.write("\7\u0081\2\2\u0405\u0407\7\u00f7\2\2\u0406\u0404\3\2\2")
        buf.write("\2\u0406\u0407\3\2\2\2\u0407\u0409\3\2\2\2\u0408\u040a")
        buf.write("\t\20\2\2\u0409\u0408\3\2\2\2\u0409\u040a\3\2\2\2\u040a")
        buf.write("\u040c\3\2\2\2\u040b\u040d\t\21\2\2\u040c\u040b\3\2\2")
        buf.write("\2\u040c\u040d\3\2\2\2\u040d\u040f\3\2\2\2\u040e\u0410")
        buf.write("\t\17\2\2\u040f\u040e\3\2\2\2\u040f\u0410\3\2\2\2\u0410")
        buf.write("\u0411\3\2\2\2\u0411\u0412\7\20\2\2\u0412K\3\2\2\2\u0413")
        buf.write("\u0414\7H\2\2\u0414\u0415\5\u00ceh\2\u0415M\3\2\2\2\u0416")
        buf.write("\u0417\7K\2\2\u0417\u0418\5\u00ceh\2\u0418O\3\2\2\2\u0419")
        buf.write("\u041a\7s\2\2\u041a\u041b\7\17\2\2\u041b\u041c\5\n\6\2")
        buf.write("\u041c\u041d\7?\2\2\u041d\u0427\7\u00f7\2\2\u041e\u041f")
        buf.write("\7\u00a8\2\2\u041f\u0424\5\u00c4c\2\u0420\u0421\7?\2\2")
        buf.write("\u0421\u0423\5\u00c4c\2\u0422\u0420\3\2\2\2\u0423\u0426")
        buf.write("\3\2\2\2\u0424\u0422\3\2\2\2\u0424\u0425\3\2\2\2\u0425")
        buf.write("\u0428\3\2\2\2\u0426\u0424\3\2\2\2\u0427\u041e\3\2\2\2")
        buf.write("\u0427\u0428\3\2\2\2\u0428\u042b\3\2\2\2\u0429\u042a\7")
        buf.write("\u0081\2\2\u042a\u042c\7\u00f7\2\2\u042b\u0429\3\2\2\2")
        buf.write("\u042b\u042c\3\2\2\2\u042c\u042f\3\2\2\2\u042d\u0430\t")
        buf.write("\20\2\2\u042e\u0430\7t\2\2\u042f\u042d\3\2\2\2\u042f\u042e")
        buf.write("\3\2\2\2\u042f\u0430\3\2\2\2\u0430\u0433\3\2\2\2\u0431")
        buf.write("\u0434\t\22\2\2\u0432\u0434\7t\2\2\u0433\u0431\3\2\2\2")
        buf.write("\u0433\u0432\3\2\2\2\u0433\u0434\3\2\2\2\u0434\u0437\3")
        buf.write("\2\2\2\u0435\u0438\t\23\2\2\u0436\u0438\7t\2\2\u0437\u0435")
        buf.write("\3\2\2\2\u0437\u0436\3\2\2\2\u0437\u0438\3\2\2\2\u0438")
        buf.write("\u0439\3\2\2\2\u0439\u043a\7\20\2\2\u043aQ\3\2\2\2\u043b")
        buf.write("\u043c\7.\2\2\u043c\u0446\5\u0088E\2\u043d\u0446\5\u0084")
        buf.write("C\2\u043e\u0446\5\u0086D\2\u043f\u0446\5\u008cG\2\u0440")
        buf.write("\u0446\5\u0096L\2\u0441\u0446\5\u0092J\2\u0442\u0446\5")
        buf.write("\u009cO\2\u0443\u0446\5\u009aN\2\u0444\u0446\5\u009eP")
        buf.write("\2\u0445\u043b\3\2\2\2\u0445\u043d\3\2\2\2\u0445\u043e")
        buf.write("\3\2\2\2\u0445\u043f\3\2\2\2\u0445\u0440\3\2\2\2\u0445")
        buf.write("\u0441\3\2\2\2\u0445\u0442\3\2\2\2\u0445\u0443\3\2\2\2")
        buf.write("\u0445\u0444\3\2\2\2\u0446S\3\2\2\2\u0447\u044a\5\u00ac")
        buf.write("W\2\u0448\u044a\5z>\2\u0449\u0447\3\2\2\2\u0449\u0448")
        buf.write("\3\2\2\2\u0449\u044a\3\2\2\2\u044a\u044b\3\2\2\2\u044b")
        buf.write("\u044d\7\17\2\2\u044c\u044e\5\n\6\2\u044d\u044c\3\2\2")
        buf.write("\2\u044d\u044e\3\2\2\2\u044e\u0453\3\2\2\2\u044f\u0450")
        buf.write("\7?\2\2\u0450\u0452\5\n\6\2\u0451\u044f\3\2\2\2\u0452")
        buf.write("\u0455\3\2\2\2\u0453\u0451\3\2\2\2\u0453\u0454\3\2\2\2")
        buf.write("\u0454\u0456\3\2\2\2\u0455\u0453\3\2\2\2\u0456\u0457\7")
        buf.write("\u0099\2\2\u0457\u0459\7\17\2\2\u0458\u045a\5V,\2\u0459")
        buf.write("\u0458\3\2\2\2\u0459\u045a\3\2\2\2\u045a\u045c\3\2\2\2")
        buf.write("\u045b\u045d\5X-\2\u045c\u045b\3\2\2\2\u045c\u045d\3\2")
        buf.write("\2\2\u045d\u045f\3\2\2\2\u045e\u0460\5Z.\2\u045f\u045e")
        buf.write("\3\2\2\2\u045f\u0460\3\2\2\2\u0460\u0461\3\2\2\2\u0461")
        buf.write("\u0462\7\20\2\2\u0462\u0463\7\20\2\2\u0463U\3\2\2\2\u0464")
        buf.write("\u0465\7\u009d\2\2\u0465\u0466\7M\2\2\u0466\u046b\7\u00f7")
        buf.write("\2\2\u0467\u0468\7?\2\2\u0468\u046a\7\u00f7\2\2\u0469")
        buf.write("\u0467\3\2\2\2\u046a\u046d\3\2\2\2\u046b\u0469\3\2\2\2")
        buf.write("\u046b\u046c\3\2\2\2\u046cW\3\2\2\2\u046d\u046b\3\2\2")
        buf.write("\2\u046e\u046f\7L\2\2\u046f\u0470\7M\2\2\u0470\u0472\5")
        buf.write("\u00c4c\2\u0471\u0473\t\24\2\2\u0472\u0471\3\2\2\2\u0472")
        buf.write("\u0473\3\2\2\2\u0473\u047b\3\2\2\2\u0474\u0475\7?\2\2")
        buf.write("\u0475\u0477\5\u00c4c\2\u0476\u0478\t\24\2\2\u0477\u0476")
        buf.write("\3\2\2\2\u0477\u0478\3\2\2\2\u0478\u047a\3\2\2\2\u0479")
        buf.write("\u0474\3\2\2\2\u047a\u047d\3\2\2\2\u047b\u0479\3\2\2\2")
        buf.write("\u047b\u047c\3\2\2\2\u047cY\3\2\2\2\u047d\u047b\3\2\2")
        buf.write("\2\u047e\u047f\7x\2\2\u047f\u0482\7\u00bc\2\2\u0480\u0482")
        buf.write("\7\u009f\2\2\u0481\u047e\3\2\2\2\u0481\u0480\3\2\2\2\u0482")
        buf.write("\u0483\3\2\2\2\u0483\u0484\7\64\2\2\u0484\u0485\5\\/\2")
        buf.write("\u0485\u0486\7\60\2\2\u0486\u0487\5\\/\2\u0487[\3\2\2")
        buf.write("\2\u0488\u0489\7\u00f0\2\2\u0489\u0494\7\u009a\2\2\u048a")
        buf.write("\u048b\7\u00f0\2\2\u048b\u0494\7\u009b\2\2\u048c\u048d")
        buf.write("\7\u00a0\2\2\u048d\u048e\7x\2\2\u048e\u0494\7\u00bd\2")
        buf.write("\2\u048f\u0490\7\u009c\2\2\u0490\u0494\7\u009a\2\2\u0491")
        buf.write("\u0492\7\u009c\2\2\u0492\u0494\7\u009b\2\2\u0493\u0488")
        buf.write("\3\2\2\2\u0493\u048a\3\2\2\2\u0493\u048c\3\2\2\2\u0493")
        buf.write("\u048f\3\2\2\2\u0493\u0491\3\2\2\2\u0494]\3\2\2\2\u0495")
        buf.write("\u0496\5\u00caf\2\u0496\u0497\7\17\2\2\u0497\u0499\5`")
        buf.write("\61\2\u0498\u049a\5b\62\2\u0499\u0498\3\2\2\2\u0499\u049a")
        buf.write("\3\2\2\2\u049a\u049b\3\2\2\2\u049b\u049c\7\20\2\2\u049c")
        buf.write("_\3\2\2\2\u049d\u04a0\5\n\6\2\u049e\u049f\7/\2\2\u049f")
        buf.write("\u04a1\7\u00f7\2\2\u04a0\u049e\3\2\2\2\u04a0\u04a1\3\2")
        buf.write("\2\2\u04a1\u04aa\3\2\2\2\u04a2\u04a3\7?\2\2\u04a3\u04a6")
        buf.write("\5\n\6\2\u04a4\u04a5\7/\2\2\u04a5\u04a7\7\u00f7\2\2\u04a6")
        buf.write("\u04a4\3\2\2\2\u04a6\u04a7\3\2\2\2\u04a7\u04a9\3\2\2\2")
        buf.write("\u04a8\u04a2\3\2\2\2\u04a9\u04ac\3\2\2\2\u04aa\u04a8\3")
        buf.write("\2\2\2\u04aa\u04ab\3\2\2\2\u04ab\u04b6\3\2\2\2\u04ac\u04aa")
        buf.write("\3\2\2\2\u04ad\u04ae\7\34\2\2\u04ae\u04b3\5\u00c4c\2\u04af")
        buf.write("\u04b0\7?\2\2\u04b0\u04b2\5\u00c4c\2\u04b1\u04af\3\2\2")
        buf.write("\2\u04b2\u04b5\3\2\2\2\u04b3\u04b1\3\2\2\2\u04b3\u04b4")
        buf.write("\3\2\2\2\u04b4\u04b7\3\2\2\2\u04b5\u04b3\3\2\2\2\u04b6")
        buf.write("\u04ad\3\2\2\2\u04b6\u04b7\3\2\2\2\u04b7a\3\2\2\2\u04b8")
        buf.write("\u04ba\5t;\2\u04b9\u04b8\3\2\2\2\u04b9\u04ba\3\2\2\2\u04ba")
        buf.write("\u04be\3\2\2\2\u04bb\u04bf\5d\63\2\u04bc\u04bf\5x=\2\u04bd")
        buf.write("\u04bf\5j\66\2\u04be\u04bb\3\2\2\2\u04be\u04bc\3\2\2\2")
        buf.write("\u04be\u04bd\3\2\2\2\u04be\u04bf\3\2\2\2\u04bf\u04c2\3")
        buf.write("\2\2\2\u04c0\u04c3\5p9\2\u04c1\u04c3\5r:\2\u04c2\u04c0")
        buf.write("\3\2\2\2\u04c2\u04c1\3\2\2\2\u04c2\u04c3\3\2\2\2\u04c3")
        buf.write("\u04c5\3\2\2\2\u04c4\u04c6\5v<\2\u04c5\u04c4\3\2\2\2\u04c5")
        buf.write("\u04c6\3\2\2\2\u04c6c\3\2\2\2\u04c7\u04c9\5\u00b4[\2\u04c8")
        buf.write("\u04c7\3\2\2\2\u04c8\u04c9\3\2\2\2\u04c9\u04ca\3\2\2\2")
        buf.write("\u04ca\u04cf\5f\64\2\u04cb\u04cc\7?\2\2\u04cc\u04ce\5")
        buf.write("f\64\2\u04cd\u04cb\3\2\2\2\u04ce\u04d1\3\2\2\2\u04cf\u04cd")
        buf.write("\3\2\2\2\u04cf\u04d0\3\2\2\2\u04d0e\3\2\2\2\u04d1\u04cf")
        buf.write("\3\2\2\2\u04d2\u04d4\7,\2\2\u04d3\u04d5\5\u00b4[\2\u04d4")
        buf.write("\u04d3\3\2\2\2\u04d4\u04d5\3\2\2\2\u04d5\u04d6\3\2\2\2")
        buf.write("\u04d6\u04de\5h\65\2\u04d7\u04d9\7?\2\2\u04d8\u04da\5")
        buf.write("\u00b4[\2\u04d9\u04d8\3\2\2\2\u04d9\u04da\3\2\2\2\u04da")
        buf.write("\u04db\3\2\2\2\u04db\u04dd\5h\65\2\u04dc\u04d7\3\2\2\2")
        buf.write("\u04dd\u04e0\3\2\2\2\u04de\u04dc\3\2\2\2\u04de\u04df\3")
        buf.write("\2\2\2\u04dfg\3\2\2\2\u04e0\u04de\3\2\2\2\u04e1\u04e2")
        buf.write("\5\u00c4c\2\u04e2\u04e3\7\25\2\2\u04e3\u04e4\5\n\6\2\u04e4")
        buf.write("i\3\2\2\2\u04e5\u04e7\5\u00b4[\2\u04e6\u04e5\3\2\2\2\u04e6")
        buf.write("\u04e7\3\2\2\2\u04e7\u04e8\3\2\2\2\u04e8\u04e9\7J\2\2")
        buf.write("\u04e9\u04ee\5l\67\2\u04ea\u04eb\7?\2\2\u04eb\u04ed\5")
        buf.write("l\67\2\u04ec\u04ea\3\2\2\2\u04ed\u04f0\3\2\2\2\u04ee\u04ec")
        buf.write("\3\2\2\2\u04ee\u04ef\3\2\2\2\u04ef\u04f2\3\2\2\2\u04f0")
        buf.write("\u04ee\3\2\2\2\u04f1\u04f3\5\u00aeX\2\u04f2\u04f1\3\2")
        buf.write("\2\2\u04f2\u04f3\3\2\2\2\u04f3\u04f5\3\2\2\2\u04f4\u04f6")
        buf.write("\5\u00b0Y\2\u04f5\u04f4\3\2\2\2\u04f5\u04f6\3\2\2\2\u04f6")
        buf.write("k\3\2\2\2\u04f7\u04f9\5\u00b4[\2\u04f8\u04f7\3\2\2\2\u04f8")
        buf.write("\u04f9\3\2\2\2\u04f9\u04fa\3\2\2\2\u04fa\u04ff\5n8\2\u04fb")
        buf.write("\u04fc\7?\2\2\u04fc\u04fe\5n8\2\u04fd\u04fb\3\2\2\2\u04fe")
        buf.write("\u0501\3\2\2\2\u04ff\u04fd\3\2\2\2\u04ff\u0500\3\2\2\2")
        buf.write("\u0500m\3\2\2\2\u0501\u04ff\3\2\2\2\u0502\u0503\5\u00c4")
        buf.write("c\2\u0503\u0504\7\25\2\2\u0504\u0505\5\u008aF\2\u0505")
        buf.write("o\3\2\2\2\u0506\u0507\7+\2\2\u0507\u050c\5\u0098M\2\u0508")
        buf.write("\u0509\7?\2\2\u0509\u050b\5\u0098M\2\u050a\u0508\3\2\2")
        buf.write("\2\u050b\u050e\3\2\2\2\u050c\u050a\3\2\2\2\u050c\u050d")
        buf.write("\3\2\2\2\u050dq\3\2\2\2\u050e\u050c\3\2\2\2\u050f\u0510")
        buf.write("\7*\2\2\u0510\u0515\5\u0094K\2\u0511\u0512\7?\2\2\u0512")
        buf.write("\u0514\5\u0094K\2\u0513\u0511\3\2\2\2\u0514\u0517\3\2")
        buf.write("\2\2\u0515\u0513\3\2\2\2\u0515\u0516\3\2\2\2\u0516s\3")
        buf.write("\2\2\2\u0517\u0515\3\2\2\2\u0518\u0519\7k\2\2\u0519\u051c")
        buf.write("\5\n\6\2\u051a\u051c\5\u00c0a\2\u051b\u0518\3\2\2\2\u051b")
        buf.write("\u051a\3\2\2\2\u051cu\3\2\2\2\u051d\u0521\7.\2\2\u051e")
        buf.write("\u051f\5\u00c4c\2\u051f\u0520\7\26\2\2\u0520\u0522\3\2")
        buf.write("\2\2\u0521\u051e\3\2\2\2\u0521\u0522\3\2\2\2\u0522\u0523")
        buf.write("\3\2\2\2\u0523\u0524\5\u00c2b\2\u0524\u0528\7E\2\2\u0525")
        buf.write("\u0526\5\u00c4c\2\u0526\u0527\7\26\2\2\u0527\u0529\3\2")
        buf.write("\2\2\u0528\u0525\3\2\2\2\u0528\u0529\3\2\2\2\u0529\u052a")
        buf.write("\3\2\2\2\u052a\u053c\5\u00c2b\2\u052b\u052f\7?\2\2\u052c")
        buf.write("\u052d\5\u00c4c\2\u052d\u052e\7\26\2\2\u052e\u0530\3\2")
        buf.write("\2\2\u052f\u052c\3\2\2\2\u052f\u0530\3\2\2\2\u0530\u0531")
        buf.write("\3\2\2\2\u0531\u0532\5\u00c2b\2\u0532\u0536\7E\2\2\u0533")
        buf.write("\u0534\5\u00c4c\2\u0534\u0535\7\26\2\2\u0535\u0537\3\2")
        buf.write("\2\2\u0536\u0533\3\2\2\2\u0536\u0537\3\2\2\2\u0537\u0538")
        buf.write("\3\2\2\2\u0538\u0539\5\u00c2b\2\u0539\u053b\3\2\2\2\u053a")
        buf.write("\u052b\3\2\2\2\u053b\u053e\3\2\2\2\u053c\u053d\3\2\2\2")
        buf.write("\u053c\u053a\3\2\2\2\u053dw\3\2\2\2\u053e\u053c\3\2\2")
        buf.write("\2\u053f\u0540\7\u00cd\2\2\u0540\u0541\5\n\6\2\u0541y")
        buf.write("\3\2\2\2\u0542\u0543\t\25\2\2\u0543{\3\2\2\2\u0544\u0549")
        buf.write("\5~@\2\u0545\u0546\7?\2\2\u0546\u0548\5~@\2\u0547\u0545")
        buf.write("\3\2\2\2\u0548\u054b\3\2\2\2\u0549\u0547\3\2\2\2\u0549")
        buf.write("\u054a\3\2\2\2\u054a}\3\2\2\2\u054b\u0549\3\2\2\2\u054c")
        buf.write("\u054e\5\u00b4[\2\u054d\u054c\3\2\2\2\u054d\u054e\3\2")
        buf.write("\2\2\u054e\u054f\3\2\2\2\u054f\u0550\5\u00c4c\2\u0550")
        buf.write("\u0551\7\25\2\2\u0551\u0552\5\u008aF\2\u0552\177\3\2\2")
        buf.write("\2\u0553\u0558\5\u0082B\2\u0554\u0555\7?\2\2\u0555\u0557")
        buf.write("\5\u0082B\2\u0556\u0554\3\2\2\2\u0557\u055a\3\2\2\2\u0558")
        buf.write("\u0556\3\2\2\2\u0558\u0559\3\2\2\2\u0559\u0081\3\2\2\2")
        buf.write("\u055a\u0558\3\2\2\2\u055b\u055d\7k\2\2\u055c\u055b\3")
        buf.write("\2\2\2\u055c\u055d\3\2\2\2\u055d\u055e\3\2\2\2\u055e\u055f")
        buf.write("\5\n\6\2\u055f\u0083\3\2\2\2\u0560\u0561\7J\2\2\u0561")
        buf.write("\u0563\5|?\2\u0562\u0564\5\u00aeX\2\u0563\u0562\3\2\2")
        buf.write("\2\u0563\u0564\3\2\2\2\u0564\u0566\3\2\2\2\u0565\u0567")
        buf.write("\5\u00b0Y\2\u0566\u0565\3\2\2\2\u0566\u0567\3\2\2\2\u0567")
        buf.write("\u0085\3\2\2\2\u0568\u0569\7k\2\2\u0569\u056a\5\n\6\2")
        buf.write("\u056a\u0087\3\2\2\2\u056b\u056c\5\u00c2b\2\u056c\u056d")
        buf.write("\7E\2\2\u056d\u0575\5\u00c2b\2\u056e\u056f\7?\2\2\u056f")
        buf.write("\u0570\5\u00c2b\2\u0570\u0571\7E\2\2\u0571\u0572\5\u00c2")
        buf.write("b\2\u0572\u0574\3\2\2\2\u0573\u056e\3\2\2\2\u0574\u0577")
        buf.write("\3\2\2\2\u0575\u0573\3\2\2\2\u0575\u0576\3\2\2\2\u0576")
        buf.write("\u0089\3\2\2\2\u0577\u0575\3\2\2\2\u0578\u0579\7d\2\2")
        buf.write("\u0579\u057a\7\17\2\2\u057a\u057b\5\n\6\2\u057b\u057c")
        buf.write("\7\20\2\2\u057c\u05b1\3\2\2\2\u057d\u057e\7e\2\2\u057e")
        buf.write("\u057f\7\17\2\2\u057f\u0580\5\n\6\2\u0580\u0581\7\20\2")
        buf.write("\2\u0581\u05b1\3\2\2\2\u0582\u0583\7g\2\2\u0583\u0585")
        buf.write("\7\17\2\2\u0584\u0586\5\n\6\2\u0585\u0584\3\2\2\2\u0585")
        buf.write("\u0586\3\2\2\2\u0586\u0587\3\2\2\2\u0587\u05b1\7\20\2")
        buf.write("\2\u0588\u0589\7f\2\2\u0589\u058a\7\17\2\2\u058a\u058b")
        buf.write("\5\n\6\2\u058b\u058c\7\20\2\2\u058c\u05b1\3\2\2\2\u058d")
        buf.write("\u058e\7Q\2\2\u058e\u058f\7\17\2\2\u058f\u0590\5\n\6\2")
        buf.write("\u0590\u0591\7\20\2\2\u0591\u05b1\3\2\2\2\u0592\u0593")
        buf.write("\7R\2\2\u0593\u0594\7\17\2\2\u0594\u0595\5\n\6\2\u0595")
        buf.write("\u0596\7\20\2\2\u0596\u05b1\3\2\2\2\u0597\u0598\7N\2\2")
        buf.write("\u0598\u0599\7\17\2\2\u0599\u059a\5\n\6\2\u059a\u059b")
        buf.write("\7\20\2\2\u059b\u05b1\3\2\2\2\u059c\u059d\7\u008d\2\2")
        buf.write("\u059d\u059e\7\17\2\2\u059e\u059f\5\n\6\2\u059f\u05a0")
        buf.write("\7\20\2\2\u05a0\u05b1\3\2\2\2\u05a1\u05a2\7\u008e\2\2")
        buf.write("\u05a2\u05a3\7\17\2\2\u05a3\u05a4\5\n\6\2\u05a4\u05a5")
        buf.write("\7\20\2\2\u05a5\u05b1\3\2\2\2\u05a6\u05a7\7\u008f\2\2")
        buf.write("\u05a7\u05a8\7\17\2\2\u05a8\u05a9\5\n\6\2\u05a9\u05aa")
        buf.write("\7\20\2\2\u05aa\u05b1\3\2\2\2\u05ab\u05ac\7\u0090\2\2")
        buf.write("\u05ac\u05ad\7\17\2\2\u05ad\u05ae\5\n\6\2\u05ae\u05af")
        buf.write("\7\20\2\2\u05af\u05b1\3\2\2\2\u05b0\u0578\3\2\2\2\u05b0")
        buf.write("\u057d\3\2\2\2\u05b0\u0582\3\2\2\2\u05b0\u0588\3\2\2\2")
        buf.write("\u05b0\u058d\3\2\2\2\u05b0\u0592\3\2\2\2\u05b0\u0597\3")
        buf.write("\2\2\2\u05b0\u059c\3\2\2\2\u05b0\u05a1\3\2\2\2\u05b0\u05a6")
        buf.write("\3\2\2\2\u05b0\u05ab\3\2\2\2\u05b1\u008b\3\2\2\2\u05b2")
        buf.write("\u05b3\7,\2\2\u05b3\u05b8\5\u008eH\2\u05b4\u05b5\7?\2")
        buf.write("\2\u05b5\u05b7\5\u008eH\2\u05b6\u05b4\3\2\2\2\u05b7\u05ba")
        buf.write("\3\2\2\2\u05b8\u05b6\3\2\2\2\u05b8\u05b9\3\2\2\2\u05b9")
        buf.write("\u008d\3\2\2\2\u05ba\u05b8\3\2\2\2\u05bb\u05bd\5\u00b4")
        buf.write("[\2\u05bc\u05bb\3\2\2\2\u05bc\u05bd\3\2\2\2\u05bd\u05be")
        buf.write("\3\2\2\2\u05be\u05bf\5\u00c4c\2\u05bf\u05c0\7\25\2\2\u05c0")
        buf.write("\u05c1\5\u0090I\2\u05c1\u008f\3\2\2\2\u05c2\u05c3\5\u008a")
        buf.write("F\2\u05c3\u05c4\7\17\2\2\u05c4\u05c5\5\n\6\2\u05c5\u05c6")
        buf.write("\7\20\2\2\u05c6\u05c9\3\2\2\2\u05c7\u05c9\5\n\6\2\u05c8")
        buf.write("\u05c2\3\2\2\2\u05c8\u05c7\3\2\2\2\u05c9\u0091\3\2\2\2")
        buf.write("\u05ca\u05cb\7*\2\2\u05cb\u05d0\5\u0094K\2\u05cc\u05cd")
        buf.write("\7?\2\2\u05cd\u05cf\5\u0094K\2\u05ce\u05cc\3\2\2\2\u05cf")
        buf.write("\u05d2\3\2\2\2\u05d0\u05ce\3\2\2\2\u05d0\u05d1\3\2\2\2")
        buf.write("\u05d1\u0093\3\2\2\2\u05d2\u05d0\3\2\2\2\u05d3\u05d9\5")
        buf.write("\u00c4c\2\u05d4\u05d5\5\u00be`\2\u05d5\u05d6\7\26\2\2")
        buf.write("\u05d6\u05d7\5\u00c4c\2\u05d7\u05d9\3\2\2\2\u05d8\u05d3")
        buf.write("\3\2\2\2\u05d8\u05d4\3\2\2\2\u05d9\u0095\3\2\2\2\u05da")
        buf.write("\u05db\7+\2\2\u05db\u05e0\5\u0098M\2\u05dc\u05dd\7?\2")
        buf.write("\2\u05dd\u05df\5\u0098M\2\u05de\u05dc\3\2\2\2\u05df\u05e2")
        buf.write("\3\2\2\2\u05e0\u05de\3\2\2\2\u05e0\u05e1\3\2\2\2\u05e1")
        buf.write("\u0097\3\2\2\2\u05e2\u05e0\3\2\2\2\u05e3\u05e9\5\u00c4")
        buf.write("c\2\u05e4\u05e5\5\u00be`\2\u05e5\u05e6\7\26\2\2\u05e6")
        buf.write("\u05e7\5\u00c4c\2\u05e7\u05e9\3\2\2\2\u05e8\u05e3\3\2")
        buf.write("\2\2\u05e8\u05e4\3\2\2\2\u05e9\u0099\3\2\2\2\u05ea\u05eb")
        buf.write("\7\u00cb\2\2\u05eb\u05ec\5\u00c2b\2\u05ec\u05ed\7?\2\2")
        buf.write("\u05ed\u05ee\5\u00c2b\2\u05ee\u009b\3\2\2\2\u05ef\u05f0")
        buf.write("\7\u00ca\2\2\u05f0\u05f1\5\u00c2b\2\u05f1\u05f2\7?\2\2")
        buf.write("\u05f2\u05f3\5\u00c2b\2\u05f3\u009d\3\2\2\2\u05f4\u05f5")
        buf.write("\7\u00cc\2\2\u05f5\u05f6\5\u00c2b\2\u05f6\u05f7\7\r\2")
        buf.write("\2\u05f7\u05ff\5\u00ceh\2\u05f8\u05f9\7?\2\2\u05f9\u05fa")
        buf.write("\5\u00c2b\2\u05fa\u05fb\7\r\2\2\u05fb\u05fc\5\u00ceh\2")
        buf.write("\u05fc\u05fe\3\2\2\2\u05fd\u05f8\3\2\2\2\u05fe\u0601\3")
        buf.write("\2\2\2\u05ff\u05fd\3\2\2\2\u05ff\u0600\3\2\2\2\u0600\u009f")
        buf.write("\3\2\2\2\u0601\u05ff\3\2\2\2\u0602\u0605\7\65\2\2\u0603")
        buf.write("\u0606\5\u00a2R\2\u0604\u0606\7\u00f7\2\2\u0605\u0603")
        buf.write("\3\2\2\2\u0605\u0604\3\2\2\2\u0606\u060d\3\2\2\2\u0607")
        buf.write("\u060a\7\66\2\2\u0608\u060b\5\u00a2R\2\u0609\u060b\7\u00f7")
        buf.write("\2\2\u060a\u0608\3\2\2\2\u060a\u0609\3\2\2\2\u060b\u060d")
        buf.write("\3\2\2\2\u060c\u0602\3\2\2\2\u060c\u0607\3\2\2\2\u060d")
        buf.write("\u00a1\3\2\2\2\u060e\u060f\79\2\2\u060f\u0610\7\17\2\2")
        buf.write("\u0610\u0615\5\n\6\2\u0611\u0612\7?\2\2\u0612\u0614\5")
        buf.write("\n\6\2\u0613\u0611\3\2\2\2\u0614\u0617\3\2\2\2\u0615\u0613")
        buf.write("\3\2\2\2\u0615\u0616\3\2\2\2\u0616\u0618\3\2\2\2\u0617")
        buf.write("\u0615\3\2\2\2\u0618\u0619\7\20\2\2\u0619\u0635\3\2\2")
        buf.write("\2\u061a\u061b\7;\2\2\u061b\u061c\7\17\2\2\u061c\u061d")
        buf.write("\5\n\6\2\u061d\u061e\7?\2\2\u061e\u061f\5\n\6\2\u061f")
        buf.write("\u0620\7\20\2\2\u0620\u0635\3\2\2\2\u0621\u0622\7\u008c")
        buf.write("\2\2\u0622\u0623\7\17\2\2\u0623\u0624\5\n\6\2\u0624\u0625")
        buf.write("\7?\2\2\u0625\u0626\5\n\6\2\u0626\u0627\7\20\2\2\u0627")
        buf.write("\u0635\3\2\2\2\u0628\u0629\7<\2\2\u0629\u062a\7\17\2\2")
        buf.write("\u062a\u062f\5\n\6\2\u062b\u062c\7?\2\2\u062c\u062e\5")
        buf.write("\n\6\2\u062d\u062b\3\2\2\2\u062e\u0631\3\2\2\2\u062f\u062d")
        buf.write("\3\2\2\2\u062f\u0630\3\2\2\2\u0630\u0632\3\2\2\2\u0631")
        buf.write("\u062f\3\2\2\2\u0632\u0633\7\20\2\2\u0633\u0635\3\2\2")
        buf.write("\2\u0634\u060e\3\2\2\2\u0634\u061a\3\2\2\2\u0634\u0621")
        buf.write("\3\2\2\2\u0634\u0628\3\2\2\2\u0635\u00a3\3\2\2\2\u0636")
        buf.write("\u0637\7=\2\2\u0637\u0638\7\17\2\2\u0638\u0639\5\n\6\2")
        buf.write("\u0639\u063a\7?\2\2\u063a\u063b\5\n\6\2\u063b\u063c\7")
        buf.write("\20\2\2\u063c\u00a5\3\2\2\2\u063d\u063e\5\u00bc_\2\u063e")
        buf.write("\u063f\7\3\2\2\u063f\u0640\5\u00c4c\2\u0640\u0641\7\r")
        buf.write("\2\2\u0641\u0647\5\u00ceh\2\u0642\u0643\7?\2\2\u0643\u0644")
        buf.write("\5\u00c4c\2\u0644\u0645\7\r\2\2\u0645\u0646\5\u00ceh\2")
        buf.write("\u0646\u0648\3\2\2\2\u0647\u0642\3\2\2\2\u0647\u0648\3")
        buf.write("\2\2\2\u0648\u0649\3\2\2\2\u0649\u064a\7\4\2\2\u064a\u00a7")
        buf.write("\3\2\2\2\u064b\u064c\5\u00acW\2\u064c\u064d\7\17\2\2\u064d")
        buf.write("\u0650\7\u00f7\2\2\u064e\u064f\7\26\2\2\u064f\u0651\5")
        buf.write("\u00c4c\2\u0650\u064e\3\2\2\2\u0650\u0651\3\2\2\2\u0651")
        buf.write("\u065a\3\2\2\2\u0652\u0653\7?\2\2\u0653\u0656\7\u00f7")
        buf.write("\2\2\u0654\u0655\7\26\2\2\u0655\u0657\5\u00c4c\2\u0656")
        buf.write("\u0654\3\2\2\2\u0656\u0657\3\2\2\2\u0657\u0659\3\2\2\2")
        buf.write("\u0658\u0652\3\2\2\2\u0659\u065c\3\2\2\2\u065a\u0658\3")
        buf.write("\2\2\2\u065a\u065b\3\2\2\2\u065b\u065e\3\2\2\2\u065c\u065a")
        buf.write("\3\2\2\2\u065d\u065f\5\u00aeX\2\u065e\u065d\3\2\2\2\u065e")
        buf.write("\u065f\3\2\2\2\u065f\u0661\3\2\2\2\u0660\u0662\5\u00b0")
        buf.write("Y\2\u0661\u0660\3\2\2\2\u0661\u0662\3\2\2\2\u0662\u0663")
        buf.write("\3\2\2\2\u0663\u0664\7\20\2\2\u0664\u00a9\3\2\2\2\u0665")
        buf.write("\u0666\5\u00acW\2\u0666\u0667\7\17\2\2\u0667\u066a\7\u00f7")
        buf.write("\2\2\u0668\u0669\7\26\2\2\u0669\u066b\5\u00c4c\2\u066a")
        buf.write("\u0668\3\2\2\2\u066a\u066b\3\2\2\2\u066b\u0674\3\2\2\2")
        buf.write("\u066c\u066d\7?\2\2\u066d\u0670\7\u00f7\2\2\u066e\u066f")
        buf.write("\7\26\2\2\u066f\u0671\5\u00c4c\2\u0670\u066e\3\2\2\2\u0670")
        buf.write("\u0671\3\2\2\2\u0671\u0673\3\2\2\2\u0672\u066c\3\2\2\2")
        buf.write("\u0673\u0676\3\2\2\2\u0674\u0672\3\2\2\2\u0674\u0675\3")
        buf.write("\2\2\2\u0675\u0677\3\2\2\2\u0676\u0674\3\2\2\2\u0677\u0679")
        buf.write("\7\20\2\2\u0678\u067a\5\u00aeX\2\u0679\u0678\3\2\2\2\u0679")
        buf.write("\u067a\3\2\2\2\u067a\u067c\3\2\2\2\u067b\u067d\5\u00b0")
        buf.write("Y\2\u067c\u067b\3\2\2\2\u067c\u067d\3\2\2\2\u067d\u00ab")
        buf.write("\3\2\2\2\u067e\u067f\t\26\2\2\u067f\u00ad\3\2\2\2\u0680")
        buf.write("\u068a\5\u00ccg\2\u0681\u0686\7\u00f7\2\2\u0682\u0683")
        buf.write("\7?\2\2\u0683\u0685\7\u00f7\2\2\u0684\u0682\3\2\2\2\u0685")
        buf.write("\u0688\3\2\2\2\u0686\u0684\3\2\2\2\u0686\u0687\3\2\2\2")
        buf.write("\u0687\u068b\3\2\2\2\u0688\u0686\3\2\2\2\u0689\u068b\5")
        buf.write("\n\6\2\u068a\u0681\3\2\2\2\u068a\u0689\3\2\2\2\u068b\u00af")
        buf.write("\3\2\2\2\u068c\u068e\7\u0093\2\2\u068d\u068f\7\17\2\2")
        buf.write("\u068e\u068d\3\2\2\2\u068e\u068f\3\2\2\2\u068f\u0691\3")
        buf.write("\2\2\2\u0690\u0692\5\u008aF\2\u0691\u0690\3\2\2\2\u0691")
        buf.write("\u0692\3\2\2\2\u0692\u0693\3\2\2\2\u0693\u0695\5\n\6\2")
        buf.write("\u0694\u0696\7\20\2\2\u0695\u0694\3\2\2\2\u0695\u0696")
        buf.write("\3\2\2\2\u0696\u00b1\3\2\2\2\u0697\u0698\7F\2\2\u0698")
        buf.write("\u0699\7I\2\2\u0699\u069a\7x\2\2\u069a\u069b\7\u00bc\2")
        buf.write("\2\u069b\u00b3\3\2\2\2\u069c\u06a2\7i\2\2\u069d\u06a2")
        buf.write("\7\u00e9\2\2\u069e\u06a2\7h\2\2\u069f\u06a2\7j\2\2\u06a0")
        buf.write("\u06a2\5\u00b6\\\2\u06a1\u069c\3\2\2\2\u06a1\u069d\3\2")
        buf.write("\2\2\u06a1\u069e\3\2\2\2\u06a1\u069f\3\2\2\2\u06a1\u06a0")
        buf.write("\3\2\2\2\u06a2\u00b5\3\2\2\2\u06a3\u06a4\7o\2\2\u06a4")
        buf.write("\u06a5\7j\2\2\u06a5\u00b7\3\2\2\2\u06a6\u06a7\5\n\6\2")
        buf.write("\u06a7\u00b9\3\2\2\2\u06a8\u06a9\t\27\2\2\u06a9\u00bb")
        buf.write("\3\2\2\2\u06aa\u06ab\7\u00f6\2\2\u06ab\u00bd\3\2\2\2\u06ac")
        buf.write("\u06ad\7\u00f7\2\2\u06ad\u00bf\3\2\2\2\u06ae\u06af\7\u00f7")
        buf.write("\2\2\u06af\u00c1\3\2\2\2\u06b0\u06b1\7\u00f7\2\2\u06b1")
        buf.write("\u00c3\3\2\2\2\u06b2\u06b3\7\u00f7\2\2\u06b3\u00c5\3\2")
        buf.write("\2\2\u06b4\u06b5\7\u00f7\2\2\u06b5\u00c7\3\2\2\2\u06b6")
        buf.write("\u06b7\7\u00f7\2\2\u06b7\u00c9\3\2\2\2\u06b8\u06b9\t\30")
        buf.write("\2\2\u06b9\u00cb\3\2\2\2\u06ba\u06bb\7\u0091\2\2\u06bb")
        buf.write("\u06c1\7M\2\2\u06bc\u06bd\7\u0091\2\2\u06bd\u06c1\7\u0092")
        buf.write("\2\2\u06be\u06bf\7\u0091\2\2\u06bf\u06c1\7I\2\2\u06c0")
        buf.write("\u06ba\3\2\2\2\u06c0\u06bc\3\2\2\2\u06c0\u06be\3\2\2\2")
        buf.write("\u06c1\u00cd\3\2\2\2\u06c2\u06c3\t\31\2\2\u06c3\u00cf")
        buf.write("\3\2\2\2\u06c4\u06c5\t\32\2\2\u06c5\u00d1\3\2\2\2\u06c6")
        buf.write("\u06ca\5\u00d4k\2\u06c7\u06ca\5\u00d6l\2\u06c8\u06ca\5")
        buf.write("\u00d8m\2\u06c9\u06c6\3\2\2\2\u06c9\u06c7\3\2\2\2\u06c9")
        buf.write("\u06c8\3\2\2\2\u06ca\u06cc\3\2\2\2\u06cb\u06cd\5\u00da")
        buf.write("n\2\u06cc\u06cb\3\2\2\2\u06cc\u06cd\3\2\2\2\u06cd\u06d2")
        buf.write("\3\2\2\2\u06ce\u06d0\7\63\2\2\u06cf\u06ce\3\2\2\2\u06cf")
        buf.write("\u06d0\3\2\2\2\u06d0\u06d1\3\2\2\2\u06d1\u06d3\7\u00f5")
        buf.write("\2\2\u06d2\u06cf\3\2\2\2\u06d2\u06d3\3\2\2\2\u06d3\u00d3")
        buf.write("\3\2\2\2\u06d4\u06d5\t\33\2\2\u06d5\u00d5\3\2\2\2\u06d6")
        buf.write("\u06d7\7\u00f7\2\2\u06d7\u00d7\3\2\2\2\u06d8\u06d9\7\u00f7")
        buf.write("\2\2\u06d9\u00d9\3\2\2\2\u06da\u06db\7\3\2\2\u06db\u06dc")
        buf.write("\5\n\6\2\u06dc\u06dd\7\4\2\2\u06dd\u06ea\3\2\2\2\u06de")
        buf.write("\u06df\7\22\2\2\u06df\u06e4\5\u00ceh\2\u06e0\u06e1\7?")
        buf.write("\2\2\u06e1\u06e3\5\u00ceh\2\u06e2\u06e0\3\2\2\2\u06e3")
        buf.write("\u06e6\3\2\2\2\u06e4\u06e2\3\2\2\2\u06e4\u06e5\3\2\2\2")
        buf.write("\u06e5\u06e7\3\2\2\2\u06e6\u06e4\3\2\2\2\u06e7\u06e8\7")
        buf.write("\23\2\2\u06e8\u06ea\3\2\2\2\u06e9\u06da\3\2\2\2\u06e9")
        buf.write("\u06de\3\2\2\2\u06ea\u00db\3\2\2\2\u06eb\u06f2\5\u00d2")
        buf.write("j\2\u06ec\u06f2\5\u00dep\2\u06ed\u06f2\5\u00e0q\2\u06ee")
        buf.write("\u06f2\5\u00f6|\2\u06ef\u06f2\5\u00f0y\2\u06f0\u06f2\5")
        buf.write("\u00e6t\2\u06f1\u06eb\3\2\2\2\u06f1\u06ec\3\2\2\2\u06f1")
        buf.write("\u06ed\3\2\2\2\u06f1\u06ee\3\2\2\2\u06f1\u06ef\3\2\2\2")
        buf.write("\u06f1\u06f0\3\2\2\2\u06f2\u00dd\3\2\2\2\u06f3\u06f8\5")
        buf.write("\u00b4[\2\u06f4\u06f5\7\n\2\2\u06f5\u06f6\5\u00d2j\2\u06f6")
        buf.write("\u06f7\7\t\2\2\u06f7\u06f9\3\2\2\2\u06f8\u06f4\3\2\2\2")
        buf.write("\u06f8\u06f9\3\2\2\2\u06f9\u00df\3\2\2\2\u06fa\u0706\7")
        buf.write("z\2\2\u06fb\u06fc\7\22\2\2\u06fc\u0701\5\u00e2r\2\u06fd")
        buf.write("\u06fe\7?\2\2\u06fe\u0700\5\u00e2r\2\u06ff\u06fd\3\2\2")
        buf.write("\2\u0700\u0703\3\2\2\2\u0701\u06ff\3\2\2\2\u0701\u0702")
        buf.write("\3\2\2\2\u0702\u0704\3\2\2\2\u0703\u0701\3\2\2\2\u0704")
        buf.write("\u0705\7\23\2\2\u0705\u0707\3\2\2\2\u0706\u06fb\3\2\2")
        buf.write("\2\u0706\u0707\3\2\2\2\u0707\u00e1\3\2\2\2\u0708\u070b")
        buf.write("\5\u00dep\2\u0709\u070c\5\u00c4c\2\u070a\u070c\5\u00e4")
        buf.write("s\2\u070b\u0709\3\2\2\2\u070b\u070a\3\2\2\2\u070c\u00e3")
        buf.write("\3\2\2\2\u070d\u070f\7t\2\2\u070e\u0710\t\34\2\2\u070f")
        buf.write("\u070e\3\2\2\2\u070f\u0710\3\2\2\2\u0710\u00e5\3\2\2\2")
        buf.write("\u0711\u0715\7\u0080\2\2\u0712\u0715\5\u00e8u\2\u0713")
        buf.write("\u0715\5\u00eav\2\u0714\u0711\3\2\2\2\u0714\u0712\3\2")
        buf.write("\2\2\u0714\u0713\3\2\2\2\u0715\u00e7\3\2\2\2\u0716\u0722")
        buf.write("\7~\2\2\u0717\u0718\7\u00ea\2\2\u0718\u0719\7\22\2\2\u0719")
        buf.write("\u071a\5\u00ecw\2\u071a\u071b\7\23\2\2\u071b\u0722\3\2")
        buf.write("\2\2\u071c\u071d\7\u00eb\2\2\u071d\u071e\7\22\2\2\u071e")
        buf.write("\u071f\5\u00eex\2\u071f\u0720\7\23\2\2\u0720\u0722\3\2")
        buf.write("\2\2\u0721\u0716\3\2\2\2\u0721\u0717\3\2\2\2\u0721\u071c")
        buf.write("\3\2\2\2\u0722\u00e9\3\2\2\2\u0723\u073e\7\177\2\2\u0724")
        buf.write("\u072e\7\u00ec\2\2\u0725\u0726\7\22\2\2\u0726\u072b\7")
        buf.write("\u00f7\2\2\u0727\u0728\7\17\2\2\u0728\u0729\5\u00ecw\2")
        buf.write("\u0729\u072a\7\20\2\2\u072a\u072c\3\2\2\2\u072b\u0727")
        buf.write("\3\2\2\2\u072b\u072c\3\2\2\2\u072c\u072d\3\2\2\2\u072d")
        buf.write("\u072f\7\23\2\2\u072e\u0725\3\2\2\2\u072e\u072f\3\2\2")
        buf.write("\2\u072f\u073e\3\2\2\2\u0730\u073b\7\u00ed\2\2\u0731\u0732")
        buf.write("\7\22\2\2\u0732\u0737\5\u00c2b\2\u0733\u0734\7\17\2\2")
        buf.write("\u0734\u0735\5\u00eex\2\u0735\u0736\7\20\2\2\u0736\u0738")
        buf.write("\3\2\2\2\u0737\u0733\3\2\2\2\u0737\u0738\3\2\2\2\u0738")
        buf.write("\u0739\3\2\2\2\u0739\u073a\7\23\2\2\u073a\u073c\3\2\2")
        buf.write("\2\u073b\u0731\3\2\2\2\u073b\u073c\3\2\2\2\u073c\u073e")
        buf.write("\3\2\2\2\u073d\u0723\3\2\2\2\u073d\u0724\3\2\2\2\u073d")
        buf.write("\u0730\3\2\2\2\u073e\u00eb\3\2\2\2\u073f\u0744\7\u00f7")
        buf.write("\2\2\u0740\u0741\7\7\2\2\u0741\u0743\7\u00f7\2\2\u0742")
        buf.write("\u0740\3\2\2\2\u0743\u0746\3\2\2\2\u0744\u0742\3\2\2\2")
        buf.write("\u0744\u0745\3\2\2\2\u0745\u00ed\3\2\2\2\u0746\u0744\3")
        buf.write("\2\2\2\u0747\u074c\5\u00c2b\2\u0748\u0749\7\7\2\2\u0749")
        buf.write("\u074b\5\u00c2b\2\u074a\u0748\3\2\2\2\u074b\u074e\3\2")
        buf.write("\2\2\u074c\u074a\3\2\2\2\u074c\u074d\3\2\2\2\u074d\u00ef")
        buf.write("\3\2\2\2\u074e\u074c\3\2\2\2\u074f\u0754\5\u00f2z\2\u0750")
        buf.write("\u0751\7\7\2\2\u0751\u0753\5\u00f2z\2\u0752\u0750\3\2")
        buf.write("\2\2\u0753\u0756\3\2\2\2\u0754\u0752\3\2\2\2\u0754\u0755")
        buf.write("\3\2\2\2\u0755\u0757\3\2\2\2\u0756\u0754\3\2\2\2\u0757")
        buf.write("\u0758\7\24\2\2\u0758\u0759\5\u00f4{\2\u0759\u00f1\3\2")
        buf.write("\2\2\u075a\u075e\5\u00d2j\2\u075b\u075e\5\u00e0q\2\u075c")
        buf.write("\u075e\5\u00dep\2\u075d\u075a\3\2\2\2\u075d\u075b\3\2")
        buf.write("\2\2\u075d\u075c\3\2\2\2\u075e\u00f3\3\2\2\2\u075f\u0765")
        buf.write("\5\u00d2j\2\u0760\u0765\5\u00e0q\2\u0761\u0765\5\u00f6")
        buf.write("|\2\u0762\u0765\5\u00e6t\2\u0763\u0765\5\u00dep\2\u0764")
        buf.write("\u075f\3\2\2\2\u0764\u0760\3\2\2\2\u0764\u0761\3\2\2\2")
        buf.write("\u0764\u0762\3\2\2\2\u0764\u0763\3\2\2\2\u0765\u00f5\3")
        buf.write("\2\2\2\u0766\u076b\7\u00ee\2\2\u0767\u0768\7\n\2\2\u0768")
        buf.write("\u0769\5\u00d2j\2\u0769\u076a\7\t\2\2\u076a\u076c\3\2")
        buf.write("\2\2\u076b\u0767\3\2\2\2\u076b\u076c\3\2\2\2\u076c\u00f7")
        buf.write("\3\2\2\2\u076d\u076e\t\35\2\2\u076e\u00f9\3\2\2\2\u076f")
        buf.write("\u0770\7|\2\2\u0770\u0771\7~\2\2\u0771\u0772\7\u0080\2")
        buf.write("\2\u0772\u00fb\3\2\2\2\u0773\u0774\7|\2\2\u0774\u0775")
        buf.write("\7\177\2\2\u0775\u0776\7\u0080\2\2\u0776\u00fd\3\2\2\2")
        buf.write("\u0777\u0778\7\u0082\2\2\u0778\u0779\7~\2\2\u0779\u077a")
        buf.write("\7\u0080\2\2\u077a\u00ff\3\2\2\2\u077b\u077c\7\u0082\2")
        buf.write("\2\u077c\u077d\7\177\2\2\u077d\u077e\7\u0080\2\2\u077e")
        buf.write("\u0101\3\2\2\2\u077f\u0780\7|\2\2\u0780\u0781\7x\2\2\u0781")
        buf.write("\u0782\7y\2\2\u0782\u0103\3\2\2\2\u00cc\u0105\u010a\u0110")
        buf.write("\u0116\u011a\u011f\u0124\u0128\u0130\u013a\u0140\u0145")
        buf.write("\u0150\u0167\u0171\u018c\u0192\u0194\u0196\u01a4\u01aa")
        buf.write("\u01e7\u01f7\u01fc\u0200\u0203\u0207\u0210\u0216\u021a")
        buf.write("\u0221\u0228\u022c\u0233\u0237\u0247\u024c\u0252\u0256")
        buf.write("\u0259\u0261\u0267\u026c\u0277\u027a\u027f\u028a\u0290")
        buf.write("\u0295\u0299\u029c\u02a5\u02ce\u030a\u030e\u0319\u031d")
        buf.write("\u0328\u0357\u035f\u0367\u0372\u037d\u0382\u0386\u038c")
        buf.write("\u0390\u039a\u039e\u03a5\u03b5\u03be\u03c3\u03c5\u03c9")
        buf.write("\u03d1\u03d4\u03d8\u03db\u03ea\u03ed\u03f0\u03ff\u0402")
        buf.write("\u0406\u0409\u040c\u040f\u0424\u0427\u042b\u042f\u0433")
        buf.write("\u0437\u0445\u0449\u044d\u0453\u0459\u045c\u045f\u046b")
        buf.write("\u0472\u0477\u047b\u0481\u0493\u0499\u04a0\u04a6\u04aa")
        buf.write("\u04b3\u04b6\u04b9\u04be\u04c2\u04c5\u04c8\u04cf\u04d4")
        buf.write("\u04d9\u04de\u04e6\u04ee\u04f2\u04f5\u04f8\u04ff\u050c")
        buf.write("\u0515\u051b\u0521\u0528\u052f\u0536\u053c\u0549\u054d")
        buf.write("\u0558\u055c\u0563\u0566\u0575\u0585\u05b0\u05b8\u05bc")
        buf.write("\u05c8\u05d0\u05d8\u05e0\u05e8\u05ff\u0605\u060a\u060c")
        buf.write("\u0615\u062f\u0634\u0647\u0650\u0656\u065a\u065e\u0661")
        buf.write("\u066a\u0670\u0674\u0679\u067c\u0686\u068a\u068e\u0691")
        buf.write("\u0695\u06a1\u06c0\u06c9\u06cc\u06cf\u06d2\u06e4\u06e9")
        buf.write("\u06f1\u06f8\u0701\u0706\u070b\u070f\u0714\u0721\u072b")
        buf.write("\u072e\u0737\u073b\u073d\u0744\u074c\u0754\u075d\u0764")
        buf.write("\u076b")
        return buf.getvalue()


class VtlParser(Parser):

    grammarFileName = "Vtl.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [DFA(ds, i) for i, ds in enumerate(atn.decisionToState)]

    sharedContextCache = PredictionContextCache()

    literalNames = [
        "<INVALID>",
        "'['",
        "']'",
        "'+'",
        "'-'",
        "'*'",
        "'/'",
        "'>'",
        "'<'",
        "'<='",
        "'>='",
        "'='",
        "'<>'",
        "'('",
        "')'",
        "':'",
        "'{'",
        "'}'",
        "'->'",
        "':='",
        "'#'",
        "'eval'",
        "'if'",
        "'case'",
        "'then'",
        "'else'",
        "'using'",
        "'with'",
        "'current_date'",
        "'datediff'",
        "'dateadd'",
        "'year'",
        "'month'",
        "'dayofmonth'",
        "'dayofyear'",
        "'daytoyear'",
        "'daytomonth'",
        "'yeartoday'",
        "'monthtoday'",
        "'on'",
        "'drop'",
        "'keep'",
        "'calc'",
        "'attrcalc'",
        "'rename'",
        "'as'",
        "'and'",
        "'or'",
        "'xor'",
        "'not'",
        "'between'",
        "'in'",
        "'not_in'",
        "'isnull'",
        "'ex'",
        "'union'",
        "'diff'",
        "'symdiff'",
        "'intersect'",
        "'random'",
        "'keys'",
        "','",
        "'intyear'",
        "'intmonth'",
        "'intday'",
        "'check'",
        "'exists_in'",
        "'to'",
        "'return'",
        "'imbalance'",
        "'errorcode'",
        "'all'",
        "'aggr'",
        "'errorlevel'",
        "'order'",
        "'by'",
        "'rank'",
        "'asc'",
        "'desc'",
        "'min'",
        "'max'",
        "'first'",
        "'last'",
        "'indexof'",
        "'abs'",
        "'key'",
        "'ln'",
        "'log'",
        "'trunc'",
        "'round'",
        "'power'",
        "'mod'",
        "'length'",
        "'||'",
        "'trim'",
        "'upper'",
        "'lower'",
        "'substr'",
        "'sum'",
        "'avg'",
        "'median'",
        "'count'",
        "'identifier'",
        "'measure'",
        "'attribute'",
        "'filter'",
        "'merge'",
        "'exp'",
        "'role'",
        "'viral'",
        "'match_characters'",
        "'type'",
        "'nvl'",
        "'hierarchy'",
        "'_'",
        "'invalid'",
        "'valuedomain'",
        "'variable'",
        "'data'",
        "'structure'",
        "'dataset'",
        "'operator'",
        "'define'",
        "'<-'",
        "'datapoint'",
        "'hierarchical'",
        "'ruleset'",
        "'rule'",
        "'end'",
        "'alterDataset'",
        "'ltrim'",
        "'rtrim'",
        "'instr'",
        "'replace'",
        "'ceil'",
        "'floor'",
        "'sqrt'",
        "'any'",
        "'setdiff'",
        "'stddev_pop'",
        "'stddev_samp'",
        "'var_pop'",
        "'var_samp'",
        "'group'",
        "'except'",
        "'having'",
        "'first_value'",
        "'last_value'",
        "'lag'",
        "'lead'",
        "'ratio_to_report'",
        "'over'",
        "'preceding'",
        "'following'",
        "'unbounded'",
        "'partition'",
        "'rows'",
        "'range'",
        "'current'",
        "'valid'",
        "'fill_time_series'",
        "'flow_to_stock'",
        "'stock_to_flow'",
        "'timeshift'",
        "'measures'",
        "'no_measures'",
        "'condition'",
        "'boolean'",
        "'date'",
        "'time_period'",
        "'number'",
        "'string'",
        "'integer'",
        "'float'",
        "'list'",
        "'record'",
        "'restrict'",
        "'yyyy'",
        "'mm'",
        "'dd'",
        "'maxLength'",
        "'regexp'",
        "'is'",
        "'when'",
        "'from'",
        "'aggregates'",
        "'points'",
        "'point'",
        "'total'",
        "'partial'",
        "'always'",
        "'inner_join'",
        "'left_join'",
        "'cross_join'",
        "'full_join'",
        "'maps_from'",
        "'maps_to'",
        "'map_to'",
        "'map_from'",
        "'returns'",
        "'pivot'",
        "'unpivot'",
        "'sub'",
        "'apply'",
        "'conditioned'",
        "'period_indicator'",
        "'single'",
        "'duration'",
        "'time_agg'",
        "'unit'",
        "'Value'",
        "'valuedomains'",
        "'variables'",
        "'input'",
        "'output'",
        "'cast'",
        "'rule_priority'",
        "'dataset_priority'",
        "'default'",
        "'check_datapoint'",
        "'check_hierarchy'",
        "'computed'",
        "'non_null'",
        "'non_zero'",
        "'partial_null'",
        "'partial_zero'",
        "'always_null'",
        "'always_zero'",
        "'components'",
        "'all_measures'",
        "'scalar'",
        "'component'",
        "'datapoint_on_valuedomains'",
        "'datapoint_on_variables'",
        "'hierarchical_on_valuedomains'",
        "'hierarchical_on_variables'",
        "'set'",
        "'language'",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "'null'",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "';'",
    ]

    symbolicNames = [
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "ASSIGN",
        "MEMBERSHIP",
        "EVAL",
        "IF",
        "CASE",
        "THEN",
        "ELSE",
        "USING",
        "WITH",
        "CURRENT_DATE",
        "DATEDIFF",
        "DATEADD",
        "YEAR_OP",
        "MONTH_OP",
        "DAYOFMONTH",
        "DAYOFYEAR",
        "DAYTOYEAR",
        "DAYTOMONTH",
        "YEARTODAY",
        "MONTHTODAY",
        "ON",
        "DROP",
        "KEEP",
        "CALC",
        "ATTRCALC",
        "RENAME",
        "AS",
        "AND",
        "OR",
        "XOR",
        "NOT",
        "BETWEEN",
        "IN",
        "NOT_IN",
        "ISNULL",
        "EX",
        "UNION",
        "DIFF",
        "SYMDIFF",
        "INTERSECT",
        "RANDOM",
        "KEYS",
        "CARTESIAN_PER",
        "INTYEAR",
        "INTMONTH",
        "INTDAY",
        "CHECK",
        "EXISTS_IN",
        "TO",
        "RETURN",
        "IMBALANCE",
        "ERRORCODE",
        "ALL",
        "AGGREGATE",
        "ERRORLEVEL",
        "ORDER",
        "BY",
        "RANK",
        "ASC",
        "DESC",
        "MIN",
        "MAX",
        "FIRST",
        "LAST",
        "INDEXOF",
        "ABS",
        "KEY",
        "LN",
        "LOG",
        "TRUNC",
        "ROUND",
        "POWER",
        "MOD",
        "LEN",
        "CONCAT",
        "TRIM",
        "UCASE",
        "LCASE",
        "SUBSTR",
        "SUM",
        "AVG",
        "MEDIAN",
        "COUNT",
        "DIMENSION",
        "MEASURE",
        "ATTRIBUTE",
        "FILTER",
        "MERGE",
        "EXP",
        "ROLE",
        "VIRAL",
        "CHARSET_MATCH",
        "TYPE",
        "NVL",
        "HIERARCHY",
        "OPTIONAL",
        "INVALID",
        "VALUE_DOMAIN",
        "VARIABLE",
        "DATA",
        "STRUCTURE",
        "DATASET",
        "OPERATOR",
        "DEFINE",
        "PUT_SYMBOL",
        "DATAPOINT",
        "HIERARCHICAL",
        "RULESET",
        "RULE",
        "END",
        "ALTER_DATASET",
        "LTRIM",
        "RTRIM",
        "INSTR",
        "REPLACE",
        "CEIL",
        "FLOOR",
        "SQRT",
        "ANY",
        "SETDIFF",
        "STDDEV_POP",
        "STDDEV_SAMP",
        "VAR_POP",
        "VAR_SAMP",
        "GROUP",
        "EXCEPT",
        "HAVING",
        "FIRST_VALUE",
        "LAST_VALUE",
        "LAG",
        "LEAD",
        "RATIO_TO_REPORT",
        "OVER",
        "PRECEDING",
        "FOLLOWING",
        "UNBOUNDED",
        "PARTITION",
        "ROWS",
        "RANGE",
        "CURRENT",
        "VALID",
        "FILL_TIME_SERIES",
        "FLOW_TO_STOCK",
        "STOCK_TO_FLOW",
        "TIMESHIFT",
        "MEASURES",
        "NO_MEASURES",
        "CONDITION",
        "BOOLEAN",
        "DATE",
        "TIME_PERIOD",
        "NUMBER",
        "STRING",
        "INTEGER",
        "FLOAT",
        "LIST",
        "RECORD",
        "RESTRICT",
        "YYYY",
        "MM",
        "DD",
        "MAX_LENGTH",
        "REGEXP",
        "IS",
        "WHEN",
        "FROM",
        "AGGREGATES",
        "POINTS",
        "POINT",
        "TOTAL",
        "PARTIAL",
        "ALWAYS",
        "INNER_JOIN",
        "LEFT_JOIN",
        "CROSS_JOIN",
        "FULL_JOIN",
        "MAPS_FROM",
        "MAPS_TO",
        "MAP_TO",
        "MAP_FROM",
        "RETURNS",
        "PIVOT",
        "UNPIVOT",
        "SUBSPACE",
        "APPLY",
        "CONDITIONED",
        "PERIOD_INDICATOR",
        "SINGLE",
        "DURATION",
        "TIME_AGG",
        "UNIT",
        "VALUE",
        "VALUEDOMAINS",
        "VARIABLES",
        "INPUT",
        "OUTPUT",
        "CAST",
        "RULE_PRIORITY",
        "DATASET_PRIORITY",
        "DEFAULT",
        "CHECK_DATAPOINT",
        "CHECK_HIERARCHY",
        "COMPUTED",
        "NON_NULL",
        "NON_ZERO",
        "PARTIAL_NULL",
        "PARTIAL_ZERO",
        "ALWAYS_NULL",
        "ALWAYS_ZERO",
        "COMPONENTS",
        "ALL_MEASURES",
        "SCALAR",
        "COMPONENT",
        "DATAPOINT_ON_VD",
        "DATAPOINT_ON_VAR",
        "HIERARCHICAL_ON_VD",
        "HIERARCHICAL_ON_VAR",
        "SET",
        "LANGUAGE",
        "INTEGER_CONSTANT",
        "POSITIVE_CONSTANT",
        "NEGATIVE_CONSTANT",
        "FLOAT_CONSTANT",
        "BOOLEAN_CONSTANT",
        "NULL_CONSTANT",
        "STRING_CONSTANT",
        "IDENTIFIER",
        "DIGITS0_9",
        "MONTH",
        "DAY",
        "YEAR",
        "WEEK",
        "HOURS",
        "MINUTES",
        "SECONDS",
        "DATE_FORMAT",
        "TIME_FORMAT",
        "TIME_UNIT",
        "TIME",
        "WS",
        "EOL",
        "ML_COMMENT",
        "SL_COMMENT",
        "COMPARISON_OP",
        "FREQUENCY",
    ]

    RULE_start = 0
    RULE_statement = 1
    RULE_persistentAssignment = 2
    RULE_optionalExpr = 3
    RULE_expr = 4
    RULE_exprComplex = 5
    RULE_timeExpr = 6
    RULE_defHierarchical = 7
    RULE_ruleClauseHierarchical = 8
    RULE_ruleItemHierarchical = 9
    RULE_hierRuleSignature = 10
    RULE_valueDomainSignature = 11
    RULE_codeItemRelation = 12
    RULE_codeItemRelationClause = 13
    RULE_codeItemRef = 14
    RULE_defDatapoint = 15
    RULE_ruleClauseDatapoint = 16
    RULE_ruleItemDatapoint = 17
    RULE_rulesetSignature = 18
    RULE_varSignature = 19
    RULE_defExpr = 20
    RULE_defOperator = 21
    RULE_parameterItem = 22
    RULE_callFunction = 23
    RULE_exprAtom = 24
    RULE_ref = 25
    RULE_identifierList = 26
    RULE_lists = 27
    RULE_evalExpr = 28
    RULE_castExpr = 29
    RULE_periodExpr = 30
    RULE_timeShiftExpr = 31
    RULE_timeSeriesExpr = 32
    RULE_timeAggExpr = 33
    RULE_validationExpr = 34
    RULE_validationDatapoint = 35
    RULE_validationHierarchical = 36
    RULE_erCode = 37
    RULE_erLevel = 38
    RULE_hierarchyExpr = 39
    RULE_datasetClause = 40
    RULE_anFunctionClause = 41
    RULE_partitionByClause = 42
    RULE_orderByClause = 43
    RULE_windowingClause = 44
    RULE_limitClauseItem = 45
    RULE_joinExpr = 46
    RULE_joinClause = 47
    RULE_joinBody = 48
    RULE_joinCalcClause = 49
    RULE_joinCalcClauseItem = 50
    RULE_joinCalcExpr = 51
    RULE_joinAggClause = 52
    RULE_joinAggClauseItem = 53
    RULE_joinAggExpr = 54
    RULE_joinKeepClause = 55
    RULE_joinDropClause = 56
    RULE_joinFilterClause = 57
    RULE_joinRenameClause = 58
    RULE_joinApplyClause = 59
    RULE_anFunction = 60
    RULE_aggregateClause = 61
    RULE_aggrFunctionClause = 62
    RULE_getFiltersClause = 63
    RULE_getFilterClause = 64
    RULE_aggrClause = 65
    RULE_filterClause = 66
    RULE_renameClause = 67
    RULE_aggrFunction = 68
    RULE_calcClause = 69
    RULE_calcClauseItem = 70
    RULE_calcExpr = 71
    RULE_dropClause = 72
    RULE_dropClauseItem = 73
    RULE_keepClause = 74
    RULE_keepClauseItem = 75
    RULE_unpivotExpr = 76
    RULE_pivotExpr = 77
    RULE_subspaceExpr = 78
    RULE_inBetweenClause = 79
    RULE_setExpr = 80
    RULE_randExpr = 81
    RULE_subscriptExpr = 82
    RULE_aggrInvocation = 83
    RULE_aggrInvocationCompExpr = 84
    RULE_aggrFunctionName = 85
    RULE_groupingClause = 86
    RULE_havingClause = 87
    RULE_returnAll = 88
    RULE_componentRole = 89
    RULE_viralAttribute = 90
    RULE_logBase = 91
    RULE_exponent = 92
    RULE_persistentDatasetID = 93
    RULE_datasetID = 94
    RULE_rulesetID = 95
    RULE_varID = 96
    RULE_componentID = 97
    RULE_operatorID = 98
    RULE_routineName = 99
    RULE_joinKeyword = 100
    RULE_groupKeyword = 101
    RULE_constant = 102
    RULE_componentType2 = 103
    RULE_scalarType = 104
    RULE_basicScalarType = 105
    RULE_valueDomainName = 106
    RULE_setName = 107
    RULE_scalarTypeConstraint = 108
    RULE_dataType = 109
    RULE_componentType = 110
    RULE_datasetType = 111
    RULE_compConstraint = 112
    RULE_multModifier = 113
    RULE_rulesetType = 114
    RULE_dpRuleset = 115
    RULE_hrRuleset = 116
    RULE_prodValueDomains = 117
    RULE_prodVariables = 118
    RULE_operatorType = 119
    RULE_inputParameterType = 120
    RULE_outputParameterType = 121
    RULE_scalarSetType = 122
    RULE_retainType = 123
    RULE_defineDatapointRuleset = 124
    RULE_defineHierarchicalRuleset = 125
    RULE_endDatapointRuleset = 126
    RULE_endHierarchicalRuleset = 127
    RULE_defineDataStructure = 128

    ruleNames = [
        "start",
        "statement",
        "persistentAssignment",
        "optionalExpr",
        "expr",
        "exprComplex",
        "timeExpr",
        "defHierarchical",
        "ruleClauseHierarchical",
        "ruleItemHierarchical",
        "hierRuleSignature",
        "valueDomainSignature",
        "codeItemRelation",
        "codeItemRelationClause",
        "codeItemRef",
        "defDatapoint",
        "ruleClauseDatapoint",
        "ruleItemDatapoint",
        "rulesetSignature",
        "varSignature",
        "defExpr",
        "defOperator",
        "parameterItem",
        "callFunction",
        "exprAtom",
        "ref",
        "identifierList",
        "lists",
        "evalExpr",
        "castExpr",
        "periodExpr",
        "timeShiftExpr",
        "timeSeriesExpr",
        "timeAggExpr",
        "validationExpr",
        "validationDatapoint",
        "validationHierarchical",
        "erCode",
        "erLevel",
        "hierarchyExpr",
        "datasetClause",
        "anFunctionClause",
        "partitionByClause",
        "orderByClause",
        "windowingClause",
        "limitClauseItem",
        "joinExpr",
        "joinClause",
        "joinBody",
        "joinCalcClause",
        "joinCalcClauseItem",
        "joinCalcExpr",
        "joinAggClause",
        "joinAggClauseItem",
        "joinAggExpr",
        "joinKeepClause",
        "joinDropClause",
        "joinFilterClause",
        "joinRenameClause",
        "joinApplyClause",
        "anFunction",
        "aggregateClause",
        "aggrFunctionClause",
        "getFiltersClause",
        "getFilterClause",
        "aggrClause",
        "filterClause",
        "renameClause",
        "aggrFunction",
        "calcClause",
        "calcClauseItem",
        "calcExpr",
        "dropClause",
        "dropClauseItem",
        "keepClause",
        "keepClauseItem",
        "unpivotExpr",
        "pivotExpr",
        "subspaceExpr",
        "inBetweenClause",
        "setExpr",
        "randExpr",
        "subscriptExpr",
        "aggrInvocation",
        "aggrInvocationCompExpr",
        "aggrFunctionName",
        "groupingClause",
        "havingClause",
        "returnAll",
        "componentRole",
        "viralAttribute",
        "logBase",
        "exponent",
        "persistentDatasetID",
        "datasetID",
        "rulesetID",
        "varID",
        "componentID",
        "operatorID",
        "routineName",
        "joinKeyword",
        "groupKeyword",
        "constant",
        "componentType2",
        "scalarType",
        "basicScalarType",
        "valueDomainName",
        "setName",
        "scalarTypeConstraint",
        "dataType",
        "componentType",
        "datasetType",
        "compConstraint",
        "multModifier",
        "rulesetType",
        "dpRuleset",
        "hrRuleset",
        "prodValueDomains",
        "prodVariables",
        "operatorType",
        "inputParameterType",
        "outputParameterType",
        "scalarSetType",
        "retainType",
        "defineDatapointRuleset",
        "defineHierarchicalRuleset",
        "endDatapointRuleset",
        "endHierarchicalRuleset",
        "defineDataStructure",
    ]

    EOF = Token.EOF
    T__0 = 1
    T__1 = 2
    T__2 = 3
    T__3 = 4
    T__4 = 5
    T__5 = 6
    T__6 = 7
    T__7 = 8
    T__8 = 9
    T__9 = 10
    T__10 = 11
    T__11 = 12
    T__12 = 13
    T__13 = 14
    T__14 = 15
    T__15 = 16
    T__16 = 17
    T__17 = 18
    ASSIGN = 19
    MEMBERSHIP = 20
    EVAL = 21
    IF = 22
    CASE = 23
    THEN = 24
    ELSE = 25
    USING = 26
    WITH = 27
    CURRENT_DATE = 28
    DATEDIFF = 29
    DATEADD = 30
    YEAR_OP = 31
    MONTH_OP = 32
    DAYOFMONTH = 33
    DAYOFYEAR = 34
    DAYTOYEAR = 35
    DAYTOMONTH = 36
    YEARTODAY = 37
    MONTHTODAY = 38
    ON = 39
    DROP = 40
    KEEP = 41
    CALC = 42
    ATTRCALC = 43
    RENAME = 44
    AS = 45
    AND = 46
    OR = 47
    XOR = 48
    NOT = 49
    BETWEEN = 50
    IN = 51
    NOT_IN = 52
    ISNULL = 53
    EX = 54
    UNION = 55
    DIFF = 56
    SYMDIFF = 57
    INTERSECT = 58
    RANDOM = 59
    KEYS = 60
    CARTESIAN_PER = 61
    INTYEAR = 62
    INTMONTH = 63
    INTDAY = 64
    CHECK = 65
    EXISTS_IN = 66
    TO = 67
    RETURN = 68
    IMBALANCE = 69
    ERRORCODE = 70
    ALL = 71
    AGGREGATE = 72
    ERRORLEVEL = 73
    ORDER = 74
    BY = 75
    RANK = 76
    ASC = 77
    DESC = 78
    MIN = 79
    MAX = 80
    FIRST = 81
    LAST = 82
    INDEXOF = 83
    ABS = 84
    KEY = 85
    LN = 86
    LOG = 87
    TRUNC = 88
    ROUND = 89
    POWER = 90
    MOD = 91
    LEN = 92
    CONCAT = 93
    TRIM = 94
    UCASE = 95
    LCASE = 96
    SUBSTR = 97
    SUM = 98
    AVG = 99
    MEDIAN = 100
    COUNT = 101
    DIMENSION = 102
    MEASURE = 103
    ATTRIBUTE = 104
    FILTER = 105
    MERGE = 106
    EXP = 107
    ROLE = 108
    VIRAL = 109
    CHARSET_MATCH = 110
    TYPE = 111
    NVL = 112
    HIERARCHY = 113
    OPTIONAL = 114
    INVALID = 115
    VALUE_DOMAIN = 116
    VARIABLE = 117
    DATA = 118
    STRUCTURE = 119
    DATASET = 120
    OPERATOR = 121
    DEFINE = 122
    PUT_SYMBOL = 123
    DATAPOINT = 124
    HIERARCHICAL = 125
    RULESET = 126
    RULE = 127
    END = 128
    ALTER_DATASET = 129
    LTRIM = 130
    RTRIM = 131
    INSTR = 132
    REPLACE = 133
    CEIL = 134
    FLOOR = 135
    SQRT = 136
    ANY = 137
    SETDIFF = 138
    STDDEV_POP = 139
    STDDEV_SAMP = 140
    VAR_POP = 141
    VAR_SAMP = 142
    GROUP = 143
    EXCEPT = 144
    HAVING = 145
    FIRST_VALUE = 146
    LAST_VALUE = 147
    LAG = 148
    LEAD = 149
    RATIO_TO_REPORT = 150
    OVER = 151
    PRECEDING = 152
    FOLLOWING = 153
    UNBOUNDED = 154
    PARTITION = 155
    ROWS = 156
    RANGE = 157
    CURRENT = 158
    VALID = 159
    FILL_TIME_SERIES = 160
    FLOW_TO_STOCK = 161
    STOCK_TO_FLOW = 162
    TIMESHIFT = 163
    MEASURES = 164
    NO_MEASURES = 165
    CONDITION = 166
    BOOLEAN = 167
    DATE = 168
    TIME_PERIOD = 169
    NUMBER = 170
    STRING = 171
    INTEGER = 172
    FLOAT = 173
    LIST = 174
    RECORD = 175
    RESTRICT = 176
    YYYY = 177
    MM = 178
    DD = 179
    MAX_LENGTH = 180
    REGEXP = 181
    IS = 182
    WHEN = 183
    FROM = 184
    AGGREGATES = 185
    POINTS = 186
    POINT = 187
    TOTAL = 188
    PARTIAL = 189
    ALWAYS = 190
    INNER_JOIN = 191
    LEFT_JOIN = 192
    CROSS_JOIN = 193
    FULL_JOIN = 194
    MAPS_FROM = 195
    MAPS_TO = 196
    MAP_TO = 197
    MAP_FROM = 198
    RETURNS = 199
    PIVOT = 200
    UNPIVOT = 201
    SUBSPACE = 202
    APPLY = 203
    CONDITIONED = 204
    PERIOD_INDICATOR = 205
    SINGLE = 206
    DURATION = 207
    TIME_AGG = 208
    UNIT = 209
    VALUE = 210
    VALUEDOMAINS = 211
    VARIABLES = 212
    INPUT = 213
    OUTPUT = 214
    CAST = 215
    RULE_PRIORITY = 216
    DATASET_PRIORITY = 217
    DEFAULT = 218
    CHECK_DATAPOINT = 219
    CHECK_HIERARCHY = 220
    COMPUTED = 221
    NON_NULL = 222
    NON_ZERO = 223
    PARTIAL_NULL = 224
    PARTIAL_ZERO = 225
    ALWAYS_NULL = 226
    ALWAYS_ZERO = 227
    COMPONENTS = 228
    ALL_MEASURES = 229
    SCALAR = 230
    COMPONENT = 231
    DATAPOINT_ON_VD = 232
    DATAPOINT_ON_VAR = 233
    HIERARCHICAL_ON_VD = 234
    HIERARCHICAL_ON_VAR = 235
    SET = 236
    LANGUAGE = 237
    INTEGER_CONSTANT = 238
    POSITIVE_CONSTANT = 239
    NEGATIVE_CONSTANT = 240
    FLOAT_CONSTANT = 241
    BOOLEAN_CONSTANT = 242
    NULL_CONSTANT = 243
    STRING_CONSTANT = 244
    IDENTIFIER = 245
    DIGITS0_9 = 246
    MONTH = 247
    DAY = 248
    YEAR = 249
    WEEK = 250
    HOURS = 251
    MINUTES = 252
    SECONDS = 253
    DATE_FORMAT = 254
    TIME_FORMAT = 255
    TIME_UNIT = 256
    TIME = 257
    WS = 258
    EOL = 259
    ML_COMMENT = 260
    SL_COMMENT = 261
    COMPARISON_OP = 262
    FREQUENCY = 263

    def __init__(self, input: TokenStream, output: TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.2")
        self._interp = ParserATNSimulator(
            self, self.atn, self.decisionsToDFA, self.sharedContextCache
        )
        self._predicates = None

    class StartContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(VtlParser.EOF, 0)

        def EOL(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.EOL)
            else:
                return self.getToken(VtlParser.EOL, i)

        def statement(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.StatementContext)
            else:
                return self.getTypedRuleContext(VtlParser.StatementContext, i)

        def ML_COMMENT(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.ML_COMMENT)
            else:
                return self.getToken(VtlParser.ML_COMMENT, i)

        def SL_COMMENT(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.SL_COMMENT)
            else:
                return self.getToken(VtlParser.SL_COMMENT, i)

        def getRuleIndex(self):
            return VtlParser.RULE_start

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStart"):
                listener.enterStart(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStart"):
                listener.exitStart(self)

    def start(self) -> StartContext:

        localctx = VtlParser.StartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_start)
        self._la = 0  # Token type
        try:
            self.state = 285
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 5, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 276
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 3, self._ctx)
                while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 259
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if (
                            (
                                ((_la) & ~0x3F) == 0
                                and (
                                    (1 << _la)
                                    & (
                                        (1 << VtlParser.T__2)
                                        | (1 << VtlParser.T__3)
                                        | (1 << VtlParser.T__12)
                                        | (1 << VtlParser.EVAL)
                                        | (1 << VtlParser.IF)
                                        | (1 << VtlParser.CASE)
                                        | (1 << VtlParser.CURRENT_DATE)
                                        | (1 << VtlParser.DATEDIFF)
                                        | (1 << VtlParser.DATEADD)
                                        | (1 << VtlParser.YEAR_OP)
                                        | (1 << VtlParser.MONTH_OP)
                                        | (1 << VtlParser.DAYOFMONTH)
                                        | (1 << VtlParser.DAYOFYEAR)
                                        | (1 << VtlParser.DAYTOYEAR)
                                        | (1 << VtlParser.DAYTOMONTH)
                                        | (1 << VtlParser.YEARTODAY)
                                        | (1 << VtlParser.MONTHTODAY)
                                        | (1 << VtlParser.NOT)
                                        | (1 << VtlParser.BETWEEN)
                                        | (1 << VtlParser.ISNULL)
                                        | (1 << VtlParser.UNION)
                                        | (1 << VtlParser.SYMDIFF)
                                        | (1 << VtlParser.INTERSECT)
                                        | (1 << VtlParser.RANDOM)
                                    )
                                )
                                != 0
                            )
                            or (
                                (((_la - 65)) & ~0x3F) == 0
                                and (
                                    (1 << (_la - 65))
                                    & (
                                        (1 << (VtlParser.CHECK - 65))
                                        | (1 << (VtlParser.EXISTS_IN - 65))
                                        | (1 << (VtlParser.RANK - 65))
                                        | (1 << (VtlParser.MIN - 65))
                                        | (1 << (VtlParser.MAX - 65))
                                        | (1 << (VtlParser.ABS - 65))
                                        | (1 << (VtlParser.LN - 65))
                                        | (1 << (VtlParser.LOG - 65))
                                        | (1 << (VtlParser.TRUNC - 65))
                                        | (1 << (VtlParser.ROUND - 65))
                                        | (1 << (VtlParser.POWER - 65))
                                        | (1 << (VtlParser.MOD - 65))
                                        | (1 << (VtlParser.LEN - 65))
                                        | (1 << (VtlParser.TRIM - 65))
                                        | (1 << (VtlParser.UCASE - 65))
                                        | (1 << (VtlParser.LCASE - 65))
                                        | (1 << (VtlParser.SUBSTR - 65))
                                        | (1 << (VtlParser.SUM - 65))
                                        | (1 << (VtlParser.AVG - 65))
                                        | (1 << (VtlParser.MEDIAN - 65))
                                        | (1 << (VtlParser.COUNT - 65))
                                        | (1 << (VtlParser.EXP - 65))
                                        | (1 << (VtlParser.CHARSET_MATCH - 65))
                                        | (1 << (VtlParser.NVL - 65))
                                        | (1 << (VtlParser.HIERARCHY - 65))
                                        | (1 << (VtlParser.DEFINE - 65))
                                    )
                                )
                                != 0
                            )
                            or (
                                (((_la - 130)) & ~0x3F) == 0
                                and (
                                    (1 << (_la - 130))
                                    & (
                                        (1 << (VtlParser.LTRIM - 130))
                                        | (1 << (VtlParser.RTRIM - 130))
                                        | (1 << (VtlParser.INSTR - 130))
                                        | (1 << (VtlParser.REPLACE - 130))
                                        | (1 << (VtlParser.CEIL - 130))
                                        | (1 << (VtlParser.FLOOR - 130))
                                        | (1 << (VtlParser.SQRT - 130))
                                        | (1 << (VtlParser.SETDIFF - 130))
                                        | (1 << (VtlParser.STDDEV_POP - 130))
                                        | (1 << (VtlParser.STDDEV_SAMP - 130))
                                        | (1 << (VtlParser.VAR_POP - 130))
                                        | (1 << (VtlParser.VAR_SAMP - 130))
                                        | (1 << (VtlParser.FIRST_VALUE - 130))
                                        | (1 << (VtlParser.LAST_VALUE - 130))
                                        | (1 << (VtlParser.LAG - 130))
                                        | (1 << (VtlParser.LEAD - 130))
                                        | (1 << (VtlParser.RATIO_TO_REPORT - 130))
                                        | (1 << (VtlParser.FILL_TIME_SERIES - 130))
                                        | (1 << (VtlParser.FLOW_TO_STOCK - 130))
                                        | (1 << (VtlParser.STOCK_TO_FLOW - 130))
                                        | (1 << (VtlParser.TIMESHIFT - 130))
                                        | (1 << (VtlParser.INNER_JOIN - 130))
                                        | (1 << (VtlParser.LEFT_JOIN - 130))
                                        | (1 << (VtlParser.CROSS_JOIN - 130))
                                    )
                                )
                                != 0
                            )
                            or (
                                (((_la - 194)) & ~0x3F) == 0
                                and (
                                    (1 << (_la - 194))
                                    & (
                                        (1 << (VtlParser.FULL_JOIN - 194))
                                        | (1 << (VtlParser.PERIOD_INDICATOR - 194))
                                        | (1 << (VtlParser.TIME_AGG - 194))
                                        | (1 << (VtlParser.CAST - 194))
                                        | (1 << (VtlParser.CHECK_DATAPOINT - 194))
                                        | (1 << (VtlParser.CHECK_HIERARCHY - 194))
                                        | (1 << (VtlParser.INTEGER_CONSTANT - 194))
                                        | (1 << (VtlParser.FLOAT_CONSTANT - 194))
                                        | (1 << (VtlParser.BOOLEAN_CONSTANT - 194))
                                        | (1 << (VtlParser.NULL_CONSTANT - 194))
                                        | (1 << (VtlParser.STRING_CONSTANT - 194))
                                        | (1 << (VtlParser.IDENTIFIER - 194))
                                    )
                                )
                                != 0
                            )
                        ):
                            self.state = 258
                            self.statement()

                        self.state = 264
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while _la == VtlParser.ML_COMMENT:
                            self.state = 261
                            self.match(VtlParser.ML_COMMENT)
                            self.state = 266
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)

                        self.state = 270
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while _la == VtlParser.SL_COMMENT:
                            self.state = 267
                            self.match(VtlParser.SL_COMMENT)
                            self.state = 272
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)

                        self.state = 273
                        self.match(VtlParser.EOL)
                    self.state = 278
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input, 3, self._ctx)

                self.state = 280
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (
                    (
                        ((_la) & ~0x3F) == 0
                        and (
                            (1 << _la)
                            & (
                                (1 << VtlParser.T__2)
                                | (1 << VtlParser.T__3)
                                | (1 << VtlParser.T__12)
                                | (1 << VtlParser.EVAL)
                                | (1 << VtlParser.IF)
                                | (1 << VtlParser.CASE)
                                | (1 << VtlParser.CURRENT_DATE)
                                | (1 << VtlParser.DATEDIFF)
                                | (1 << VtlParser.DATEADD)
                                | (1 << VtlParser.YEAR_OP)
                                | (1 << VtlParser.MONTH_OP)
                                | (1 << VtlParser.DAYOFMONTH)
                                | (1 << VtlParser.DAYOFYEAR)
                                | (1 << VtlParser.DAYTOYEAR)
                                | (1 << VtlParser.DAYTOMONTH)
                                | (1 << VtlParser.YEARTODAY)
                                | (1 << VtlParser.MONTHTODAY)
                                | (1 << VtlParser.NOT)
                                | (1 << VtlParser.BETWEEN)
                                | (1 << VtlParser.ISNULL)
                                | (1 << VtlParser.UNION)
                                | (1 << VtlParser.SYMDIFF)
                                | (1 << VtlParser.INTERSECT)
                                | (1 << VtlParser.RANDOM)
                            )
                        )
                        != 0
                    )
                    or (
                        (((_la - 65)) & ~0x3F) == 0
                        and (
                            (1 << (_la - 65))
                            & (
                                (1 << (VtlParser.CHECK - 65))
                                | (1 << (VtlParser.EXISTS_IN - 65))
                                | (1 << (VtlParser.RANK - 65))
                                | (1 << (VtlParser.MIN - 65))
                                | (1 << (VtlParser.MAX - 65))
                                | (1 << (VtlParser.ABS - 65))
                                | (1 << (VtlParser.LN - 65))
                                | (1 << (VtlParser.LOG - 65))
                                | (1 << (VtlParser.TRUNC - 65))
                                | (1 << (VtlParser.ROUND - 65))
                                | (1 << (VtlParser.POWER - 65))
                                | (1 << (VtlParser.MOD - 65))
                                | (1 << (VtlParser.LEN - 65))
                                | (1 << (VtlParser.TRIM - 65))
                                | (1 << (VtlParser.UCASE - 65))
                                | (1 << (VtlParser.LCASE - 65))
                                | (1 << (VtlParser.SUBSTR - 65))
                                | (1 << (VtlParser.SUM - 65))
                                | (1 << (VtlParser.AVG - 65))
                                | (1 << (VtlParser.MEDIAN - 65))
                                | (1 << (VtlParser.COUNT - 65))
                                | (1 << (VtlParser.EXP - 65))
                                | (1 << (VtlParser.CHARSET_MATCH - 65))
                                | (1 << (VtlParser.NVL - 65))
                                | (1 << (VtlParser.HIERARCHY - 65))
                                | (1 << (VtlParser.DEFINE - 65))
                            )
                        )
                        != 0
                    )
                    or (
                        (((_la - 130)) & ~0x3F) == 0
                        and (
                            (1 << (_la - 130))
                            & (
                                (1 << (VtlParser.LTRIM - 130))
                                | (1 << (VtlParser.RTRIM - 130))
                                | (1 << (VtlParser.INSTR - 130))
                                | (1 << (VtlParser.REPLACE - 130))
                                | (1 << (VtlParser.CEIL - 130))
                                | (1 << (VtlParser.FLOOR - 130))
                                | (1 << (VtlParser.SQRT - 130))
                                | (1 << (VtlParser.SETDIFF - 130))
                                | (1 << (VtlParser.STDDEV_POP - 130))
                                | (1 << (VtlParser.STDDEV_SAMP - 130))
                                | (1 << (VtlParser.VAR_POP - 130))
                                | (1 << (VtlParser.VAR_SAMP - 130))
                                | (1 << (VtlParser.FIRST_VALUE - 130))
                                | (1 << (VtlParser.LAST_VALUE - 130))
                                | (1 << (VtlParser.LAG - 130))
                                | (1 << (VtlParser.LEAD - 130))
                                | (1 << (VtlParser.RATIO_TO_REPORT - 130))
                                | (1 << (VtlParser.FILL_TIME_SERIES - 130))
                                | (1 << (VtlParser.FLOW_TO_STOCK - 130))
                                | (1 << (VtlParser.STOCK_TO_FLOW - 130))
                                | (1 << (VtlParser.TIMESHIFT - 130))
                                | (1 << (VtlParser.INNER_JOIN - 130))
                                | (1 << (VtlParser.LEFT_JOIN - 130))
                                | (1 << (VtlParser.CROSS_JOIN - 130))
                            )
                        )
                        != 0
                    )
                    or (
                        (((_la - 194)) & ~0x3F) == 0
                        and (
                            (1 << (_la - 194))
                            & (
                                (1 << (VtlParser.FULL_JOIN - 194))
                                | (1 << (VtlParser.PERIOD_INDICATOR - 194))
                                | (1 << (VtlParser.TIME_AGG - 194))
                                | (1 << (VtlParser.CAST - 194))
                                | (1 << (VtlParser.CHECK_DATAPOINT - 194))
                                | (1 << (VtlParser.CHECK_HIERARCHY - 194))
                                | (1 << (VtlParser.INTEGER_CONSTANT - 194))
                                | (1 << (VtlParser.FLOAT_CONSTANT - 194))
                                | (1 << (VtlParser.BOOLEAN_CONSTANT - 194))
                                | (1 << (VtlParser.NULL_CONSTANT - 194))
                                | (1 << (VtlParser.STRING_CONSTANT - 194))
                                | (1 << (VtlParser.IDENTIFIER - 194))
                            )
                        )
                        != 0
                    )
                ):
                    self.state = 279
                    self.statement()

                self.state = 282
                self.match(VtlParser.EOF)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 283
                self.match(VtlParser.ML_COMMENT)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 284
                self.match(VtlParser.SL_COMMENT)
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StatementContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def varID(self):
            return self.getTypedRuleContext(VtlParser.VarIDContext, 0)

        def ASSIGN(self):
            return self.getToken(VtlParser.ASSIGN, 0)

        def persistentAssignment(self):
            return self.getTypedRuleContext(VtlParser.PersistentAssignmentContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_statement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStatement"):
                listener.enterStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStatement"):
                listener.exitStatement(self)

    def statement(self):

        localctx = VtlParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_statement)
        try:
            self.state = 294
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 7, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 290
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 6, self._ctx)
                if la_ == 1:
                    self.state = 287
                    self.varID()
                    self.state = 288
                    self.match(VtlParser.ASSIGN)

                self.state = 292
                self.expr(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 293
                self.persistentAssignment()
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PersistentAssignmentContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def varID(self):
            return self.getTypedRuleContext(VtlParser.VarIDContext, 0)

        def PUT_SYMBOL(self):
            return self.getToken(VtlParser.PUT_SYMBOL, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_persistentAssignment

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPersistentAssignment"):
                listener.enterPersistentAssignment(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPersistentAssignment"):
                listener.exitPersistentAssignment(self)

    def persistentAssignment(self):

        localctx = VtlParser.PersistentAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_persistentAssignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 296
            self.varID()
            self.state = 297
            self.match(VtlParser.PUT_SYMBOL)
            self.state = 298
            self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OptionalExprContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def OPTIONAL(self):
            return self.getToken(VtlParser.OPTIONAL, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_optionalExpr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterOptionalExpr"):
                listener.enterOptionalExpr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitOptionalExpr"):
                listener.exitOptionalExpr(self)

    def optionalExpr(self):

        localctx = VtlParser.OptionalExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_optionalExpr)
        try:
            self.state = 302
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [
                VtlParser.T__2,
                VtlParser.T__3,
                VtlParser.T__12,
                VtlParser.EVAL,
                VtlParser.IF,
                VtlParser.CASE,
                VtlParser.CURRENT_DATE,
                VtlParser.DATEDIFF,
                VtlParser.DATEADD,
                VtlParser.YEAR_OP,
                VtlParser.MONTH_OP,
                VtlParser.DAYOFMONTH,
                VtlParser.DAYOFYEAR,
                VtlParser.DAYTOYEAR,
                VtlParser.DAYTOMONTH,
                VtlParser.YEARTODAY,
                VtlParser.MONTHTODAY,
                VtlParser.NOT,
                VtlParser.BETWEEN,
                VtlParser.ISNULL,
                VtlParser.UNION,
                VtlParser.SYMDIFF,
                VtlParser.INTERSECT,
                VtlParser.RANDOM,
                VtlParser.CHECK,
                VtlParser.EXISTS_IN,
                VtlParser.RANK,
                VtlParser.MIN,
                VtlParser.MAX,
                VtlParser.ABS,
                VtlParser.LN,
                VtlParser.LOG,
                VtlParser.TRUNC,
                VtlParser.ROUND,
                VtlParser.POWER,
                VtlParser.MOD,
                VtlParser.LEN,
                VtlParser.TRIM,
                VtlParser.UCASE,
                VtlParser.LCASE,
                VtlParser.SUBSTR,
                VtlParser.SUM,
                VtlParser.AVG,
                VtlParser.MEDIAN,
                VtlParser.COUNT,
                VtlParser.EXP,
                VtlParser.CHARSET_MATCH,
                VtlParser.NVL,
                VtlParser.HIERARCHY,
                VtlParser.DEFINE,
                VtlParser.LTRIM,
                VtlParser.RTRIM,
                VtlParser.INSTR,
                VtlParser.REPLACE,
                VtlParser.CEIL,
                VtlParser.FLOOR,
                VtlParser.SQRT,
                VtlParser.SETDIFF,
                VtlParser.STDDEV_POP,
                VtlParser.STDDEV_SAMP,
                VtlParser.VAR_POP,
                VtlParser.VAR_SAMP,
                VtlParser.FIRST_VALUE,
                VtlParser.LAST_VALUE,
                VtlParser.LAG,
                VtlParser.LEAD,
                VtlParser.RATIO_TO_REPORT,
                VtlParser.FILL_TIME_SERIES,
                VtlParser.FLOW_TO_STOCK,
                VtlParser.STOCK_TO_FLOW,
                VtlParser.TIMESHIFT,
                VtlParser.INNER_JOIN,
                VtlParser.LEFT_JOIN,
                VtlParser.CROSS_JOIN,
                VtlParser.FULL_JOIN,
                VtlParser.PERIOD_INDICATOR,
                VtlParser.TIME_AGG,
                VtlParser.CAST,
                VtlParser.CHECK_DATAPOINT,
                VtlParser.CHECK_HIERARCHY,
                VtlParser.INTEGER_CONSTANT,
                VtlParser.FLOAT_CONSTANT,
                VtlParser.BOOLEAN_CONSTANT,
                VtlParser.NULL_CONSTANT,
                VtlParser.STRING_CONSTANT,
                VtlParser.IDENTIFIER,
            ]:
                self.enterOuterAlt(localctx, 1)
                self.state = 300
                self.expr(0)
                pass
            elif token in [VtlParser.OPTIONAL]:
                self.enterOuterAlt(localctx, 2)
                self.state = 301
                self.match(VtlParser.OPTIONAL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExprContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def exprAtom(self):
            return self.getTypedRuleContext(VtlParser.ExprAtomContext, 0)

        def MEMBERSHIP(self):
            return self.getToken(VtlParser.MEMBERSHIP, 0)

        def componentID(self):
            return self.getTypedRuleContext(VtlParser.ComponentIDContext, 0)

        def datasetClause(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.DatasetClauseContext)
            else:
                return self.getTypedRuleContext(VtlParser.DatasetClauseContext, i)

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ExprContext)
            else:
                return self.getTypedRuleContext(VtlParser.ExprContext, i)

        def ASSIGN(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.ASSIGN)
            else:
                return self.getToken(VtlParser.ASSIGN, i)

        def NOT(self):
            return self.getToken(VtlParser.NOT, 0)

        def EXISTS_IN(self):
            return self.getToken(VtlParser.EXISTS_IN, 0)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def retainType(self):
            return self.getTypedRuleContext(VtlParser.RetainTypeContext, 0)

        def IF(self):
            return self.getToken(VtlParser.IF, 0)

        def THEN(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.THEN)
            else:
                return self.getToken(VtlParser.THEN, i)

        def ELSE(self):
            return self.getToken(VtlParser.ELSE, 0)

        def CASE(self):
            return self.getToken(VtlParser.CASE, 0)

        def WHEN(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.WHEN)
            else:
                return self.getToken(VtlParser.WHEN, i)

        def exprComplex(self):
            return self.getTypedRuleContext(VtlParser.ExprComplexContext, 0)

        def constant(self):
            return self.getTypedRuleContext(VtlParser.ConstantContext, 0)

        def IDENTIFIER(self):
            return self.getToken(VtlParser.IDENTIFIER, 0)

        def AND(self):
            return self.getToken(VtlParser.AND, 0)

        def OR(self):
            return self.getToken(VtlParser.OR, 0)

        def XOR(self):
            return self.getToken(VtlParser.XOR, 0)

        def CONCAT(self):
            return self.getToken(VtlParser.CONCAT, 0)

        def IN(self):
            return self.getToken(VtlParser.IN, 0)

        def NOT_IN(self):
            return self.getToken(VtlParser.NOT_IN, 0)

        def lists(self):
            return self.getTypedRuleContext(VtlParser.ListsContext, 0)

        def ALL(self):
            return self.getToken(VtlParser.ALL, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_expr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExpr"):
                listener.enterExpr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExpr"):
                listener.exitExpr(self)

    def expr(self, _p: int = 0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = VtlParser.ExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 8
        self.enterRecursionRule(localctx, 8, self.RULE_expr, _p)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 367
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 14, self._ctx)
            if la_ == 1:
                self.state = 305
                self.exprAtom()
                self.state = 318
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 10, self._ctx)
                while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 306
                        self.match(VtlParser.T__0)
                        self.state = 312
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [
                            VtlParser.DROP,
                            VtlParser.KEEP,
                            VtlParser.CALC,
                            VtlParser.RENAME,
                            VtlParser.AGGREGATE,
                            VtlParser.FILTER,
                            VtlParser.PIVOT,
                            VtlParser.UNPIVOT,
                            VtlParser.SUBSPACE,
                        ]:
                            self.state = 307
                            self.datasetClause()
                            pass
                        elif token in [
                            VtlParser.T__2,
                            VtlParser.T__3,
                            VtlParser.T__12,
                            VtlParser.EVAL,
                            VtlParser.IF,
                            VtlParser.CASE,
                            VtlParser.CURRENT_DATE,
                            VtlParser.DATEDIFF,
                            VtlParser.DATEADD,
                            VtlParser.YEAR_OP,
                            VtlParser.MONTH_OP,
                            VtlParser.DAYOFMONTH,
                            VtlParser.DAYOFYEAR,
                            VtlParser.DAYTOYEAR,
                            VtlParser.DAYTOMONTH,
                            VtlParser.YEARTODAY,
                            VtlParser.MONTHTODAY,
                            VtlParser.NOT,
                            VtlParser.BETWEEN,
                            VtlParser.ISNULL,
                            VtlParser.UNION,
                            VtlParser.SYMDIFF,
                            VtlParser.INTERSECT,
                            VtlParser.RANDOM,
                            VtlParser.CHECK,
                            VtlParser.EXISTS_IN,
                            VtlParser.RANK,
                            VtlParser.MIN,
                            VtlParser.MAX,
                            VtlParser.ABS,
                            VtlParser.LN,
                            VtlParser.LOG,
                            VtlParser.TRUNC,
                            VtlParser.ROUND,
                            VtlParser.POWER,
                            VtlParser.MOD,
                            VtlParser.LEN,
                            VtlParser.TRIM,
                            VtlParser.UCASE,
                            VtlParser.LCASE,
                            VtlParser.SUBSTR,
                            VtlParser.SUM,
                            VtlParser.AVG,
                            VtlParser.MEDIAN,
                            VtlParser.COUNT,
                            VtlParser.EXP,
                            VtlParser.CHARSET_MATCH,
                            VtlParser.NVL,
                            VtlParser.HIERARCHY,
                            VtlParser.DEFINE,
                            VtlParser.LTRIM,
                            VtlParser.RTRIM,
                            VtlParser.INSTR,
                            VtlParser.REPLACE,
                            VtlParser.CEIL,
                            VtlParser.FLOOR,
                            VtlParser.SQRT,
                            VtlParser.SETDIFF,
                            VtlParser.STDDEV_POP,
                            VtlParser.STDDEV_SAMP,
                            VtlParser.VAR_POP,
                            VtlParser.VAR_SAMP,
                            VtlParser.FIRST_VALUE,
                            VtlParser.LAST_VALUE,
                            VtlParser.LAG,
                            VtlParser.LEAD,
                            VtlParser.RATIO_TO_REPORT,
                            VtlParser.FILL_TIME_SERIES,
                            VtlParser.FLOW_TO_STOCK,
                            VtlParser.STOCK_TO_FLOW,
                            VtlParser.TIMESHIFT,
                            VtlParser.INNER_JOIN,
                            VtlParser.LEFT_JOIN,
                            VtlParser.CROSS_JOIN,
                            VtlParser.FULL_JOIN,
                            VtlParser.PERIOD_INDICATOR,
                            VtlParser.TIME_AGG,
                            VtlParser.CAST,
                            VtlParser.CHECK_DATAPOINT,
                            VtlParser.CHECK_HIERARCHY,
                            VtlParser.INTEGER_CONSTANT,
                            VtlParser.FLOAT_CONSTANT,
                            VtlParser.BOOLEAN_CONSTANT,
                            VtlParser.NULL_CONSTANT,
                            VtlParser.STRING_CONSTANT,
                            VtlParser.IDENTIFIER,
                        ]:
                            self.state = 308
                            self.expr(0)
                            self.state = 309
                            self.match(VtlParser.ASSIGN)
                            self.state = 310
                            self.expr(0)
                            pass
                        else:
                            raise NoViableAltException(self)

                        self.state = 314
                        self.match(VtlParser.T__1)
                    self.state = 320
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input, 10, self._ctx)

                self.state = 323
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 11, self._ctx)
                if la_ == 1:
                    self.state = 321
                    self.match(VtlParser.MEMBERSHIP)
                    self.state = 322
                    self.componentID()

                pass

            elif la_ == 2:
                self.state = 325
                _la = self._input.LA(1)
                if not (
                    (
                        ((_la) & ~0x3F) == 0
                        and (
                            (1 << _la)
                            & ((1 << VtlParser.T__2) | (1 << VtlParser.T__3) | (1 << VtlParser.NOT))
                        )
                        != 0
                    )
                ):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 326
                self.expr(17)
                pass

            elif la_ == 3:
                self.state = 327
                self.match(VtlParser.EXISTS_IN)
                self.state = 328
                self.match(VtlParser.T__12)
                self.state = 329
                self.expr(0)
                self.state = 330
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 331
                self.expr(0)
                self.state = 334
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == VtlParser.CARTESIAN_PER:
                    self.state = 332
                    self.match(VtlParser.CARTESIAN_PER)
                    self.state = 333
                    self.retainType()

                self.state = 336
                self.match(VtlParser.T__13)
                pass

            elif la_ == 4:
                self.state = 338
                self.match(VtlParser.IF)
                self.state = 339
                self.expr(0)
                self.state = 340
                self.match(VtlParser.THEN)
                self.state = 341
                self.expr(0)
                self.state = 342
                self.match(VtlParser.ELSE)
                self.state = 343
                self.expr(7)
                pass

            elif la_ == 5:
                self.state = 345
                self.match(VtlParser.CASE)
                self.state = 346
                self.match(VtlParser.WHEN)
                self.state = 347
                self.expr(0)
                self.state = 348
                self.match(VtlParser.THEN)
                self.state = 349
                self.expr(0)
                self.state = 357
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == VtlParser.WHEN:
                    self.state = 350
                    self.match(VtlParser.WHEN)
                    self.state = 351
                    self.expr(0)
                    self.state = 352
                    self.match(VtlParser.THEN)
                    self.state = 353
                    self.expr(0)
                    self.state = 359
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 360
                self.match(VtlParser.ELSE)
                self.state = 361
                self.expr(6)
                pass

            elif la_ == 6:
                self.state = 363
                self.exprComplex()
                pass

            elif la_ == 7:
                self.state = 364
                self.exprAtom()
                pass

            elif la_ == 8:
                self.state = 365
                self.constant()
                pass

            elif la_ == 9:
                self.state = 366
                self.match(VtlParser.IDENTIFIER)
                pass

            self._ctx.stop = self._input.LT(-1)
            self.state = 404
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 18, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 402
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input, 17, self._ctx)
                    if la_ == 1:
                        localctx = VtlParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 369
                        if not self.precpred(self._ctx, 16):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 16)")
                        self.state = 370
                        _la = self._input.LA(1)
                        if not (_la == VtlParser.T__4 or _la == VtlParser.T__5):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 371
                        self.expr(17)
                        pass

                    elif la_ == 2:
                        localctx = VtlParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 372
                        if not self.precpred(self._ctx, 15):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 15)")
                        self.state = 373
                        _la = self._input.LA(1)
                        if not (_la == VtlParser.T__2 or _la == VtlParser.T__3):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 374
                        self.expr(16)
                        pass

                    elif la_ == 3:
                        localctx = VtlParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 375
                        if not self.precpred(self._ctx, 14):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 14)")
                        self.state = 376
                        _la = self._input.LA(1)
                        if not (
                            (
                                ((_la) & ~0x3F) == 0
                                and (
                                    (1 << _la)
                                    & (
                                        (1 << VtlParser.T__6)
                                        | (1 << VtlParser.T__7)
                                        | (1 << VtlParser.T__8)
                                        | (1 << VtlParser.T__9)
                                        | (1 << VtlParser.T__10)
                                        | (1 << VtlParser.T__11)
                                    )
                                )
                                != 0
                            )
                        ):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 377
                        self.expr(15)
                        pass

                    elif la_ == 4:
                        localctx = VtlParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 378
                        if not self.precpred(self._ctx, 10):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 10)")
                        self.state = 379
                        _la = self._input.LA(1)
                        if not (_la == VtlParser.T__10 or _la == VtlParser.T__11):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 380
                        self.expr(11)
                        pass

                    elif la_ == 5:
                        localctx = VtlParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 381
                        if not self.precpred(self._ctx, 9):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
                        self.state = 382
                        self.match(VtlParser.AND)
                        self.state = 383
                        self.expr(10)
                        pass

                    elif la_ == 6:
                        localctx = VtlParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 384
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 385
                        _la = self._input.LA(1)
                        if not (_la == VtlParser.OR or _la == VtlParser.XOR):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 386
                        self.expr(9)
                        pass

                    elif la_ == 7:
                        localctx = VtlParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 387
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 388
                        self.match(VtlParser.CONCAT)
                        self.state = 389
                        self.expr(4)
                        pass

                    elif la_ == 8:
                        localctx = VtlParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 390
                        if not self.precpred(self._ctx, 13):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 13)")
                        self.state = 391
                        _la = self._input.LA(1)
                        if not (_la == VtlParser.IN or _la == VtlParser.NOT_IN):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 394
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [VtlParser.T__15]:
                            self.state = 392
                            self.lists()
                            pass
                        elif token in [VtlParser.IDENTIFIER]:
                            self.state = 393
                            self.match(VtlParser.IDENTIFIER)
                            pass
                        else:
                            raise NoViableAltException(self)

                        pass

                    elif la_ == 9:
                        localctx = VtlParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 396
                        if not self.precpred(self._ctx, 12):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 12)")
                        self.state = 397
                        self.match(VtlParser.EXISTS_IN)
                        self.state = 398
                        self.expr(0)
                        self.state = 400
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input, 16, self._ctx)
                        if la_ == 1:
                            self.state = 399
                            self.match(VtlParser.ALL)

                        pass

                self.state = 406
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 18, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class ExprComplexContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def getRuleIndex(self):
            return VtlParser.RULE_exprComplex

        def copyFrom(self, ctx: ParserRuleContext):
            super().copyFrom(ctx)

    class SimpleaggregateFunctionsContext(ExprComplexContext):

        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a VtlParser.ExprComplexContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def aggrFunction(self):
            return self.getTypedRuleContext(VtlParser.AggrFunctionContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSimpleaggregateFunctions"):
                listener.enterSimpleaggregateFunctions(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSimpleaggregateFunctions"):
                listener.exitSimpleaggregateFunctions(self)

    class StandaloneAggregateFunctionContext(ExprComplexContext):

        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a VtlParser.ExprComplexContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def aggrInvocation(self):
            return self.getTypedRuleContext(VtlParser.AggrInvocationContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStandaloneAggregateFunction"):
                listener.enterStandaloneAggregateFunction(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStandaloneAggregateFunction"):
                listener.exitStandaloneAggregateFunction(self)

    class DefinitionExpressionsContext(ExprComplexContext):

        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a VtlParser.ExprComplexContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def defExpr(self):
            return self.getTypedRuleContext(VtlParser.DefExprContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDefinitionExpressions"):
                listener.enterDefinitionExpressions(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDefinitionExpressions"):
                listener.exitDefinitionExpressions(self)

    class TimeexpressionsContext(ExprComplexContext):

        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a VtlParser.ExprComplexContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def timeExpr(self):
            return self.getTypedRuleContext(VtlParser.TimeExprContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTimeexpressions"):
                listener.enterTimeexpressions(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTimeexpressions"):
                listener.exitTimeexpressions(self)

    class RandExpressionsContext(ExprComplexContext):

        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a VtlParser.ExprComplexContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def randExpr(self):
            return self.getTypedRuleContext(VtlParser.RandExprContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRandExpressions"):
                listener.enterRandExpressions(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRandExpressions"):
                listener.exitRandExpressions(self)

    class JoinExpressionContext(ExprComplexContext):

        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a VtlParser.ExprComplexContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def joinExpr(self):
            return self.getTypedRuleContext(VtlParser.JoinExprContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterJoinExpression"):
                listener.enterJoinExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitJoinExpression"):
                listener.exitJoinExpression(self)

    class CallFunctionExpressionContext(ExprComplexContext):

        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a VtlParser.ExprComplexContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def callFunction(self):
            return self.getTypedRuleContext(VtlParser.CallFunctionContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCallFunctionExpression"):
                listener.enterCallFunctionExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCallFunctionExpression"):
                listener.exitCallFunctionExpression(self)

    class ExprValidationExprContext(ExprComplexContext):

        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a VtlParser.ExprComplexContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def validationExpr(self):
            return self.getTypedRuleContext(VtlParser.ValidationExprContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExprValidationExpr"):
                listener.enterExprValidationExpr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExprValidationExpr"):
                listener.exitExprValidationExpr(self)

    class StandaloneAnalyticFunctionContext(ExprComplexContext):

        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a VtlParser.ExprComplexContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def anFunctionClause(self):
            return self.getTypedRuleContext(VtlParser.AnFunctionClauseContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStandaloneAnalyticFunction"):
                listener.enterStandaloneAnalyticFunction(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStandaloneAnalyticFunction"):
                listener.exitStandaloneAnalyticFunction(self)

    class ComponentExpressionwithAggrClauseContext(ExprComplexContext):

        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a VtlParser.ExprComplexContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def aggrInvocationCompExpr(self):
            return self.getTypedRuleContext(VtlParser.AggrInvocationCompExprContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterComponentExpressionwithAggrClause"):
                listener.enterComponentExpressionwithAggrClause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitComponentExpressionwithAggrClause"):
                listener.exitComponentExpressionwithAggrClause(self)

    class SetExpressionsContext(ExprComplexContext):

        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a VtlParser.ExprComplexContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def setExpr(self):
            return self.getTypedRuleContext(VtlParser.SetExprContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSetExpressions"):
                listener.enterSetExpressions(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSetExpressions"):
                listener.exitSetExpressions(self)

    def exprComplex(self):

        localctx = VtlParser.ExprComplexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_exprComplex)
        try:
            self.state = 418
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 19, self._ctx)
            if la_ == 1:
                localctx = VtlParser.ExprValidationExprContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 407
                self.validationExpr()
                pass

            elif la_ == 2:
                localctx = VtlParser.DefinitionExpressionsContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 408
                self.defExpr()
                pass

            elif la_ == 3:
                localctx = VtlParser.StandaloneAggregateFunctionContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 409
                self.aggrInvocation()
                pass

            elif la_ == 4:
                localctx = VtlParser.ComponentExpressionwithAggrClauseContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 410
                self.aggrInvocationCompExpr()
                pass

            elif la_ == 5:
                localctx = VtlParser.StandaloneAnalyticFunctionContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 411
                self.anFunctionClause()
                pass

            elif la_ == 6:
                localctx = VtlParser.SimpleaggregateFunctionsContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 412
                self.aggrFunction()
                pass

            elif la_ == 7:
                localctx = VtlParser.TimeexpressionsContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 413
                self.timeExpr()
                pass

            elif la_ == 8:
                localctx = VtlParser.SetExpressionsContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 414
                self.setExpr()
                pass

            elif la_ == 9:
                localctx = VtlParser.RandExpressionsContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 415
                self.randExpr()
                pass

            elif la_ == 10:
                localctx = VtlParser.CallFunctionExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 10)
                self.state = 416
                self.callFunction()
                pass

            elif la_ == 11:
                localctx = VtlParser.JoinExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 11)
                self.state = 417
                self.joinExpr()
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TimeExprContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.opComp = None  # Token
            self.dateFrom = None  # ExprContext
            self.dateTo = None  # ExprContext
            self.op = None  # ExprContext
            self.shiftNumber = None  # ExprContext
            self.periodInd = None  # ExprContext

        def timeSeriesExpr(self):
            return self.getTypedRuleContext(VtlParser.TimeSeriesExprContext, 0)

        def periodExpr(self):
            return self.getTypedRuleContext(VtlParser.PeriodExprContext, 0)

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ExprContext)
            else:
                return self.getTypedRuleContext(VtlParser.ExprContext, i)

        def timeShiftExpr(self):
            return self.getTypedRuleContext(VtlParser.TimeShiftExprContext, 0)

        def timeAggExpr(self):
            return self.getTypedRuleContext(VtlParser.TimeAggExprContext, 0)

        def DATEDIFF(self):
            return self.getToken(VtlParser.DATEDIFF, 0)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def DATEADD(self):
            return self.getToken(VtlParser.DATEADD, 0)

        def YEAR_OP(self):
            return self.getToken(VtlParser.YEAR_OP, 0)

        def MONTH_OP(self):
            return self.getToken(VtlParser.MONTH_OP, 0)

        def DAYOFMONTH(self):
            return self.getToken(VtlParser.DAYOFMONTH, 0)

        def DAYOFYEAR(self):
            return self.getToken(VtlParser.DAYOFYEAR, 0)

        def DAYTOYEAR(self):
            return self.getToken(VtlParser.DAYTOYEAR, 0)

        def DAYTOMONTH(self):
            return self.getToken(VtlParser.DAYTOMONTH, 0)

        def YEARTODAY(self):
            return self.getToken(VtlParser.YEARTODAY, 0)

        def MONTHTODAY(self):
            return self.getToken(VtlParser.MONTHTODAY, 0)

        def CURRENT_DATE(self):
            return self.getToken(VtlParser.CURRENT_DATE, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_timeExpr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTimeExpr"):
                listener.enterTimeExpr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTimeExpr"):
                listener.exitTimeExpr(self)

    def timeExpr(self):

        localctx = VtlParser.TimeExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_timeExpr)
        self._la = 0  # Token type
        try:
            self.state = 485
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [VtlParser.FILL_TIME_SERIES]:
                self.enterOuterAlt(localctx, 1)
                self.state = 420
                self.timeSeriesExpr()
                pass
            elif token in [VtlParser.PERIOD_INDICATOR]:
                self.enterOuterAlt(localctx, 2)
                self.state = 421
                self.periodExpr()
                self.state = 424
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 20, self._ctx)
                if la_ == 1:
                    self.state = 422
                    localctx.opComp = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not (
                        (
                            ((_la) & ~0x3F) == 0
                            and (
                                (1 << _la)
                                & (
                                    (1 << VtlParser.T__6)
                                    | (1 << VtlParser.T__7)
                                    | (1 << VtlParser.T__8)
                                    | (1 << VtlParser.T__9)
                                    | (1 << VtlParser.T__10)
                                    | (1 << VtlParser.T__11)
                                )
                            )
                            != 0
                        )
                    ):
                        localctx.opComp = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 423
                    self.expr(0)

                pass
            elif token in [VtlParser.TIMESHIFT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 426
                self.timeShiftExpr()
                pass
            elif token in [VtlParser.TIME_AGG]:
                self.enterOuterAlt(localctx, 4)
                self.state = 427
                self.timeAggExpr()
                pass
            elif token in [VtlParser.DATEDIFF]:
                self.enterOuterAlt(localctx, 5)
                self.state = 428
                self.match(VtlParser.DATEDIFF)
                self.state = 429
                self.match(VtlParser.T__12)
                self.state = 430
                localctx.dateFrom = self.expr(0)
                self.state = 431
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 432
                localctx.dateTo = self.expr(0)
                self.state = 433
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.DATEADD]:
                self.enterOuterAlt(localctx, 6)
                self.state = 435
                self.match(VtlParser.DATEADD)
                self.state = 436
                self.match(VtlParser.T__12)
                self.state = 437
                localctx.op = self.expr(0)
                self.state = 438
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 439
                localctx.shiftNumber = self.expr(0)
                self.state = 440
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 441
                localctx.periodInd = self.expr(0)
                self.state = 442
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.YEAR_OP]:
                self.enterOuterAlt(localctx, 7)
                self.state = 444
                self.match(VtlParser.YEAR_OP)
                self.state = 445
                self.match(VtlParser.T__12)
                self.state = 446
                self.expr(0)
                self.state = 447
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.MONTH_OP]:
                self.enterOuterAlt(localctx, 8)
                self.state = 449
                self.match(VtlParser.MONTH_OP)
                self.state = 450
                self.match(VtlParser.T__12)
                self.state = 451
                self.expr(0)
                self.state = 452
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.DAYOFMONTH]:
                self.enterOuterAlt(localctx, 9)
                self.state = 454
                self.match(VtlParser.DAYOFMONTH)
                self.state = 455
                self.match(VtlParser.T__12)
                self.state = 456
                self.expr(0)
                self.state = 457
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.DAYOFYEAR]:
                self.enterOuterAlt(localctx, 10)
                self.state = 459
                self.match(VtlParser.DAYOFYEAR)
                self.state = 460
                self.match(VtlParser.T__12)
                self.state = 461
                self.expr(0)
                self.state = 462
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.DAYTOYEAR]:
                self.enterOuterAlt(localctx, 11)
                self.state = 464
                self.match(VtlParser.DAYTOYEAR)
                self.state = 465
                self.match(VtlParser.T__12)
                self.state = 466
                self.expr(0)
                self.state = 467
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.DAYTOMONTH]:
                self.enterOuterAlt(localctx, 12)
                self.state = 469
                self.match(VtlParser.DAYTOMONTH)
                self.state = 470
                self.match(VtlParser.T__12)
                self.state = 471
                self.expr(0)
                self.state = 472
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.YEARTODAY]:
                self.enterOuterAlt(localctx, 13)
                self.state = 474
                self.match(VtlParser.YEARTODAY)
                self.state = 475
                self.match(VtlParser.T__12)
                self.state = 476
                self.expr(0)
                self.state = 477
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.MONTHTODAY]:
                self.enterOuterAlt(localctx, 14)
                self.state = 479
                self.match(VtlParser.MONTHTODAY)
                self.state = 480
                self.match(VtlParser.T__12)
                self.state = 481
                self.expr(0)
                self.state = 482
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.CURRENT_DATE]:
                self.enterOuterAlt(localctx, 15)
                self.state = 484
                self.match(VtlParser.CURRENT_DATE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DefHierarchicalContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def defineHierarchicalRuleset(self):
            return self.getTypedRuleContext(VtlParser.DefineHierarchicalRulesetContext, 0)

        def rulesetID(self):
            return self.getTypedRuleContext(VtlParser.RulesetIDContext, 0)

        def hierRuleSignature(self):
            return self.getTypedRuleContext(VtlParser.HierRuleSignatureContext, 0)

        def IS(self):
            return self.getToken(VtlParser.IS, 0)

        def ruleClauseHierarchical(self):
            return self.getTypedRuleContext(VtlParser.RuleClauseHierarchicalContext, 0)

        def endHierarchicalRuleset(self):
            return self.getTypedRuleContext(VtlParser.EndHierarchicalRulesetContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_defHierarchical

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDefHierarchical"):
                listener.enterDefHierarchical(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDefHierarchical"):
                listener.exitDefHierarchical(self)

    def defHierarchical(self):

        localctx = VtlParser.DefHierarchicalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_defHierarchical)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 487
            self.defineHierarchicalRuleset()
            self.state = 488
            self.rulesetID()
            self.state = 489
            self.match(VtlParser.T__12)
            self.state = 490
            self.hierRuleSignature()
            self.state = 491
            self.match(VtlParser.T__13)
            self.state = 492
            self.match(VtlParser.IS)
            self.state = 493
            self.ruleClauseHierarchical()
            self.state = 494
            self.endHierarchicalRuleset()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RuleClauseHierarchicalContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleItemHierarchical(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.RuleItemHierarchicalContext)
            else:
                return self.getTypedRuleContext(VtlParser.RuleItemHierarchicalContext, i)

        def EOL(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.EOL)
            else:
                return self.getToken(VtlParser.EOL, i)

        def getRuleIndex(self):
            return VtlParser.RULE_ruleClauseHierarchical

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRuleClauseHierarchical"):
                listener.enterRuleClauseHierarchical(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRuleClauseHierarchical"):
                listener.exitRuleClauseHierarchical(self)

    def ruleClauseHierarchical(self):

        localctx = VtlParser.RuleClauseHierarchicalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_ruleClauseHierarchical)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 496
            self.ruleItemHierarchical()
            self.state = 501
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == VtlParser.EOL:
                self.state = 497
                self.match(VtlParser.EOL)
                self.state = 498
                self.ruleItemHierarchical()
                self.state = 503
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RuleItemHierarchicalContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def codeItemRelation(self):
            return self.getTypedRuleContext(VtlParser.CodeItemRelationContext, 0)

        def IDENTIFIER(self):
            return self.getToken(VtlParser.IDENTIFIER, 0)

        def erCode(self):
            return self.getTypedRuleContext(VtlParser.ErCodeContext, 0)

        def erLevel(self):
            return self.getTypedRuleContext(VtlParser.ErLevelContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_ruleItemHierarchical

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRuleItemHierarchical"):
                listener.enterRuleItemHierarchical(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRuleItemHierarchical"):
                listener.exitRuleItemHierarchical(self)

    def ruleItemHierarchical(self):

        localctx = VtlParser.RuleItemHierarchicalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_ruleItemHierarchical)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 506
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 23, self._ctx)
            if la_ == 1:
                self.state = 504
                self.match(VtlParser.IDENTIFIER)
                self.state = 505
                self.match(VtlParser.T__14)

            self.state = 508
            self.codeItemRelation()
            self.state = 510
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.ERRORCODE:
                self.state = 509
                self.erCode()

            self.state = 513
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.ERRORLEVEL:
                self.state = 512
                self.erLevel()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class HierRuleSignatureContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RULE(self):
            return self.getToken(VtlParser.RULE, 0)

        def IDENTIFIER(self):
            return self.getToken(VtlParser.IDENTIFIER, 0)

        def VALUE_DOMAIN(self):
            return self.getToken(VtlParser.VALUE_DOMAIN, 0)

        def VARIABLE(self):
            return self.getToken(VtlParser.VARIABLE, 0)

        def valueDomainSignature(self):
            return self.getTypedRuleContext(VtlParser.ValueDomainSignatureContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_hierRuleSignature

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterHierRuleSignature"):
                listener.enterHierRuleSignature(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitHierRuleSignature"):
                listener.exitHierRuleSignature(self)

    def hierRuleSignature(self):

        localctx = VtlParser.HierRuleSignatureContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_hierRuleSignature)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 515
            _la = self._input.LA(1)
            if not (_la == VtlParser.VALUE_DOMAIN or _la == VtlParser.VARIABLE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 517
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.CONDITION:
                self.state = 516
                self.valueDomainSignature()

            self.state = 519
            self.match(VtlParser.RULE)
            self.state = 520
            self.match(VtlParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ValueDomainSignatureContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONDITION(self):
            return self.getToken(VtlParser.CONDITION, 0)

        def IDENTIFIER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.IDENTIFIER)
            else:
                return self.getToken(VtlParser.IDENTIFIER, i)

        def AS(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.AS)
            else:
                return self.getToken(VtlParser.AS, i)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def getRuleIndex(self):
            return VtlParser.RULE_valueDomainSignature

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterValueDomainSignature"):
                listener.enterValueDomainSignature(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitValueDomainSignature"):
                listener.exitValueDomainSignature(self)

    def valueDomainSignature(self):

        localctx = VtlParser.ValueDomainSignatureContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_valueDomainSignature)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 522
            self.match(VtlParser.CONDITION)
            self.state = 523
            self.match(VtlParser.IDENTIFIER)
            self.state = 526
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.AS:
                self.state = 524
                self.match(VtlParser.AS)
                self.state = 525
                self.match(VtlParser.IDENTIFIER)

            self.state = 536
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == VtlParser.CARTESIAN_PER:
                self.state = 528
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 529
                self.match(VtlParser.IDENTIFIER)
                self.state = 532
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == VtlParser.AS:
                    self.state = 530
                    self.match(VtlParser.AS)
                    self.state = 531
                    self.match(VtlParser.IDENTIFIER)

                self.state = 538
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CodeItemRelationContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def codeItemRef(self):
            return self.getTypedRuleContext(VtlParser.CodeItemRefContext, 0)

        def codeItemRelationClause(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.CodeItemRelationClauseContext)
            else:
                return self.getTypedRuleContext(VtlParser.CodeItemRelationClauseContext, i)

        def WHEN(self):
            return self.getToken(VtlParser.WHEN, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def THEN(self):
            return self.getToken(VtlParser.THEN, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_codeItemRelation

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCodeItemRelation"):
                listener.enterCodeItemRelation(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCodeItemRelation"):
                listener.exitCodeItemRelation(self)

    def codeItemRelation(self):

        localctx = VtlParser.CodeItemRelationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_codeItemRelation)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 543
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.WHEN:
                self.state = 539
                self.match(VtlParser.WHEN)
                self.state = 540
                self.expr(0)
                self.state = 541
                self.match(VtlParser.THEN)

            self.state = 545
            self.codeItemRef()
            self.state = 546
            self.codeItemRelationClause()
            self.state = 550
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == VtlParser.T__2 or _la == VtlParser.T__3 or _la == VtlParser.IDENTIFIER:
                self.state = 547
                self.codeItemRelationClause()
                self.state = 552
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CodeItemRelationClauseContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.opAdd = None  # Token

        def IDENTIFIER(self):
            return self.getToken(VtlParser.IDENTIFIER, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_codeItemRelationClause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCodeItemRelationClause"):
                listener.enterCodeItemRelationClause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCodeItemRelationClause"):
                listener.exitCodeItemRelationClause(self)

    def codeItemRelationClause(self):

        localctx = VtlParser.CodeItemRelationClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_codeItemRelationClause)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 554
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.T__2 or _la == VtlParser.T__3:
                self.state = 553
                localctx.opAdd = self._input.LT(1)
                _la = self._input.LA(1)
                if not (_la == VtlParser.T__2 or _la == VtlParser.T__3):
                    localctx.opAdd = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()

            self.state = 556
            self.match(VtlParser.IDENTIFIER)
            self.state = 561
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.T__0:
                self.state = 557
                self.match(VtlParser.T__0)
                self.state = 558
                self.expr(0)
                self.state = 559
                self.match(VtlParser.T__1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CodeItemRefContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.opComp = None  # Token

        def IDENTIFIER(self):
            return self.getToken(VtlParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_codeItemRef

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCodeItemRef"):
                listener.enterCodeItemRef(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCodeItemRef"):
                listener.exitCodeItemRef(self)

    def codeItemRef(self):

        localctx = VtlParser.CodeItemRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_codeItemRef)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 563
            self.match(VtlParser.IDENTIFIER)
            self.state = 565
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((_la) & ~0x3F) == 0 and (
                (1 << _la)
                & (
                    (1 << VtlParser.T__6)
                    | (1 << VtlParser.T__7)
                    | (1 << VtlParser.T__8)
                    | (1 << VtlParser.T__9)
                    | (1 << VtlParser.T__10)
                )
            ) != 0:
                self.state = 564
                localctx.opComp = self._input.LT(1)
                _la = self._input.LA(1)
                if not (
                    (
                        ((_la) & ~0x3F) == 0
                        and (
                            (1 << _la)
                            & (
                                (1 << VtlParser.T__6)
                                | (1 << VtlParser.T__7)
                                | (1 << VtlParser.T__8)
                                | (1 << VtlParser.T__9)
                                | (1 << VtlParser.T__10)
                            )
                        )
                        != 0
                    )
                ):
                    localctx.opComp = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DefDatapointContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def defineDatapointRuleset(self):
            return self.getTypedRuleContext(VtlParser.DefineDatapointRulesetContext, 0)

        def rulesetID(self):
            return self.getTypedRuleContext(VtlParser.RulesetIDContext, 0)

        def rulesetSignature(self):
            return self.getTypedRuleContext(VtlParser.RulesetSignatureContext, 0)

        def IS(self):
            return self.getToken(VtlParser.IS, 0)

        def ruleClauseDatapoint(self):
            return self.getTypedRuleContext(VtlParser.RuleClauseDatapointContext, 0)

        def endDatapointRuleset(self):
            return self.getTypedRuleContext(VtlParser.EndDatapointRulesetContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_defDatapoint

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDefDatapoint"):
                listener.enterDefDatapoint(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDefDatapoint"):
                listener.exitDefDatapoint(self)

    def defDatapoint(self):

        localctx = VtlParser.DefDatapointContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_defDatapoint)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 567
            self.defineDatapointRuleset()
            self.state = 568
            self.rulesetID()
            self.state = 569
            self.match(VtlParser.T__12)
            self.state = 570
            self.rulesetSignature()
            self.state = 571
            self.match(VtlParser.T__13)
            self.state = 572
            self.match(VtlParser.IS)
            self.state = 573
            self.ruleClauseDatapoint()
            self.state = 574
            self.endDatapointRuleset()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RuleClauseDatapointContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleItemDatapoint(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.RuleItemDatapointContext)
            else:
                return self.getTypedRuleContext(VtlParser.RuleItemDatapointContext, i)

        def EOL(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.EOL)
            else:
                return self.getToken(VtlParser.EOL, i)

        def getRuleIndex(self):
            return VtlParser.RULE_ruleClauseDatapoint

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRuleClauseDatapoint"):
                listener.enterRuleClauseDatapoint(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRuleClauseDatapoint"):
                listener.exitRuleClauseDatapoint(self)

    def ruleClauseDatapoint(self):

        localctx = VtlParser.RuleClauseDatapointContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_ruleClauseDatapoint)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 576
            self.ruleItemDatapoint()
            self.state = 581
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == VtlParser.EOL:
                self.state = 577
                self.match(VtlParser.EOL)
                self.state = 578
                self.ruleItemDatapoint()
                self.state = 583
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RuleItemDatapointContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ExprContext)
            else:
                return self.getTypedRuleContext(VtlParser.ExprContext, i)

        def IDENTIFIER(self):
            return self.getToken(VtlParser.IDENTIFIER, 0)

        def WHEN(self):
            return self.getToken(VtlParser.WHEN, 0)

        def THEN(self):
            return self.getToken(VtlParser.THEN, 0)

        def erCode(self):
            return self.getTypedRuleContext(VtlParser.ErCodeContext, 0)

        def erLevel(self):
            return self.getTypedRuleContext(VtlParser.ErLevelContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_ruleItemDatapoint

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRuleItemDatapoint"):
                listener.enterRuleItemDatapoint(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRuleItemDatapoint"):
                listener.exitRuleItemDatapoint(self)

    def ruleItemDatapoint(self):

        localctx = VtlParser.RuleItemDatapointContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_ruleItemDatapoint)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 586
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 36, self._ctx)
            if la_ == 1:
                self.state = 584
                self.match(VtlParser.IDENTIFIER)
                self.state = 585
                self.match(VtlParser.T__14)

            self.state = 592
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.WHEN:
                self.state = 588
                self.match(VtlParser.WHEN)
                self.state = 589
                self.expr(0)
                self.state = 590
                self.match(VtlParser.THEN)

            self.state = 594
            self.expr(0)
            self.state = 596
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.ERRORCODE:
                self.state = 595
                self.erCode()

            self.state = 599
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.ERRORLEVEL:
                self.state = 598
                self.erLevel()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RulesetSignatureContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def varSignature(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.VarSignatureContext)
            else:
                return self.getTypedRuleContext(VtlParser.VarSignatureContext, i)

        def VALUE_DOMAIN(self):
            return self.getToken(VtlParser.VALUE_DOMAIN, 0)

        def VARIABLE(self):
            return self.getToken(VtlParser.VARIABLE, 0)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def getRuleIndex(self):
            return VtlParser.RULE_rulesetSignature

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRulesetSignature"):
                listener.enterRulesetSignature(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRulesetSignature"):
                listener.exitRulesetSignature(self)

    def rulesetSignature(self):

        localctx = VtlParser.RulesetSignatureContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_rulesetSignature)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 601
            _la = self._input.LA(1)
            if not (_la == VtlParser.VALUE_DOMAIN or _la == VtlParser.VARIABLE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 602
            self.varSignature()
            self.state = 607
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == VtlParser.CARTESIAN_PER:
                self.state = 603
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 604
                self.varSignature()
                self.state = 609
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VarSignatureContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def varID(self):
            return self.getTypedRuleContext(VtlParser.VarIDContext, 0)

        def AS(self):
            return self.getToken(VtlParser.AS, 0)

        def IDENTIFIER(self):
            return self.getToken(VtlParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_varSignature

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterVarSignature"):
                listener.enterVarSignature(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitVarSignature"):
                listener.exitVarSignature(self)

    def varSignature(self):

        localctx = VtlParser.VarSignatureContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_varSignature)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 610
            self.varID()
            self.state = 613
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.AS:
                self.state = 611
                self.match(VtlParser.AS)
                self.state = 612
                self.match(VtlParser.IDENTIFIER)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DefExprContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def defOperator(self):
            return self.getTypedRuleContext(VtlParser.DefOperatorContext, 0)

        def defDatapoint(self):
            return self.getTypedRuleContext(VtlParser.DefDatapointContext, 0)

        def defHierarchical(self):
            return self.getTypedRuleContext(VtlParser.DefHierarchicalContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_defExpr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDefExpr"):
                listener.enterDefExpr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDefExpr"):
                listener.exitDefExpr(self)

    def defExpr(self):

        localctx = VtlParser.DefExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_defExpr)
        try:
            self.state = 618
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 42, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 615
                self.defOperator()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 616
                self.defDatapoint()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 617
                self.defHierarchical()
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DefOperatorContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFINE(self):
            return self.getToken(VtlParser.DEFINE, 0)

        def OPERATOR(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.OPERATOR)
            else:
                return self.getToken(VtlParser.OPERATOR, i)

        def operatorID(self):
            return self.getTypedRuleContext(VtlParser.OperatorIDContext, 0)

        def IS(self):
            return self.getToken(VtlParser.IS, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def END(self):
            return self.getToken(VtlParser.END, 0)

        def parameterItem(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ParameterItemContext)
            else:
                return self.getTypedRuleContext(VtlParser.ParameterItemContext, i)

        def RETURNS(self):
            return self.getToken(VtlParser.RETURNS, 0)

        def dataType(self):
            return self.getTypedRuleContext(VtlParser.DataTypeContext, 0)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def getRuleIndex(self):
            return VtlParser.RULE_defOperator

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDefOperator"):
                listener.enterDefOperator(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDefOperator"):
                listener.exitDefOperator(self)

    def defOperator(self):

        localctx = VtlParser.DefOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_defOperator)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 620
            self.match(VtlParser.DEFINE)
            self.state = 621
            self.match(VtlParser.OPERATOR)
            self.state = 622
            self.operatorID()
            self.state = 623
            self.match(VtlParser.T__12)
            self.state = 632
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.IDENTIFIER:
                self.state = 624
                self.parameterItem()
                self.state = 629
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == VtlParser.CARTESIAN_PER:
                    self.state = 625
                    self.match(VtlParser.CARTESIAN_PER)
                    self.state = 626
                    self.parameterItem()
                    self.state = 631
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

            self.state = 634
            self.match(VtlParser.T__13)
            self.state = 637
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.RETURNS:
                self.state = 635
                self.match(VtlParser.RETURNS)
                self.state = 636
                self.dataType()

            self.state = 639
            self.match(VtlParser.IS)
            self.state = 640
            self.expr(0)
            self.state = 641
            self.match(VtlParser.END)
            self.state = 642
            self.match(VtlParser.OPERATOR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ParameterItemContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def varID(self):
            return self.getTypedRuleContext(VtlParser.VarIDContext, 0)

        def dataType(self):
            return self.getTypedRuleContext(VtlParser.DataTypeContext, 0)

        def DEFAULT(self):
            return self.getToken(VtlParser.DEFAULT, 0)

        def constant(self):
            return self.getTypedRuleContext(VtlParser.ConstantContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_parameterItem

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterParameterItem"):
                listener.enterParameterItem(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitParameterItem"):
                listener.exitParameterItem(self)

    def parameterItem(self):

        localctx = VtlParser.ParameterItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_parameterItem)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 644
            self.varID()
            self.state = 645
            self.dataType()
            self.state = 648
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.DEFAULT:
                self.state = 646
                self.match(VtlParser.DEFAULT)
                self.state = 647
                self.constant()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CallFunctionContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def operatorID(self):
            return self.getTypedRuleContext(VtlParser.OperatorIDContext, 0)

        def constant(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ConstantContext)
            else:
                return self.getTypedRuleContext(VtlParser.ConstantContext, i)

        def OPTIONAL(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.OPTIONAL)
            else:
                return self.getToken(VtlParser.OPTIONAL, i)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def getRuleIndex(self):
            return VtlParser.RULE_callFunction

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCallFunction"):
                listener.enterCallFunction(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCallFunction"):
                listener.exitCallFunction(self)

    def callFunction(self):

        localctx = VtlParser.CallFunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_callFunction)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 650
            self.operatorID()
            self.state = 651
            self.match(VtlParser.T__12)
            self.state = 666
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.OPTIONAL or (
                (((_la - 238)) & ~0x3F) == 0
                and (
                    (1 << (_la - 238))
                    & (
                        (1 << (VtlParser.INTEGER_CONSTANT - 238))
                        | (1 << (VtlParser.FLOAT_CONSTANT - 238))
                        | (1 << (VtlParser.BOOLEAN_CONSTANT - 238))
                        | (1 << (VtlParser.NULL_CONSTANT - 238))
                        | (1 << (VtlParser.STRING_CONSTANT - 238))
                    )
                )
                != 0
            ):
                self.state = 654
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [
                    VtlParser.INTEGER_CONSTANT,
                    VtlParser.FLOAT_CONSTANT,
                    VtlParser.BOOLEAN_CONSTANT,
                    VtlParser.NULL_CONSTANT,
                    VtlParser.STRING_CONSTANT,
                ]:
                    self.state = 652
                    self.constant()
                    pass
                elif token in [VtlParser.OPTIONAL]:
                    self.state = 653
                    self.match(VtlParser.OPTIONAL)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 663
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == VtlParser.CARTESIAN_PER:
                    self.state = 656
                    self.match(VtlParser.CARTESIAN_PER)
                    self.state = 659
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [
                        VtlParser.INTEGER_CONSTANT,
                        VtlParser.FLOAT_CONSTANT,
                        VtlParser.BOOLEAN_CONSTANT,
                        VtlParser.NULL_CONSTANT,
                        VtlParser.STRING_CONSTANT,
                    ]:
                        self.state = 657
                        self.constant()
                        pass
                    elif token in [VtlParser.OPTIONAL]:
                        self.state = 658
                        self.match(VtlParser.OPTIONAL)
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 665
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

            self.state = 668
            self.match(VtlParser.T__13)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExprAtomContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def getRuleIndex(self):
            return VtlParser.RULE_exprAtom

        def copyFrom(self, ctx: ParserRuleContext):
            super().copyFrom(ctx)

    class SqrtAtomContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SQRT(self):
            return self.getToken(VtlParser.SQRT, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSqrtAtom"):
                listener.enterSqrtAtom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSqrtAtom"):
                listener.exitSqrtAtom(self)

    class LtrimAtomContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LTRIM(self):
            return self.getToken(VtlParser.LTRIM, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLtrimAtom"):
                listener.enterLtrimAtom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLtrimAtom"):
                listener.exitLtrimAtom(self)

    class StockToFlowAtomContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def STOCK_TO_FLOW(self):
            return self.getToken(VtlParser.STOCK_TO_FLOW, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStockToFlowAtom"):
                listener.enterStockToFlowAtom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStockToFlowAtom"):
                listener.exitStockToFlowAtom(self)

    class TrimAtomContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TRIM(self):
            return self.getToken(VtlParser.TRIM, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTrimAtom"):
                listener.enterTrimAtom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTrimAtom"):
                listener.exitTrimAtom(self)

    class ValidateDPrulesetContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def validationDatapoint(self):
            return self.getTypedRuleContext(VtlParser.ValidationDatapointContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterValidateDPruleset"):
                listener.enterValidateDPruleset(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitValidateDPruleset"):
                listener.exitValidateDPruleset(self)

    class InstrAtomContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def INSTR(self):
            return self.getToken(VtlParser.INSTR, 0)

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ExprContext)
            else:
                return self.getTypedRuleContext(VtlParser.ExprContext, i)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def optionalExpr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.OptionalExprContext)
            else:
                return self.getTypedRuleContext(VtlParser.OptionalExprContext, i)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInstrAtom"):
                listener.enterInstrAtom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInstrAtom"):
                listener.exitInstrAtom(self)

    class CharsetMatchAtomContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CHARSET_MATCH(self):
            return self.getToken(VtlParser.CHARSET_MATCH, 0)

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ExprContext)
            else:
                return self.getTypedRuleContext(VtlParser.ExprContext, i)

        def CARTESIAN_PER(self):
            return self.getToken(VtlParser.CARTESIAN_PER, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCharsetMatchAtom"):
                listener.enterCharsetMatchAtom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCharsetMatchAtom"):
                listener.exitCharsetMatchAtom(self)

    class LnAtomContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LN(self):
            return self.getToken(VtlParser.LN, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def TRUNC(self):
            return self.getToken(VtlParser.TRUNC, 0)

        def CARTESIAN_PER(self):
            return self.getToken(VtlParser.CARTESIAN_PER, 0)

        def optionalExpr(self):
            return self.getTypedRuleContext(VtlParser.OptionalExprContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLnAtom"):
                listener.enterLnAtom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLnAtom"):
                listener.exitLnAtom(self)

    class ValidationSimpleContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def validationExpr(self):
            return self.getTypedRuleContext(VtlParser.ValidationExprContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterValidationSimple"):
                listener.enterValidationSimple(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitValidationSimple"):
                listener.exitValidationSimple(self)

    class IsNullAtomContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ISNULL(self):
            return self.getToken(VtlParser.ISNULL, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterIsNullAtom"):
                listener.enterIsNullAtom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitIsNullAtom"):
                listener.exitIsNullAtom(self)

    class NvlAtomContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NVL(self):
            return self.getToken(VtlParser.NVL, 0)

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ExprContext)
            else:
                return self.getTypedRuleContext(VtlParser.ExprContext, i)

        def CARTESIAN_PER(self):
            return self.getToken(VtlParser.CARTESIAN_PER, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterNvlAtom"):
                listener.enterNvlAtom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitNvlAtom"):
                listener.exitNvlAtom(self)

    class CeilAtomContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CEIL(self):
            return self.getToken(VtlParser.CEIL, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCeilAtom"):
                listener.enterCeilAtom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCeilAtom"):
                listener.exitCeilAtom(self)

    class RtrimAtomContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def RTRIM(self):
            return self.getToken(VtlParser.RTRIM, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRtrimAtom"):
                listener.enterRtrimAtom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRtrimAtom"):
                listener.exitRtrimAtom(self)

    class RoundAtomContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ROUND(self):
            return self.getToken(VtlParser.ROUND, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def CARTESIAN_PER(self):
            return self.getToken(VtlParser.CARTESIAN_PER, 0)

        def optionalExpr(self):
            return self.getTypedRuleContext(VtlParser.OptionalExprContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRoundAtom"):
                listener.enterRoundAtom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRoundAtom"):
                listener.exitRoundAtom(self)

    class UcaseAtomContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def UCASE(self):
            return self.getToken(VtlParser.UCASE, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUcaseAtom"):
                listener.enterUcaseAtom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUcaseAtom"):
                listener.exitUcaseAtom(self)

    class LcaseAtomContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LCASE(self):
            return self.getToken(VtlParser.LCASE, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLcaseAtom"):
                listener.enterLcaseAtom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLcaseAtom"):
                listener.exitLcaseAtom(self)

    class HierarchyExprAtomContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def hierarchyExpr(self):
            return self.getTypedRuleContext(VtlParser.HierarchyExprContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterHierarchyExprAtom"):
                listener.enterHierarchyExprAtom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitHierarchyExprAtom"):
                listener.exitHierarchyExprAtom(self)

    class RefAtomContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ref(self):
            return self.getTypedRuleContext(VtlParser.RefContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRefAtom"):
                listener.enterRefAtom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRefAtom"):
                listener.exitRefAtom(self)

    class FloorAtomContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def FLOOR(self):
            return self.getToken(VtlParser.FLOOR, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFloorAtom"):
                listener.enterFloorAtom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFloorAtom"):
                listener.exitFloorAtom(self)

    class SubstrAtomContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SUBSTR(self):
            return self.getToken(VtlParser.SUBSTR, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def optionalExpr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.OptionalExprContext)
            else:
                return self.getTypedRuleContext(VtlParser.OptionalExprContext, i)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSubstrAtom"):
                listener.enterSubstrAtom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSubstrAtom"):
                listener.exitSubstrAtom(self)

    class LogAtomContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LOG(self):
            return self.getToken(VtlParser.LOG, 0)

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ExprContext)
            else:
                return self.getTypedRuleContext(VtlParser.ExprContext, i)

        def CARTESIAN_PER(self):
            return self.getToken(VtlParser.CARTESIAN_PER, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLogAtom"):
                listener.enterLogAtom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLogAtom"):
                listener.exitLogAtom(self)

    class PowerAtomContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def POWER(self):
            return self.getToken(VtlParser.POWER, 0)

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ExprContext)
            else:
                return self.getTypedRuleContext(VtlParser.ExprContext, i)

        def CARTESIAN_PER(self):
            return self.getToken(VtlParser.CARTESIAN_PER, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPowerAtom"):
                listener.enterPowerAtom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPowerAtom"):
                listener.exitPowerAtom(self)

    class LenAtomContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LEN(self):
            return self.getToken(VtlParser.LEN, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLenAtom"):
                listener.enterLenAtom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLenAtom"):
                listener.exitLenAtom(self)

    class MinAtomContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ABS(self):
            return self.getToken(VtlParser.ABS, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMinAtom"):
                listener.enterMinAtom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMinAtom"):
                listener.exitMinAtom(self)

    class ModAtomContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def MOD(self):
            return self.getToken(VtlParser.MOD, 0)

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ExprContext)
            else:
                return self.getTypedRuleContext(VtlParser.ExprContext, i)

        def CARTESIAN_PER(self):
            return self.getToken(VtlParser.CARTESIAN_PER, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterModAtom"):
                listener.enterModAtom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitModAtom"):
                listener.exitModAtom(self)

    class ValidateHRrulesetContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def validationHierarchical(self):
            return self.getTypedRuleContext(VtlParser.ValidationHierarchicalContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterValidateHRruleset"):
                listener.enterValidateHRruleset(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitValidateHRruleset"):
                listener.exitValidateHRruleset(self)

    class BetweenAtomContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def BETWEEN(self):
            return self.getToken(VtlParser.BETWEEN, 0)

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ExprContext)
            else:
                return self.getTypedRuleContext(VtlParser.ExprContext, i)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterBetweenAtom"):
                listener.enterBetweenAtom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitBetweenAtom"):
                listener.exitBetweenAtom(self)

    class ExpAtomContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def EXP(self):
            return self.getToken(VtlParser.EXP, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExpAtom"):
                listener.enterExpAtom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExpAtom"):
                listener.exitExpAtom(self)

    class EvalExprAtomContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def evalExpr(self):
            return self.getTypedRuleContext(VtlParser.EvalExprContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEvalExprAtom"):
                listener.enterEvalExprAtom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEvalExprAtom"):
                listener.exitEvalExprAtom(self)

    class CastExprAtomContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def castExpr(self):
            return self.getTypedRuleContext(VtlParser.CastExprContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCastExprAtom"):
                listener.enterCastExprAtom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCastExprAtom"):
                listener.exitCastExprAtom(self)

    class FlowToStockAtomContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def FLOW_TO_STOCK(self):
            return self.getToken(VtlParser.FLOW_TO_STOCK, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFlowToStockAtom"):
                listener.enterFlowToStockAtom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFlowToStockAtom"):
                listener.exitFlowToStockAtom(self)

    class ReplaceAtomContext(ExprAtomContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.ExprAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def REPLACE(self):
            return self.getToken(VtlParser.REPLACE, 0)

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ExprContext)
            else:
                return self.getTypedRuleContext(VtlParser.ExprContext, i)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def optionalExpr(self):
            return self.getTypedRuleContext(VtlParser.OptionalExprContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterReplaceAtom"):
                listener.enterReplaceAtom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitReplaceAtom"):
                listener.exitReplaceAtom(self)

    def exprAtom(self):

        localctx = VtlParser.ExprAtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_exprAtom)
        self._la = 0  # Token type
        try:
            self.state = 853
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [VtlParser.ROUND]:
                localctx = VtlParser.RoundAtomContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 670
                self.match(VtlParser.ROUND)
                self.state = 671
                self.match(VtlParser.T__12)
                self.state = 672
                self.expr(0)
                self.state = 675
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == VtlParser.CARTESIAN_PER:
                    self.state = 673
                    self.match(VtlParser.CARTESIAN_PER)
                    self.state = 674
                    self.optionalExpr()

                self.state = 677
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.CEIL]:
                localctx = VtlParser.CeilAtomContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 679
                self.match(VtlParser.CEIL)
                self.state = 680
                self.match(VtlParser.T__12)
                self.state = 681
                self.expr(0)
                self.state = 682
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.FLOOR]:
                localctx = VtlParser.FloorAtomContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 684
                self.match(VtlParser.FLOOR)
                self.state = 685
                self.match(VtlParser.T__12)
                self.state = 686
                self.expr(0)
                self.state = 687
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.ABS]:
                localctx = VtlParser.MinAtomContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 689
                self.match(VtlParser.ABS)
                self.state = 690
                self.match(VtlParser.T__12)
                self.state = 691
                self.expr(0)
                self.state = 692
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.EXP]:
                localctx = VtlParser.ExpAtomContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 694
                self.match(VtlParser.EXP)
                self.state = 695
                self.match(VtlParser.T__12)
                self.state = 696
                self.expr(0)
                self.state = 697
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.LN]:
                localctx = VtlParser.LnAtomContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 699
                self.match(VtlParser.LN)
                self.state = 700
                self.match(VtlParser.T__12)
                self.state = 701
                self.expr(0)
                self.state = 702
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.LOG]:
                localctx = VtlParser.LogAtomContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 704
                self.match(VtlParser.LOG)
                self.state = 705
                self.match(VtlParser.T__12)
                self.state = 706
                self.expr(0)
                self.state = 707
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 708
                self.expr(0)
                self.state = 709
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.TRUNC]:
                localctx = VtlParser.LnAtomContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 711
                self.match(VtlParser.TRUNC)
                self.state = 712
                self.match(VtlParser.T__12)
                self.state = 713
                self.expr(0)
                self.state = 716
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == VtlParser.CARTESIAN_PER:
                    self.state = 714
                    self.match(VtlParser.CARTESIAN_PER)
                    self.state = 715
                    self.optionalExpr()

                self.state = 718
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.POWER]:
                localctx = VtlParser.PowerAtomContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 720
                self.match(VtlParser.POWER)
                self.state = 721
                self.match(VtlParser.T__12)
                self.state = 722
                self.expr(0)
                self.state = 723
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 724
                self.expr(0)
                self.state = 725
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.SQRT]:
                localctx = VtlParser.SqrtAtomContext(self, localctx)
                self.enterOuterAlt(localctx, 10)
                self.state = 727
                self.match(VtlParser.SQRT)
                self.state = 728
                self.match(VtlParser.T__12)
                self.state = 729
                self.expr(0)
                self.state = 730
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.LEN]:
                localctx = VtlParser.LenAtomContext(self, localctx)
                self.enterOuterAlt(localctx, 11)
                self.state = 732
                self.match(VtlParser.LEN)
                self.state = 733
                self.match(VtlParser.T__12)
                self.state = 734
                self.expr(0)
                self.state = 735
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.BETWEEN]:
                localctx = VtlParser.BetweenAtomContext(self, localctx)
                self.enterOuterAlt(localctx, 12)
                self.state = 737
                self.match(VtlParser.BETWEEN)
                self.state = 738
                self.match(VtlParser.T__12)
                self.state = 739
                self.expr(0)
                self.state = 740
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 741
                self.expr(0)
                self.state = 742
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 743
                self.expr(0)
                self.state = 744
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.TRIM]:
                localctx = VtlParser.TrimAtomContext(self, localctx)
                self.enterOuterAlt(localctx, 13)
                self.state = 746
                self.match(VtlParser.TRIM)
                self.state = 747
                self.match(VtlParser.T__12)
                self.state = 748
                self.expr(0)
                self.state = 749
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.LTRIM]:
                localctx = VtlParser.LtrimAtomContext(self, localctx)
                self.enterOuterAlt(localctx, 14)
                self.state = 751
                self.match(VtlParser.LTRIM)
                self.state = 752
                self.match(VtlParser.T__12)
                self.state = 753
                self.expr(0)
                self.state = 754
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.RTRIM]:
                localctx = VtlParser.RtrimAtomContext(self, localctx)
                self.enterOuterAlt(localctx, 15)
                self.state = 756
                self.match(VtlParser.RTRIM)
                self.state = 757
                self.match(VtlParser.T__12)
                self.state = 758
                self.expr(0)
                self.state = 759
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.UCASE]:
                localctx = VtlParser.UcaseAtomContext(self, localctx)
                self.enterOuterAlt(localctx, 16)
                self.state = 761
                self.match(VtlParser.UCASE)
                self.state = 762
                self.match(VtlParser.T__12)
                self.state = 763
                self.expr(0)
                self.state = 764
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.LCASE]:
                localctx = VtlParser.LcaseAtomContext(self, localctx)
                self.enterOuterAlt(localctx, 17)
                self.state = 766
                self.match(VtlParser.LCASE)
                self.state = 767
                self.match(VtlParser.T__12)
                self.state = 768
                self.expr(0)
                self.state = 769
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.SUBSTR]:
                localctx = VtlParser.SubstrAtomContext(self, localctx)
                self.enterOuterAlt(localctx, 18)
                self.state = 771
                self.match(VtlParser.SUBSTR)
                self.state = 772
                self.match(VtlParser.T__12)
                self.state = 773
                self.expr(0)
                self.state = 776
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 53, self._ctx)
                if la_ == 1:
                    self.state = 774
                    self.match(VtlParser.CARTESIAN_PER)
                    self.state = 775
                    self.optionalExpr()

                self.state = 780
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == VtlParser.CARTESIAN_PER:
                    self.state = 778
                    self.match(VtlParser.CARTESIAN_PER)
                    self.state = 779
                    self.optionalExpr()

                self.state = 782
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.INSTR]:
                localctx = VtlParser.InstrAtomContext(self, localctx)
                self.enterOuterAlt(localctx, 19)
                self.state = 784
                self.match(VtlParser.INSTR)
                self.state = 785
                self.match(VtlParser.T__12)
                self.state = 786
                self.expr(0)
                self.state = 787
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 788
                self.expr(0)
                self.state = 791
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 55, self._ctx)
                if la_ == 1:
                    self.state = 789
                    self.match(VtlParser.CARTESIAN_PER)
                    self.state = 790
                    self.optionalExpr()

                self.state = 795
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == VtlParser.CARTESIAN_PER:
                    self.state = 793
                    self.match(VtlParser.CARTESIAN_PER)
                    self.state = 794
                    self.optionalExpr()

                self.state = 797
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.REPLACE]:
                localctx = VtlParser.ReplaceAtomContext(self, localctx)
                self.enterOuterAlt(localctx, 20)
                self.state = 799
                self.match(VtlParser.REPLACE)
                self.state = 800
                self.match(VtlParser.T__12)
                self.state = 801
                self.expr(0)
                self.state = 802
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 803
                self.expr(0)
                self.state = 806
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == VtlParser.CARTESIAN_PER:
                    self.state = 804
                    self.match(VtlParser.CARTESIAN_PER)
                    self.state = 805
                    self.optionalExpr()

                self.state = 808
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.CHARSET_MATCH]:
                localctx = VtlParser.CharsetMatchAtomContext(self, localctx)
                self.enterOuterAlt(localctx, 21)
                self.state = 810
                self.match(VtlParser.CHARSET_MATCH)
                self.state = 811
                self.match(VtlParser.T__12)
                self.state = 812
                self.expr(0)
                self.state = 813
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 814
                self.expr(0)
                self.state = 815
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.ISNULL]:
                localctx = VtlParser.IsNullAtomContext(self, localctx)
                self.enterOuterAlt(localctx, 22)
                self.state = 817
                self.match(VtlParser.ISNULL)
                self.state = 818
                self.match(VtlParser.T__12)
                self.state = 819
                self.expr(0)
                self.state = 820
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.NVL]:
                localctx = VtlParser.NvlAtomContext(self, localctx)
                self.enterOuterAlt(localctx, 23)
                self.state = 822
                self.match(VtlParser.NVL)
                self.state = 823
                self.match(VtlParser.T__12)
                self.state = 824
                self.expr(0)
                self.state = 825
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 826
                self.expr(0)
                self.state = 827
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.MOD]:
                localctx = VtlParser.ModAtomContext(self, localctx)
                self.enterOuterAlt(localctx, 24)
                self.state = 829
                self.match(VtlParser.MOD)
                self.state = 830
                self.match(VtlParser.T__12)
                self.state = 831
                self.expr(0)
                self.state = 832
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 833
                self.expr(0)
                self.state = 834
                self.match(VtlParser.T__13)
                pass
            elif token in [
                VtlParser.T__12,
                VtlParser.INTEGER_CONSTANT,
                VtlParser.FLOAT_CONSTANT,
                VtlParser.BOOLEAN_CONSTANT,
                VtlParser.NULL_CONSTANT,
                VtlParser.STRING_CONSTANT,
                VtlParser.IDENTIFIER,
            ]:
                localctx = VtlParser.RefAtomContext(self, localctx)
                self.enterOuterAlt(localctx, 25)
                self.state = 836
                self.ref()
                pass
            elif token in [VtlParser.EVAL]:
                localctx = VtlParser.EvalExprAtomContext(self, localctx)
                self.enterOuterAlt(localctx, 26)
                self.state = 837
                self.evalExpr()
                pass
            elif token in [VtlParser.CAST]:
                localctx = VtlParser.CastExprAtomContext(self, localctx)
                self.enterOuterAlt(localctx, 27)
                self.state = 838
                self.castExpr()
                pass
            elif token in [VtlParser.HIERARCHY]:
                localctx = VtlParser.HierarchyExprAtomContext(self, localctx)
                self.enterOuterAlt(localctx, 28)
                self.state = 839
                self.hierarchyExpr()
                pass
            elif token in [VtlParser.FLOW_TO_STOCK]:
                localctx = VtlParser.FlowToStockAtomContext(self, localctx)
                self.enterOuterAlt(localctx, 29)
                self.state = 840
                self.match(VtlParser.FLOW_TO_STOCK)
                self.state = 841
                self.match(VtlParser.T__12)
                self.state = 842
                self.expr(0)
                self.state = 843
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.STOCK_TO_FLOW]:
                localctx = VtlParser.StockToFlowAtomContext(self, localctx)
                self.enterOuterAlt(localctx, 30)
                self.state = 845
                self.match(VtlParser.STOCK_TO_FLOW)
                self.state = 846
                self.match(VtlParser.T__12)
                self.state = 847
                self.expr(0)
                self.state = 848
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.CHECK_DATAPOINT]:
                localctx = VtlParser.ValidateDPrulesetContext(self, localctx)
                self.enterOuterAlt(localctx, 31)
                self.state = 850
                self.validationDatapoint()
                pass
            elif token in [VtlParser.CHECK_HIERARCHY]:
                localctx = VtlParser.ValidateHRrulesetContext(self, localctx)
                self.enterOuterAlt(localctx, 32)
                self.state = 851
                self.validationHierarchical()
                pass
            elif token in [VtlParser.CHECK]:
                localctx = VtlParser.ValidationSimpleContext(self, localctx)
                self.enterOuterAlt(localctx, 33)
                self.state = 852
                self.validationExpr()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RefContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def getRuleIndex(self):
            return VtlParser.RULE_ref

        def copyFrom(self, ctx: ParserRuleContext):
            super().copyFrom(ctx)

    class VarIdRefContext(RefContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.RefContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def varID(self):
            return self.getTypedRuleContext(VtlParser.VarIDContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterVarIdRef"):
                listener.enterVarIdRef(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitVarIdRef"):
                listener.exitVarIdRef(self)

    class ParenthesisExprRefContext(RefContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.RefContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterParenthesisExprRef"):
                listener.enterParenthesisExprRef(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitParenthesisExprRef"):
                listener.exitParenthesisExprRef(self)

    class ConstantRefContext(RefContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a VtlParser.RefContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def constant(self):
            return self.getTypedRuleContext(VtlParser.ConstantContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConstantRef"):
                listener.enterConstantRef(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConstantRef"):
                listener.exitConstantRef(self)

    def ref(self):

        localctx = VtlParser.RefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_ref)
        try:
            self.state = 861
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [VtlParser.T__12]:
                localctx = VtlParser.ParenthesisExprRefContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 855
                self.match(VtlParser.T__12)
                self.state = 856
                self.expr(0)
                self.state = 857
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.IDENTIFIER]:
                localctx = VtlParser.VarIdRefContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 859
                self.varID()
                pass
            elif token in [
                VtlParser.INTEGER_CONSTANT,
                VtlParser.FLOAT_CONSTANT,
                VtlParser.BOOLEAN_CONSTANT,
                VtlParser.NULL_CONSTANT,
                VtlParser.STRING_CONSTANT,
            ]:
                localctx = VtlParser.ConstantRefContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 860
                self.constant()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IdentifierListContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.IDENTIFIER)
            else:
                return self.getToken(VtlParser.IDENTIFIER, i)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def getRuleIndex(self):
            return VtlParser.RULE_identifierList

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterIdentifierList"):
                listener.enterIdentifierList(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitIdentifierList"):
                listener.exitIdentifierList(self)

    def identifierList(self):

        localctx = VtlParser.IdentifierListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_identifierList)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 863
            self.match(VtlParser.T__0)
            self.state = 864
            self.match(VtlParser.IDENTIFIER)
            self.state = 869
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == VtlParser.CARTESIAN_PER:
                self.state = 865
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 866
                self.match(VtlParser.IDENTIFIER)
                self.state = 871
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 872
            self.match(VtlParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ListsContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constant(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ConstantContext)
            else:
                return self.getTypedRuleContext(VtlParser.ConstantContext, i)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def getRuleIndex(self):
            return VtlParser.RULE_lists

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLists"):
                listener.enterLists(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLists"):
                listener.exitLists(self)

    def lists(self):

        localctx = VtlParser.ListsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_lists)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 874
            self.match(VtlParser.T__15)
            self.state = 875
            self.constant()
            self.state = 880
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == VtlParser.CARTESIAN_PER:
                self.state = 876
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 877
                self.constant()
                self.state = 882
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 883
            self.match(VtlParser.T__16)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EvalExprContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EVAL(self):
            return self.getToken(VtlParser.EVAL, 0)

        def routineName(self):
            return self.getTypedRuleContext(VtlParser.RoutineNameContext, 0)

        def componentID(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ComponentIDContext)
            else:
                return self.getTypedRuleContext(VtlParser.ComponentIDContext, i)

        def constant(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ConstantContext)
            else:
                return self.getTypedRuleContext(VtlParser.ConstantContext, i)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def LANGUAGE(self):
            return self.getToken(VtlParser.LANGUAGE, 0)

        def STRING_CONSTANT(self):
            return self.getToken(VtlParser.STRING_CONSTANT, 0)

        def RETURNS(self):
            return self.getToken(VtlParser.RETURNS, 0)

        def outputParameterType(self):
            return self.getTypedRuleContext(VtlParser.OutputParameterTypeContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_evalExpr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEvalExpr"):
                listener.enterEvalExpr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEvalExpr"):
                listener.exitEvalExpr(self)

    def evalExpr(self):

        localctx = VtlParser.EvalExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_evalExpr)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 885
            self.match(VtlParser.EVAL)
            self.state = 886
            self.match(VtlParser.T__12)
            self.state = 887
            self.routineName()
            self.state = 888
            self.match(VtlParser.T__12)
            self.state = 891
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [VtlParser.IDENTIFIER]:
                self.state = 889
                self.componentID()
                pass
            elif token in [
                VtlParser.INTEGER_CONSTANT,
                VtlParser.FLOAT_CONSTANT,
                VtlParser.BOOLEAN_CONSTANT,
                VtlParser.NULL_CONSTANT,
                VtlParser.STRING_CONSTANT,
            ]:
                self.state = 890
                self.constant()
                pass
            elif token in [VtlParser.T__13, VtlParser.CARTESIAN_PER]:
                pass
            else:
                pass
            self.state = 900
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == VtlParser.CARTESIAN_PER:
                self.state = 893
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 896
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [VtlParser.IDENTIFIER]:
                    self.state = 894
                    self.componentID()
                    pass
                elif token in [
                    VtlParser.INTEGER_CONSTANT,
                    VtlParser.FLOAT_CONSTANT,
                    VtlParser.BOOLEAN_CONSTANT,
                    VtlParser.NULL_CONSTANT,
                    VtlParser.STRING_CONSTANT,
                ]:
                    self.state = 895
                    self.constant()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 902
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 903
            self.match(VtlParser.T__13)
            self.state = 906
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.LANGUAGE:
                self.state = 904
                self.match(VtlParser.LANGUAGE)
                self.state = 905
                self.match(VtlParser.STRING_CONSTANT)

            self.state = 910
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.RETURNS:
                self.state = 908
                self.match(VtlParser.RETURNS)
                self.state = 909
                self.outputParameterType()

            self.state = 912
            self.match(VtlParser.T__13)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CastExprContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CAST(self):
            return self.getToken(VtlParser.CAST, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def basicScalarType(self):
            return self.getTypedRuleContext(VtlParser.BasicScalarTypeContext, 0)

        def valueDomainName(self):
            return self.getTypedRuleContext(VtlParser.ValueDomainNameContext, 0)

        def STRING_CONSTANT(self):
            return self.getToken(VtlParser.STRING_CONSTANT, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_castExpr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCastExpr"):
                listener.enterCastExpr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCastExpr"):
                listener.exitCastExpr(self)

    def castExpr(self):

        localctx = VtlParser.CastExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_castExpr)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 914
            self.match(VtlParser.CAST)
            self.state = 915
            self.match(VtlParser.T__12)
            self.state = 916
            self.expr(0)
            self.state = 917
            self.match(VtlParser.CARTESIAN_PER)
            self.state = 920
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [
                VtlParser.BOOLEAN,
                VtlParser.DATE,
                VtlParser.TIME_PERIOD,
                VtlParser.NUMBER,
                VtlParser.STRING,
                VtlParser.INTEGER,
                VtlParser.DURATION,
                VtlParser.SCALAR,
                VtlParser.TIME,
            ]:
                self.state = 918
                self.basicScalarType()
                pass
            elif token in [VtlParser.IDENTIFIER]:
                self.state = 919
                self.valueDomainName()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 924
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.CARTESIAN_PER:
                self.state = 922
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 923
                self.match(VtlParser.STRING_CONSTANT)

            self.state = 926
            self.match(VtlParser.T__13)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PeriodExprContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PERIOD_INDICATOR(self):
            return self.getToken(VtlParser.PERIOD_INDICATOR, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_periodExpr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPeriodExpr"):
                listener.enterPeriodExpr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPeriodExpr"):
                listener.exitPeriodExpr(self)

    def periodExpr(self):

        localctx = VtlParser.PeriodExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_periodExpr)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 928
            self.match(VtlParser.PERIOD_INDICATOR)
            self.state = 929
            self.match(VtlParser.T__12)
            self.state = 931
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (
                (
                    ((_la) & ~0x3F) == 0
                    and (
                        (1 << _la)
                        & (
                            (1 << VtlParser.T__2)
                            | (1 << VtlParser.T__3)
                            | (1 << VtlParser.T__12)
                            | (1 << VtlParser.EVAL)
                            | (1 << VtlParser.IF)
                            | (1 << VtlParser.CASE)
                            | (1 << VtlParser.CURRENT_DATE)
                            | (1 << VtlParser.DATEDIFF)
                            | (1 << VtlParser.DATEADD)
                            | (1 << VtlParser.YEAR_OP)
                            | (1 << VtlParser.MONTH_OP)
                            | (1 << VtlParser.DAYOFMONTH)
                            | (1 << VtlParser.DAYOFYEAR)
                            | (1 << VtlParser.DAYTOYEAR)
                            | (1 << VtlParser.DAYTOMONTH)
                            | (1 << VtlParser.YEARTODAY)
                            | (1 << VtlParser.MONTHTODAY)
                            | (1 << VtlParser.NOT)
                            | (1 << VtlParser.BETWEEN)
                            | (1 << VtlParser.ISNULL)
                            | (1 << VtlParser.UNION)
                            | (1 << VtlParser.SYMDIFF)
                            | (1 << VtlParser.INTERSECT)
                            | (1 << VtlParser.RANDOM)
                        )
                    )
                    != 0
                )
                or (
                    (((_la - 65)) & ~0x3F) == 0
                    and (
                        (1 << (_la - 65))
                        & (
                            (1 << (VtlParser.CHECK - 65))
                            | (1 << (VtlParser.EXISTS_IN - 65))
                            | (1 << (VtlParser.RANK - 65))
                            | (1 << (VtlParser.MIN - 65))
                            | (1 << (VtlParser.MAX - 65))
                            | (1 << (VtlParser.ABS - 65))
                            | (1 << (VtlParser.LN - 65))
                            | (1 << (VtlParser.LOG - 65))
                            | (1 << (VtlParser.TRUNC - 65))
                            | (1 << (VtlParser.ROUND - 65))
                            | (1 << (VtlParser.POWER - 65))
                            | (1 << (VtlParser.MOD - 65))
                            | (1 << (VtlParser.LEN - 65))
                            | (1 << (VtlParser.TRIM - 65))
                            | (1 << (VtlParser.UCASE - 65))
                            | (1 << (VtlParser.LCASE - 65))
                            | (1 << (VtlParser.SUBSTR - 65))
                            | (1 << (VtlParser.SUM - 65))
                            | (1 << (VtlParser.AVG - 65))
                            | (1 << (VtlParser.MEDIAN - 65))
                            | (1 << (VtlParser.COUNT - 65))
                            | (1 << (VtlParser.EXP - 65))
                            | (1 << (VtlParser.CHARSET_MATCH - 65))
                            | (1 << (VtlParser.NVL - 65))
                            | (1 << (VtlParser.HIERARCHY - 65))
                            | (1 << (VtlParser.DEFINE - 65))
                        )
                    )
                    != 0
                )
                or (
                    (((_la - 130)) & ~0x3F) == 0
                    and (
                        (1 << (_la - 130))
                        & (
                            (1 << (VtlParser.LTRIM - 130))
                            | (1 << (VtlParser.RTRIM - 130))
                            | (1 << (VtlParser.INSTR - 130))
                            | (1 << (VtlParser.REPLACE - 130))
                            | (1 << (VtlParser.CEIL - 130))
                            | (1 << (VtlParser.FLOOR - 130))
                            | (1 << (VtlParser.SQRT - 130))
                            | (1 << (VtlParser.SETDIFF - 130))
                            | (1 << (VtlParser.STDDEV_POP - 130))
                            | (1 << (VtlParser.STDDEV_SAMP - 130))
                            | (1 << (VtlParser.VAR_POP - 130))
                            | (1 << (VtlParser.VAR_SAMP - 130))
                            | (1 << (VtlParser.FIRST_VALUE - 130))
                            | (1 << (VtlParser.LAST_VALUE - 130))
                            | (1 << (VtlParser.LAG - 130))
                            | (1 << (VtlParser.LEAD - 130))
                            | (1 << (VtlParser.RATIO_TO_REPORT - 130))
                            | (1 << (VtlParser.FILL_TIME_SERIES - 130))
                            | (1 << (VtlParser.FLOW_TO_STOCK - 130))
                            | (1 << (VtlParser.STOCK_TO_FLOW - 130))
                            | (1 << (VtlParser.TIMESHIFT - 130))
                            | (1 << (VtlParser.INNER_JOIN - 130))
                            | (1 << (VtlParser.LEFT_JOIN - 130))
                            | (1 << (VtlParser.CROSS_JOIN - 130))
                        )
                    )
                    != 0
                )
                or (
                    (((_la - 194)) & ~0x3F) == 0
                    and (
                        (1 << (_la - 194))
                        & (
                            (1 << (VtlParser.FULL_JOIN - 194))
                            | (1 << (VtlParser.PERIOD_INDICATOR - 194))
                            | (1 << (VtlParser.TIME_AGG - 194))
                            | (1 << (VtlParser.CAST - 194))
                            | (1 << (VtlParser.CHECK_DATAPOINT - 194))
                            | (1 << (VtlParser.CHECK_HIERARCHY - 194))
                            | (1 << (VtlParser.INTEGER_CONSTANT - 194))
                            | (1 << (VtlParser.FLOAT_CONSTANT - 194))
                            | (1 << (VtlParser.BOOLEAN_CONSTANT - 194))
                            | (1 << (VtlParser.NULL_CONSTANT - 194))
                            | (1 << (VtlParser.STRING_CONSTANT - 194))
                            | (1 << (VtlParser.IDENTIFIER - 194))
                        )
                    )
                    != 0
                )
            ):
                self.state = 930
                self.expr(0)

            self.state = 933
            self.match(VtlParser.T__13)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TimeShiftExprContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TIMESHIFT(self):
            return self.getToken(VtlParser.TIMESHIFT, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def CARTESIAN_PER(self):
            return self.getToken(VtlParser.CARTESIAN_PER, 0)

        def INTEGER_CONSTANT(self):
            return self.getToken(VtlParser.INTEGER_CONSTANT, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_timeShiftExpr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTimeShiftExpr"):
                listener.enterTimeShiftExpr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTimeShiftExpr"):
                listener.exitTimeShiftExpr(self)

    def timeShiftExpr(self):

        localctx = VtlParser.TimeShiftExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_timeShiftExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 935
            self.match(VtlParser.TIMESHIFT)
            self.state = 936
            self.match(VtlParser.T__12)
            self.state = 937
            self.expr(0)
            self.state = 938
            self.match(VtlParser.CARTESIAN_PER)
            self.state = 939
            self.match(VtlParser.INTEGER_CONSTANT)
            self.state = 940
            self.match(VtlParser.T__13)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TimeSeriesExprContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FILL_TIME_SERIES(self):
            return self.getToken(VtlParser.FILL_TIME_SERIES, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def CARTESIAN_PER(self):
            return self.getToken(VtlParser.CARTESIAN_PER, 0)

        def SINGLE(self):
            return self.getToken(VtlParser.SINGLE, 0)

        def ALL(self):
            return self.getToken(VtlParser.ALL, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_timeSeriesExpr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTimeSeriesExpr"):
                listener.enterTimeSeriesExpr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTimeSeriesExpr"):
                listener.exitTimeSeriesExpr(self)

    def timeSeriesExpr(self):

        localctx = VtlParser.TimeSeriesExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_timeSeriesExpr)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 942
            self.match(VtlParser.FILL_TIME_SERIES)
            self.state = 943
            self.match(VtlParser.T__12)
            self.state = 944
            self.expr(0)
            self.state = 947
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.CARTESIAN_PER:
                self.state = 945
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 946
                _la = self._input.LA(1)
                if not (_la == VtlParser.ALL or _la == VtlParser.SINGLE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()

            self.state = 949
            self.match(VtlParser.T__13)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TimeAggExprContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TIME_AGG(self):
            return self.getToken(VtlParser.TIME_AGG, 0)

        def STRING_CONSTANT(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.STRING_CONSTANT)
            else:
                return self.getToken(VtlParser.STRING_CONSTANT, i)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def OPTIONAL(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.OPTIONAL)
            else:
                return self.getToken(VtlParser.OPTIONAL, i)

        def FIRST(self):
            return self.getToken(VtlParser.FIRST, 0)

        def LAST(self):
            return self.getToken(VtlParser.LAST, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_timeAggExpr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTimeAggExpr"):
                listener.enterTimeAggExpr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTimeAggExpr"):
                listener.exitTimeAggExpr(self)

    def timeAggExpr(self):

        localctx = VtlParser.TimeAggExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_timeAggExpr)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 951
            self.match(VtlParser.TIME_AGG)
            self.state = 952
            self.match(VtlParser.T__12)
            self.state = 953
            self.match(VtlParser.STRING_CONSTANT)
            self.state = 956
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 71, self._ctx)
            if la_ == 1:
                self.state = 954
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 955
                _la = self._input.LA(1)
                if not (_la == VtlParser.OPTIONAL or _la == VtlParser.STRING_CONSTANT):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()

            self.state = 963
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 73, self._ctx)
            if la_ == 1:
                self.state = 958
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 961
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [
                    VtlParser.T__2,
                    VtlParser.T__3,
                    VtlParser.T__12,
                    VtlParser.EVAL,
                    VtlParser.IF,
                    VtlParser.CASE,
                    VtlParser.CURRENT_DATE,
                    VtlParser.DATEDIFF,
                    VtlParser.DATEADD,
                    VtlParser.YEAR_OP,
                    VtlParser.MONTH_OP,
                    VtlParser.DAYOFMONTH,
                    VtlParser.DAYOFYEAR,
                    VtlParser.DAYTOYEAR,
                    VtlParser.DAYTOMONTH,
                    VtlParser.YEARTODAY,
                    VtlParser.MONTHTODAY,
                    VtlParser.NOT,
                    VtlParser.BETWEEN,
                    VtlParser.ISNULL,
                    VtlParser.UNION,
                    VtlParser.SYMDIFF,
                    VtlParser.INTERSECT,
                    VtlParser.RANDOM,
                    VtlParser.CHECK,
                    VtlParser.EXISTS_IN,
                    VtlParser.RANK,
                    VtlParser.MIN,
                    VtlParser.MAX,
                    VtlParser.ABS,
                    VtlParser.LN,
                    VtlParser.LOG,
                    VtlParser.TRUNC,
                    VtlParser.ROUND,
                    VtlParser.POWER,
                    VtlParser.MOD,
                    VtlParser.LEN,
                    VtlParser.TRIM,
                    VtlParser.UCASE,
                    VtlParser.LCASE,
                    VtlParser.SUBSTR,
                    VtlParser.SUM,
                    VtlParser.AVG,
                    VtlParser.MEDIAN,
                    VtlParser.COUNT,
                    VtlParser.EXP,
                    VtlParser.CHARSET_MATCH,
                    VtlParser.NVL,
                    VtlParser.HIERARCHY,
                    VtlParser.DEFINE,
                    VtlParser.LTRIM,
                    VtlParser.RTRIM,
                    VtlParser.INSTR,
                    VtlParser.REPLACE,
                    VtlParser.CEIL,
                    VtlParser.FLOOR,
                    VtlParser.SQRT,
                    VtlParser.SETDIFF,
                    VtlParser.STDDEV_POP,
                    VtlParser.STDDEV_SAMP,
                    VtlParser.VAR_POP,
                    VtlParser.VAR_SAMP,
                    VtlParser.FIRST_VALUE,
                    VtlParser.LAST_VALUE,
                    VtlParser.LAG,
                    VtlParser.LEAD,
                    VtlParser.RATIO_TO_REPORT,
                    VtlParser.FILL_TIME_SERIES,
                    VtlParser.FLOW_TO_STOCK,
                    VtlParser.STOCK_TO_FLOW,
                    VtlParser.TIMESHIFT,
                    VtlParser.INNER_JOIN,
                    VtlParser.LEFT_JOIN,
                    VtlParser.CROSS_JOIN,
                    VtlParser.FULL_JOIN,
                    VtlParser.PERIOD_INDICATOR,
                    VtlParser.TIME_AGG,
                    VtlParser.CAST,
                    VtlParser.CHECK_DATAPOINT,
                    VtlParser.CHECK_HIERARCHY,
                    VtlParser.INTEGER_CONSTANT,
                    VtlParser.FLOAT_CONSTANT,
                    VtlParser.BOOLEAN_CONSTANT,
                    VtlParser.NULL_CONSTANT,
                    VtlParser.STRING_CONSTANT,
                    VtlParser.IDENTIFIER,
                ]:
                    self.state = 959
                    self.expr(0)
                    pass
                elif token in [VtlParser.OPTIONAL]:
                    self.state = 960
                    self.match(VtlParser.OPTIONAL)
                    pass
                else:
                    raise NoViableAltException(self)

            self.state = 967
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.CARTESIAN_PER:
                self.state = 965
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 966
                _la = self._input.LA(1)
                if not (_la == VtlParser.FIRST or _la == VtlParser.LAST):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()

            self.state = 969
            self.match(VtlParser.T__13)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ValidationExprContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CHECK(self):
            return self.getToken(VtlParser.CHECK, 0)

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ExprContext)
            else:
                return self.getTypedRuleContext(VtlParser.ExprContext, i)

        def erCode(self):
            return self.getTypedRuleContext(VtlParser.ErCodeContext, 0)

        def erLevel(self):
            return self.getTypedRuleContext(VtlParser.ErLevelContext, 0)

        def IMBALANCE(self):
            return self.getToken(VtlParser.IMBALANCE, 0)

        def INVALID(self):
            return self.getToken(VtlParser.INVALID, 0)

        def ALL(self):
            return self.getToken(VtlParser.ALL, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_validationExpr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterValidationExpr"):
                listener.enterValidationExpr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitValidationExpr"):
                listener.exitValidationExpr(self)

    def validationExpr(self):

        localctx = VtlParser.ValidationExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_validationExpr)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 971
            self.match(VtlParser.CHECK)
            self.state = 972
            self.match(VtlParser.T__12)
            self.state = 973
            self.expr(0)
            self.state = 975
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.ERRORCODE:
                self.state = 974
                self.erCode()

            self.state = 978
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.ERRORLEVEL:
                self.state = 977
                self.erLevel()

            self.state = 982
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.IMBALANCE:
                self.state = 980
                self.match(VtlParser.IMBALANCE)
                self.state = 981
                self.expr(0)

            self.state = 985
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.ALL or _la == VtlParser.INVALID:
                self.state = 984
                _la = self._input.LA(1)
                if not (_la == VtlParser.ALL or _la == VtlParser.INVALID):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()

            self.state = 987
            self.match(VtlParser.T__13)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ValidationDatapointContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CHECK_DATAPOINT(self):
            return self.getToken(VtlParser.CHECK_DATAPOINT, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def IDENTIFIER(self):
            return self.getToken(VtlParser.IDENTIFIER, 0)

        def COMPONENTS(self):
            return self.getToken(VtlParser.COMPONENTS, 0)

        def componentID(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ComponentIDContext)
            else:
                return self.getTypedRuleContext(VtlParser.ComponentIDContext, i)

        def INVALID(self):
            return self.getToken(VtlParser.INVALID, 0)

        def ALL_MEASURES(self):
            return self.getToken(VtlParser.ALL_MEASURES, 0)

        def ALL(self):
            return self.getToken(VtlParser.ALL, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_validationDatapoint

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterValidationDatapoint"):
                listener.enterValidationDatapoint(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitValidationDatapoint"):
                listener.exitValidationDatapoint(self)

    def validationDatapoint(self):

        localctx = VtlParser.ValidationDatapointContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_validationDatapoint)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 989
            self.match(VtlParser.CHECK_DATAPOINT)
            self.state = 990
            self.match(VtlParser.T__12)
            self.state = 991
            self.expr(0)
            self.state = 992
            self.match(VtlParser.CARTESIAN_PER)
            self.state = 993
            self.match(VtlParser.IDENTIFIER)
            self.state = 1003
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.COMPONENTS:
                self.state = 994
                self.match(VtlParser.COMPONENTS)
                self.state = 995
                self.componentID()
                self.state = 1000
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == VtlParser.CARTESIAN_PER:
                    self.state = 996
                    self.match(VtlParser.CARTESIAN_PER)
                    self.state = 997
                    self.componentID()
                    self.state = 1002
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

            self.state = 1006
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.ALL or _la == VtlParser.INVALID or _la == VtlParser.ALL_MEASURES:
                self.state = 1005
                _la = self._input.LA(1)
                if not (
                    _la == VtlParser.ALL
                    or _la == VtlParser.INVALID
                    or _la == VtlParser.ALL_MEASURES
                ):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()

            self.state = 1008
            self.match(VtlParser.T__13)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ValidationHierarchicalContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CHECK_HIERARCHY(self):
            return self.getToken(VtlParser.CHECK_HIERARCHY, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def IDENTIFIER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.IDENTIFIER)
            else:
                return self.getToken(VtlParser.IDENTIFIER, i)

        def CONDITION(self):
            return self.getToken(VtlParser.CONDITION, 0)

        def componentID(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ComponentIDContext)
            else:
                return self.getTypedRuleContext(VtlParser.ComponentIDContext, i)

        def RULE(self):
            return self.getToken(VtlParser.RULE, 0)

        def NON_NULL(self):
            return self.getToken(VtlParser.NON_NULL, 0)

        def NON_ZERO(self):
            return self.getToken(VtlParser.NON_ZERO, 0)

        def PARTIAL_NULL(self):
            return self.getToken(VtlParser.PARTIAL_NULL, 0)

        def PARTIAL_ZERO(self):
            return self.getToken(VtlParser.PARTIAL_ZERO, 0)

        def ALWAYS_NULL(self):
            return self.getToken(VtlParser.ALWAYS_NULL, 0)

        def ALWAYS_ZERO(self):
            return self.getToken(VtlParser.ALWAYS_ZERO, 0)

        def DATASET(self):
            return self.getToken(VtlParser.DATASET, 0)

        def DATASET_PRIORITY(self):
            return self.getToken(VtlParser.DATASET_PRIORITY, 0)

        def INVALID(self):
            return self.getToken(VtlParser.INVALID, 0)

        def ALL(self):
            return self.getToken(VtlParser.ALL, 0)

        def ALL_MEASURES(self):
            return self.getToken(VtlParser.ALL_MEASURES, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_validationHierarchical

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterValidationHierarchical"):
                listener.enterValidationHierarchical(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitValidationHierarchical"):
                listener.exitValidationHierarchical(self)

    def validationHierarchical(self):

        localctx = VtlParser.ValidationHierarchicalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_validationHierarchical)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1010
            self.match(VtlParser.CHECK_HIERARCHY)
            self.state = 1011
            self.match(VtlParser.T__12)
            self.state = 1012
            self.expr(0)
            self.state = 1013
            self.match(VtlParser.CARTESIAN_PER)
            self.state = 1014
            self.match(VtlParser.IDENTIFIER)
            self.state = 1024
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.CONDITION:
                self.state = 1015
                self.match(VtlParser.CONDITION)
                self.state = 1016
                self.componentID()
                self.state = 1021
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == VtlParser.CARTESIAN_PER:
                    self.state = 1017
                    self.match(VtlParser.CARTESIAN_PER)
                    self.state = 1018
                    self.componentID()
                    self.state = 1023
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

            self.state = 1028
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.RULE:
                self.state = 1026
                self.match(VtlParser.RULE)
                self.state = 1027
                self.match(VtlParser.IDENTIFIER)

            self.state = 1031
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la - 222)) & ~0x3F) == 0 and (
                (1 << (_la - 222))
                & (
                    (1 << (VtlParser.NON_NULL - 222))
                    | (1 << (VtlParser.NON_ZERO - 222))
                    | (1 << (VtlParser.PARTIAL_NULL - 222))
                    | (1 << (VtlParser.PARTIAL_ZERO - 222))
                    | (1 << (VtlParser.ALWAYS_NULL - 222))
                    | (1 << (VtlParser.ALWAYS_ZERO - 222))
                )
            ) != 0:
                self.state = 1030
                _la = self._input.LA(1)
                if not (
                    (
                        (((_la - 222)) & ~0x3F) == 0
                        and (
                            (1 << (_la - 222))
                            & (
                                (1 << (VtlParser.NON_NULL - 222))
                                | (1 << (VtlParser.NON_ZERO - 222))
                                | (1 << (VtlParser.PARTIAL_NULL - 222))
                                | (1 << (VtlParser.PARTIAL_ZERO - 222))
                                | (1 << (VtlParser.ALWAYS_NULL - 222))
                                | (1 << (VtlParser.ALWAYS_ZERO - 222))
                            )
                        )
                        != 0
                    )
                ):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()

            self.state = 1034
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.DATASET or _la == VtlParser.DATASET_PRIORITY:
                self.state = 1033
                _la = self._input.LA(1)
                if not (_la == VtlParser.DATASET or _la == VtlParser.DATASET_PRIORITY):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()

            self.state = 1037
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.ALL or _la == VtlParser.INVALID or _la == VtlParser.ALL_MEASURES:
                self.state = 1036
                _la = self._input.LA(1)
                if not (
                    _la == VtlParser.ALL
                    or _la == VtlParser.INVALID
                    or _la == VtlParser.ALL_MEASURES
                ):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()

            self.state = 1039
            self.match(VtlParser.T__13)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ErCodeContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ERRORCODE(self):
            return self.getToken(VtlParser.ERRORCODE, 0)

        def constant(self):
            return self.getTypedRuleContext(VtlParser.ConstantContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_erCode

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterErCode"):
                listener.enterErCode(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitErCode"):
                listener.exitErCode(self)

    def erCode(self):

        localctx = VtlParser.ErCodeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_erCode)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1041
            self.match(VtlParser.ERRORCODE)
            self.state = 1042
            self.constant()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ErLevelContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ERRORLEVEL(self):
            return self.getToken(VtlParser.ERRORLEVEL, 0)

        def constant(self):
            return self.getTypedRuleContext(VtlParser.ConstantContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_erLevel

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterErLevel"):
                listener.enterErLevel(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitErLevel"):
                listener.exitErLevel(self)

    def erLevel(self):

        localctx = VtlParser.ErLevelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_erLevel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1044
            self.match(VtlParser.ERRORLEVEL)
            self.state = 1045
            self.constant()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class HierarchyExprContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HIERARCHY(self):
            return self.getToken(VtlParser.HIERARCHY, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def IDENTIFIER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.IDENTIFIER)
            else:
                return self.getToken(VtlParser.IDENTIFIER, i)

        def CONDITION(self):
            return self.getToken(VtlParser.CONDITION, 0)

        def componentID(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ComponentIDContext)
            else:
                return self.getTypedRuleContext(VtlParser.ComponentIDContext, i)

        def RULE(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.RULE)
            else:
                return self.getToken(VtlParser.RULE, i)

        def OPTIONAL(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.OPTIONAL)
            else:
                return self.getToken(VtlParser.OPTIONAL, i)

        def NON_NULL(self):
            return self.getToken(VtlParser.NON_NULL, 0)

        def NON_ZERO(self):
            return self.getToken(VtlParser.NON_ZERO, 0)

        def PARTIAL_NULL(self):
            return self.getToken(VtlParser.PARTIAL_NULL, 0)

        def PARTIAL_ZERO(self):
            return self.getToken(VtlParser.PARTIAL_ZERO, 0)

        def ALWAYS_NULL(self):
            return self.getToken(VtlParser.ALWAYS_NULL, 0)

        def ALWAYS_ZERO(self):
            return self.getToken(VtlParser.ALWAYS_ZERO, 0)

        def DATASET(self):
            return self.getToken(VtlParser.DATASET, 0)

        def RULE_PRIORITY(self):
            return self.getToken(VtlParser.RULE_PRIORITY, 0)

        def COMPUTED(self):
            return self.getToken(VtlParser.COMPUTED, 0)

        def ALL(self):
            return self.getToken(VtlParser.ALL, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_hierarchyExpr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterHierarchyExpr"):
                listener.enterHierarchyExpr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitHierarchyExpr"):
                listener.exitHierarchyExpr(self)

    def hierarchyExpr(self):

        localctx = VtlParser.HierarchyExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_hierarchyExpr)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1047
            self.match(VtlParser.HIERARCHY)
            self.state = 1048
            self.match(VtlParser.T__12)
            self.state = 1049
            self.expr(0)
            self.state = 1050
            self.match(VtlParser.CARTESIAN_PER)
            self.state = 1051
            self.match(VtlParser.IDENTIFIER)
            self.state = 1061
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.CONDITION:
                self.state = 1052
                self.match(VtlParser.CONDITION)
                self.state = 1053
                self.componentID()
                self.state = 1058
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == VtlParser.CARTESIAN_PER:
                    self.state = 1054
                    self.match(VtlParser.CARTESIAN_PER)
                    self.state = 1055
                    self.componentID()
                    self.state = 1060
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

            self.state = 1065
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 90, self._ctx)
            if la_ == 1:
                self.state = 1063
                self.match(VtlParser.RULE)
                self.state = 1064
                self.match(VtlParser.IDENTIFIER)

            self.state = 1069
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 91, self._ctx)
            if la_ == 1:
                self.state = 1067
                _la = self._input.LA(1)
                if not (
                    (
                        (((_la - 222)) & ~0x3F) == 0
                        and (
                            (1 << (_la - 222))
                            & (
                                (1 << (VtlParser.NON_NULL - 222))
                                | (1 << (VtlParser.NON_ZERO - 222))
                                | (1 << (VtlParser.PARTIAL_NULL - 222))
                                | (1 << (VtlParser.PARTIAL_ZERO - 222))
                                | (1 << (VtlParser.ALWAYS_NULL - 222))
                                | (1 << (VtlParser.ALWAYS_ZERO - 222))
                            )
                        )
                        != 0
                    )
                ):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()

            elif la_ == 2:
                self.state = 1068
                self.match(VtlParser.OPTIONAL)

            self.state = 1073
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 92, self._ctx)
            if la_ == 1:
                self.state = 1071
                _la = self._input.LA(1)
                if not (
                    _la == VtlParser.DATASET
                    or _la == VtlParser.RULE
                    or _la == VtlParser.RULE_PRIORITY
                ):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()

            elif la_ == 2:
                self.state = 1072
                self.match(VtlParser.OPTIONAL)

            self.state = 1077
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [VtlParser.ALL, VtlParser.COMPUTED]:
                self.state = 1075
                _la = self._input.LA(1)
                if not (_la == VtlParser.ALL or _la == VtlParser.COMPUTED):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [VtlParser.OPTIONAL]:
                self.state = 1076
                self.match(VtlParser.OPTIONAL)
                pass
            elif token in [VtlParser.T__13]:
                pass
            else:
                pass
            self.state = 1079
            self.match(VtlParser.T__13)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DatasetClauseContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RENAME(self):
            return self.getToken(VtlParser.RENAME, 0)

        def renameClause(self):
            return self.getTypedRuleContext(VtlParser.RenameClauseContext, 0)

        def aggrClause(self):
            return self.getTypedRuleContext(VtlParser.AggrClauseContext, 0)

        def filterClause(self):
            return self.getTypedRuleContext(VtlParser.FilterClauseContext, 0)

        def calcClause(self):
            return self.getTypedRuleContext(VtlParser.CalcClauseContext, 0)

        def keepClause(self):
            return self.getTypedRuleContext(VtlParser.KeepClauseContext, 0)

        def dropClause(self):
            return self.getTypedRuleContext(VtlParser.DropClauseContext, 0)

        def pivotExpr(self):
            return self.getTypedRuleContext(VtlParser.PivotExprContext, 0)

        def unpivotExpr(self):
            return self.getTypedRuleContext(VtlParser.UnpivotExprContext, 0)

        def subspaceExpr(self):
            return self.getTypedRuleContext(VtlParser.SubspaceExprContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_datasetClause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDatasetClause"):
                listener.enterDatasetClause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDatasetClause"):
                listener.exitDatasetClause(self)

    def datasetClause(self):

        localctx = VtlParser.DatasetClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_datasetClause)
        try:
            self.state = 1091
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [VtlParser.RENAME]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1081
                self.match(VtlParser.RENAME)
                self.state = 1082
                self.renameClause()
                pass
            elif token in [VtlParser.AGGREGATE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1083
                self.aggrClause()
                pass
            elif token in [VtlParser.FILTER]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1084
                self.filterClause()
                pass
            elif token in [VtlParser.CALC]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1085
                self.calcClause()
                pass
            elif token in [VtlParser.KEEP]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1086
                self.keepClause()
                pass
            elif token in [VtlParser.DROP]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1087
                self.dropClause()
                pass
            elif token in [VtlParser.PIVOT]:
                self.enterOuterAlt(localctx, 7)
                self.state = 1088
                self.pivotExpr()
                pass
            elif token in [VtlParser.UNPIVOT]:
                self.enterOuterAlt(localctx, 8)
                self.state = 1089
                self.unpivotExpr()
                pass
            elif token in [VtlParser.SUBSPACE]:
                self.enterOuterAlt(localctx, 9)
                self.state = 1090
                self.subspaceExpr()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AnFunctionClauseContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OVER(self):
            return self.getToken(VtlParser.OVER, 0)

        def aggrFunctionName(self):
            return self.getTypedRuleContext(VtlParser.AggrFunctionNameContext, 0)

        def anFunction(self):
            return self.getTypedRuleContext(VtlParser.AnFunctionContext, 0)

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ExprContext)
            else:
                return self.getTypedRuleContext(VtlParser.ExprContext, i)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def partitionByClause(self):
            return self.getTypedRuleContext(VtlParser.PartitionByClauseContext, 0)

        def orderByClause(self):
            return self.getTypedRuleContext(VtlParser.OrderByClauseContext, 0)

        def windowingClause(self):
            return self.getTypedRuleContext(VtlParser.WindowingClauseContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_anFunctionClause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAnFunctionClause"):
                listener.enterAnFunctionClause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAnFunctionClause"):
                listener.exitAnFunctionClause(self)

    def anFunctionClause(self):

        localctx = VtlParser.AnFunctionClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_anFunctionClause)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1095
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [
                VtlParser.MIN,
                VtlParser.MAX,
                VtlParser.SUM,
                VtlParser.AVG,
                VtlParser.MEDIAN,
                VtlParser.COUNT,
                VtlParser.STDDEV_POP,
                VtlParser.STDDEV_SAMP,
                VtlParser.VAR_POP,
                VtlParser.VAR_SAMP,
            ]:
                self.state = 1093
                self.aggrFunctionName()
                pass
            elif token in [
                VtlParser.RANK,
                VtlParser.FIRST_VALUE,
                VtlParser.LAST_VALUE,
                VtlParser.LAG,
                VtlParser.LEAD,
                VtlParser.RATIO_TO_REPORT,
            ]:
                self.state = 1094
                self.anFunction()
                pass
            elif token in [VtlParser.T__12]:
                pass
            else:
                pass
            self.state = 1097
            self.match(VtlParser.T__12)
            self.state = 1099
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (
                (
                    ((_la) & ~0x3F) == 0
                    and (
                        (1 << _la)
                        & (
                            (1 << VtlParser.T__2)
                            | (1 << VtlParser.T__3)
                            | (1 << VtlParser.T__12)
                            | (1 << VtlParser.EVAL)
                            | (1 << VtlParser.IF)
                            | (1 << VtlParser.CASE)
                            | (1 << VtlParser.CURRENT_DATE)
                            | (1 << VtlParser.DATEDIFF)
                            | (1 << VtlParser.DATEADD)
                            | (1 << VtlParser.YEAR_OP)
                            | (1 << VtlParser.MONTH_OP)
                            | (1 << VtlParser.DAYOFMONTH)
                            | (1 << VtlParser.DAYOFYEAR)
                            | (1 << VtlParser.DAYTOYEAR)
                            | (1 << VtlParser.DAYTOMONTH)
                            | (1 << VtlParser.YEARTODAY)
                            | (1 << VtlParser.MONTHTODAY)
                            | (1 << VtlParser.NOT)
                            | (1 << VtlParser.BETWEEN)
                            | (1 << VtlParser.ISNULL)
                            | (1 << VtlParser.UNION)
                            | (1 << VtlParser.SYMDIFF)
                            | (1 << VtlParser.INTERSECT)
                            | (1 << VtlParser.RANDOM)
                        )
                    )
                    != 0
                )
                or (
                    (((_la - 65)) & ~0x3F) == 0
                    and (
                        (1 << (_la - 65))
                        & (
                            (1 << (VtlParser.CHECK - 65))
                            | (1 << (VtlParser.EXISTS_IN - 65))
                            | (1 << (VtlParser.RANK - 65))
                            | (1 << (VtlParser.MIN - 65))
                            | (1 << (VtlParser.MAX - 65))
                            | (1 << (VtlParser.ABS - 65))
                            | (1 << (VtlParser.LN - 65))
                            | (1 << (VtlParser.LOG - 65))
                            | (1 << (VtlParser.TRUNC - 65))
                            | (1 << (VtlParser.ROUND - 65))
                            | (1 << (VtlParser.POWER - 65))
                            | (1 << (VtlParser.MOD - 65))
                            | (1 << (VtlParser.LEN - 65))
                            | (1 << (VtlParser.TRIM - 65))
                            | (1 << (VtlParser.UCASE - 65))
                            | (1 << (VtlParser.LCASE - 65))
                            | (1 << (VtlParser.SUBSTR - 65))
                            | (1 << (VtlParser.SUM - 65))
                            | (1 << (VtlParser.AVG - 65))
                            | (1 << (VtlParser.MEDIAN - 65))
                            | (1 << (VtlParser.COUNT - 65))
                            | (1 << (VtlParser.EXP - 65))
                            | (1 << (VtlParser.CHARSET_MATCH - 65))
                            | (1 << (VtlParser.NVL - 65))
                            | (1 << (VtlParser.HIERARCHY - 65))
                            | (1 << (VtlParser.DEFINE - 65))
                        )
                    )
                    != 0
                )
                or (
                    (((_la - 130)) & ~0x3F) == 0
                    and (
                        (1 << (_la - 130))
                        & (
                            (1 << (VtlParser.LTRIM - 130))
                            | (1 << (VtlParser.RTRIM - 130))
                            | (1 << (VtlParser.INSTR - 130))
                            | (1 << (VtlParser.REPLACE - 130))
                            | (1 << (VtlParser.CEIL - 130))
                            | (1 << (VtlParser.FLOOR - 130))
                            | (1 << (VtlParser.SQRT - 130))
                            | (1 << (VtlParser.SETDIFF - 130))
                            | (1 << (VtlParser.STDDEV_POP - 130))
                            | (1 << (VtlParser.STDDEV_SAMP - 130))
                            | (1 << (VtlParser.VAR_POP - 130))
                            | (1 << (VtlParser.VAR_SAMP - 130))
                            | (1 << (VtlParser.FIRST_VALUE - 130))
                            | (1 << (VtlParser.LAST_VALUE - 130))
                            | (1 << (VtlParser.LAG - 130))
                            | (1 << (VtlParser.LEAD - 130))
                            | (1 << (VtlParser.RATIO_TO_REPORT - 130))
                            | (1 << (VtlParser.FILL_TIME_SERIES - 130))
                            | (1 << (VtlParser.FLOW_TO_STOCK - 130))
                            | (1 << (VtlParser.STOCK_TO_FLOW - 130))
                            | (1 << (VtlParser.TIMESHIFT - 130))
                            | (1 << (VtlParser.INNER_JOIN - 130))
                            | (1 << (VtlParser.LEFT_JOIN - 130))
                            | (1 << (VtlParser.CROSS_JOIN - 130))
                        )
                    )
                    != 0
                )
                or (
                    (((_la - 194)) & ~0x3F) == 0
                    and (
                        (1 << (_la - 194))
                        & (
                            (1 << (VtlParser.FULL_JOIN - 194))
                            | (1 << (VtlParser.PERIOD_INDICATOR - 194))
                            | (1 << (VtlParser.TIME_AGG - 194))
                            | (1 << (VtlParser.CAST - 194))
                            | (1 << (VtlParser.CHECK_DATAPOINT - 194))
                            | (1 << (VtlParser.CHECK_HIERARCHY - 194))
                            | (1 << (VtlParser.INTEGER_CONSTANT - 194))
                            | (1 << (VtlParser.FLOAT_CONSTANT - 194))
                            | (1 << (VtlParser.BOOLEAN_CONSTANT - 194))
                            | (1 << (VtlParser.NULL_CONSTANT - 194))
                            | (1 << (VtlParser.STRING_CONSTANT - 194))
                            | (1 << (VtlParser.IDENTIFIER - 194))
                        )
                    )
                    != 0
                )
            ):
                self.state = 1098
                self.expr(0)

            self.state = 1105
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == VtlParser.CARTESIAN_PER:
                self.state = 1101
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 1102
                self.expr(0)
                self.state = 1107
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1108
            self.match(VtlParser.OVER)
            self.state = 1109
            self.match(VtlParser.T__12)
            self.state = 1111
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.PARTITION:
                self.state = 1110
                self.partitionByClause()

            self.state = 1114
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.ORDER:
                self.state = 1113
                self.orderByClause()

            self.state = 1117
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.DATA or _la == VtlParser.RANGE:
                self.state = 1116
                self.windowingClause()

            self.state = 1119
            self.match(VtlParser.T__13)
            self.state = 1120
            self.match(VtlParser.T__13)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PartitionByClauseContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PARTITION(self):
            return self.getToken(VtlParser.PARTITION, 0)

        def BY(self):
            return self.getToken(VtlParser.BY, 0)

        def IDENTIFIER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.IDENTIFIER)
            else:
                return self.getToken(VtlParser.IDENTIFIER, i)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def getRuleIndex(self):
            return VtlParser.RULE_partitionByClause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPartitionByClause"):
                listener.enterPartitionByClause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPartitionByClause"):
                listener.exitPartitionByClause(self)

    def partitionByClause(self):

        localctx = VtlParser.PartitionByClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_partitionByClause)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1122
            self.match(VtlParser.PARTITION)
            self.state = 1123
            self.match(VtlParser.BY)
            self.state = 1124
            self.match(VtlParser.IDENTIFIER)
            self.state = 1129
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == VtlParser.CARTESIAN_PER:
                self.state = 1125
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 1126
                self.match(VtlParser.IDENTIFIER)
                self.state = 1131
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OrderByClauseContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ORDER(self):
            return self.getToken(VtlParser.ORDER, 0)

        def BY(self):
            return self.getToken(VtlParser.BY, 0)

        def componentID(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ComponentIDContext)
            else:
                return self.getTypedRuleContext(VtlParser.ComponentIDContext, i)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def ASC(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.ASC)
            else:
                return self.getToken(VtlParser.ASC, i)

        def DESC(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.DESC)
            else:
                return self.getToken(VtlParser.DESC, i)

        def getRuleIndex(self):
            return VtlParser.RULE_orderByClause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterOrderByClause"):
                listener.enterOrderByClause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitOrderByClause"):
                listener.exitOrderByClause(self)

    def orderByClause(self):

        localctx = VtlParser.OrderByClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_orderByClause)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1132
            self.match(VtlParser.ORDER)
            self.state = 1133
            self.match(VtlParser.BY)
            self.state = 1134
            self.componentID()
            self.state = 1136
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.ASC or _la == VtlParser.DESC:
                self.state = 1135
                _la = self._input.LA(1)
                if not (_la == VtlParser.ASC or _la == VtlParser.DESC):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()

            self.state = 1145
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == VtlParser.CARTESIAN_PER:
                self.state = 1138
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 1139
                self.componentID()
                self.state = 1141
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == VtlParser.ASC or _la == VtlParser.DESC:
                    self.state = 1140
                    _la = self._input.LA(1)
                    if not (_la == VtlParser.ASC or _la == VtlParser.DESC):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()

                self.state = 1147
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class WindowingClauseContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BETWEEN(self):
            return self.getToken(VtlParser.BETWEEN, 0)

        def limitClauseItem(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.LimitClauseItemContext)
            else:
                return self.getTypedRuleContext(VtlParser.LimitClauseItemContext, i)

        def AND(self):
            return self.getToken(VtlParser.AND, 0)

        def RANGE(self):
            return self.getToken(VtlParser.RANGE, 0)

        def DATA(self):
            return self.getToken(VtlParser.DATA, 0)

        def POINTS(self):
            return self.getToken(VtlParser.POINTS, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_windowingClause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterWindowingClause"):
                listener.enterWindowingClause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitWindowingClause"):
                listener.exitWindowingClause(self)

    def windowingClause(self):

        localctx = VtlParser.WindowingClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_windowingClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1151
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [VtlParser.DATA]:
                self.state = 1148
                self.match(VtlParser.DATA)
                self.state = 1149
                self.match(VtlParser.POINTS)
                pass
            elif token in [VtlParser.RANGE]:
                self.state = 1150
                self.match(VtlParser.RANGE)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1153
            self.match(VtlParser.BETWEEN)
            self.state = 1154
            self.limitClauseItem()
            self.state = 1155
            self.match(VtlParser.AND)
            self.state = 1156
            self.limitClauseItem()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LimitClauseItemContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTEGER_CONSTANT(self):
            return self.getToken(VtlParser.INTEGER_CONSTANT, 0)

        def PRECEDING(self):
            return self.getToken(VtlParser.PRECEDING, 0)

        def FOLLOWING(self):
            return self.getToken(VtlParser.FOLLOWING, 0)

        def CURRENT(self):
            return self.getToken(VtlParser.CURRENT, 0)

        def DATA(self):
            return self.getToken(VtlParser.DATA, 0)

        def POINT(self):
            return self.getToken(VtlParser.POINT, 0)

        def UNBOUNDED(self):
            return self.getToken(VtlParser.UNBOUNDED, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_limitClauseItem

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLimitClauseItem"):
                listener.enterLimitClauseItem(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLimitClauseItem"):
                listener.exitLimitClauseItem(self)

    def limitClauseItem(self):

        localctx = VtlParser.LimitClauseItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_limitClauseItem)
        try:
            self.state = 1169
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 106, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1158
                self.match(VtlParser.INTEGER_CONSTANT)
                self.state = 1159
                self.match(VtlParser.PRECEDING)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1160
                self.match(VtlParser.INTEGER_CONSTANT)
                self.state = 1161
                self.match(VtlParser.FOLLOWING)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1162
                self.match(VtlParser.CURRENT)
                self.state = 1163
                self.match(VtlParser.DATA)
                self.state = 1164
                self.match(VtlParser.POINT)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1165
                self.match(VtlParser.UNBOUNDED)
                self.state = 1166
                self.match(VtlParser.PRECEDING)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1167
                self.match(VtlParser.UNBOUNDED)
                self.state = 1168
                self.match(VtlParser.FOLLOWING)
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class JoinExprContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def joinKeyword(self):
            return self.getTypedRuleContext(VtlParser.JoinKeywordContext, 0)

        def joinClause(self):
            return self.getTypedRuleContext(VtlParser.JoinClauseContext, 0)

        def joinBody(self):
            return self.getTypedRuleContext(VtlParser.JoinBodyContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_joinExpr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterJoinExpr"):
                listener.enterJoinExpr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitJoinExpr"):
                listener.exitJoinExpr(self)

    def joinExpr(self):

        localctx = VtlParser.JoinExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_joinExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1171
            self.joinKeyword()
            self.state = 1172
            self.match(VtlParser.T__12)
            self.state = 1173
            self.joinClause()
            self.state = 1175
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 107, self._ctx)
            if la_ == 1:
                self.state = 1174
                self.joinBody()

            self.state = 1177
            self.match(VtlParser.T__13)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class JoinClauseContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ExprContext)
            else:
                return self.getTypedRuleContext(VtlParser.ExprContext, i)

        def AS(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.AS)
            else:
                return self.getToken(VtlParser.AS, i)

        def IDENTIFIER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.IDENTIFIER)
            else:
                return self.getToken(VtlParser.IDENTIFIER, i)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def USING(self):
            return self.getToken(VtlParser.USING, 0)

        def componentID(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ComponentIDContext)
            else:
                return self.getTypedRuleContext(VtlParser.ComponentIDContext, i)

        def getRuleIndex(self):
            return VtlParser.RULE_joinClause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterJoinClause"):
                listener.enterJoinClause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitJoinClause"):
                listener.exitJoinClause(self)

    def joinClause(self):

        localctx = VtlParser.JoinClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_joinClause)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1179
            self.expr(0)
            self.state = 1182
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.AS:
                self.state = 1180
                self.match(VtlParser.AS)
                self.state = 1181
                self.match(VtlParser.IDENTIFIER)

            self.state = 1192
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == VtlParser.CARTESIAN_PER:
                self.state = 1184
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 1185
                self.expr(0)
                self.state = 1188
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == VtlParser.AS:
                    self.state = 1186
                    self.match(VtlParser.AS)
                    self.state = 1187
                    self.match(VtlParser.IDENTIFIER)

                self.state = 1194
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1204
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.USING:
                self.state = 1195
                self.match(VtlParser.USING)
                self.state = 1196
                self.componentID()
                self.state = 1201
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == VtlParser.CARTESIAN_PER:
                    self.state = 1197
                    self.match(VtlParser.CARTESIAN_PER)
                    self.state = 1198
                    self.componentID()
                    self.state = 1203
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class JoinBodyContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def joinFilterClause(self):
            return self.getTypedRuleContext(VtlParser.JoinFilterClauseContext, 0)

        def joinCalcClause(self):
            return self.getTypedRuleContext(VtlParser.JoinCalcClauseContext, 0)

        def joinApplyClause(self):
            return self.getTypedRuleContext(VtlParser.JoinApplyClauseContext, 0)

        def joinAggClause(self):
            return self.getTypedRuleContext(VtlParser.JoinAggClauseContext, 0)

        def joinKeepClause(self):
            return self.getTypedRuleContext(VtlParser.JoinKeepClauseContext, 0)

        def joinDropClause(self):
            return self.getTypedRuleContext(VtlParser.JoinDropClauseContext, 0)

        def joinRenameClause(self):
            return self.getTypedRuleContext(VtlParser.JoinRenameClauseContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_joinBody

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterJoinBody"):
                listener.enterJoinBody(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitJoinBody"):
                listener.exitJoinBody(self)

    def joinBody(self):

        localctx = VtlParser.JoinBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_joinBody)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1207
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.FILTER or _la == VtlParser.IDENTIFIER:
                self.state = 1206
                self.joinFilterClause()

            self.state = 1212
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 114, self._ctx)
            if la_ == 1:
                self.state = 1209
                self.joinCalcClause()

            elif la_ == 2:
                self.state = 1210
                self.joinApplyClause()

            elif la_ == 3:
                self.state = 1211
                self.joinAggClause()

            self.state = 1216
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [VtlParser.KEEP]:
                self.state = 1214
                self.joinKeepClause()
                pass
            elif token in [VtlParser.DROP]:
                self.state = 1215
                self.joinDropClause()
                pass
            elif token in [VtlParser.T__13, VtlParser.RENAME]:
                pass
            else:
                pass
            self.state = 1219
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.RENAME:
                self.state = 1218
                self.joinRenameClause()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class JoinCalcClauseContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def joinCalcClauseItem(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.JoinCalcClauseItemContext)
            else:
                return self.getTypedRuleContext(VtlParser.JoinCalcClauseItemContext, i)

        def componentRole(self):
            return self.getTypedRuleContext(VtlParser.ComponentRoleContext, 0)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def getRuleIndex(self):
            return VtlParser.RULE_joinCalcClause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterJoinCalcClause"):
                listener.enterJoinCalcClause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitJoinCalcClause"):
                listener.exitJoinCalcClause(self)

    def joinCalcClause(self):

        localctx = VtlParser.JoinCalcClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_joinCalcClause)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1222
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (
                (((_la - 102)) & ~0x3F) == 0
                and (
                    (1 << (_la - 102))
                    & (
                        (1 << (VtlParser.DIMENSION - 102))
                        | (1 << (VtlParser.MEASURE - 102))
                        | (1 << (VtlParser.ATTRIBUTE - 102))
                        | (1 << (VtlParser.VIRAL - 102))
                    )
                )
                != 0
            ) or _la == VtlParser.COMPONENT:
                self.state = 1221
                self.componentRole()

            self.state = 1224
            self.joinCalcClauseItem()
            self.state = 1229
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == VtlParser.CARTESIAN_PER:
                self.state = 1225
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 1226
                self.joinCalcClauseItem()
                self.state = 1231
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class JoinCalcClauseItemContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CALC(self):
            return self.getToken(VtlParser.CALC, 0)

        def joinCalcExpr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.JoinCalcExprContext)
            else:
                return self.getTypedRuleContext(VtlParser.JoinCalcExprContext, i)

        def componentRole(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ComponentRoleContext)
            else:
                return self.getTypedRuleContext(VtlParser.ComponentRoleContext, i)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def getRuleIndex(self):
            return VtlParser.RULE_joinCalcClauseItem

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterJoinCalcClauseItem"):
                listener.enterJoinCalcClauseItem(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitJoinCalcClauseItem"):
                listener.exitJoinCalcClauseItem(self)

    def joinCalcClauseItem(self):

        localctx = VtlParser.JoinCalcClauseItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_joinCalcClauseItem)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1232
            self.match(VtlParser.CALC)
            self.state = 1234
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (
                (((_la - 102)) & ~0x3F) == 0
                and (
                    (1 << (_la - 102))
                    & (
                        (1 << (VtlParser.DIMENSION - 102))
                        | (1 << (VtlParser.MEASURE - 102))
                        | (1 << (VtlParser.ATTRIBUTE - 102))
                        | (1 << (VtlParser.VIRAL - 102))
                    )
                )
                != 0
            ) or _la == VtlParser.COMPONENT:
                self.state = 1233
                self.componentRole()

            self.state = 1236
            self.joinCalcExpr()
            self.state = 1244
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 121, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1237
                    self.match(VtlParser.CARTESIAN_PER)
                    self.state = 1239
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if (
                        (((_la - 102)) & ~0x3F) == 0
                        and (
                            (1 << (_la - 102))
                            & (
                                (1 << (VtlParser.DIMENSION - 102))
                                | (1 << (VtlParser.MEASURE - 102))
                                | (1 << (VtlParser.ATTRIBUTE - 102))
                                | (1 << (VtlParser.VIRAL - 102))
                            )
                        )
                        != 0
                    ) or _la == VtlParser.COMPONENT:
                        self.state = 1238
                        self.componentRole()

                    self.state = 1241
                    self.joinCalcExpr()
                self.state = 1246
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 121, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class JoinCalcExprContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def componentID(self):
            return self.getTypedRuleContext(VtlParser.ComponentIDContext, 0)

        def ASSIGN(self):
            return self.getToken(VtlParser.ASSIGN, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_joinCalcExpr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterJoinCalcExpr"):
                listener.enterJoinCalcExpr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitJoinCalcExpr"):
                listener.exitJoinCalcExpr(self)

    def joinCalcExpr(self):

        localctx = VtlParser.JoinCalcExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_joinCalcExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1247
            self.componentID()
            self.state = 1248
            self.match(VtlParser.ASSIGN)
            self.state = 1249
            self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class JoinAggClauseContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AGGREGATE(self):
            return self.getToken(VtlParser.AGGREGATE, 0)

        def joinAggClauseItem(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.JoinAggClauseItemContext)
            else:
                return self.getTypedRuleContext(VtlParser.JoinAggClauseItemContext, i)

        def componentRole(self):
            return self.getTypedRuleContext(VtlParser.ComponentRoleContext, 0)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def groupingClause(self):
            return self.getTypedRuleContext(VtlParser.GroupingClauseContext, 0)

        def havingClause(self):
            return self.getTypedRuleContext(VtlParser.HavingClauseContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_joinAggClause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterJoinAggClause"):
                listener.enterJoinAggClause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitJoinAggClause"):
                listener.exitJoinAggClause(self)

    def joinAggClause(self):

        localctx = VtlParser.JoinAggClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_joinAggClause)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1252
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (
                (((_la - 102)) & ~0x3F) == 0
                and (
                    (1 << (_la - 102))
                    & (
                        (1 << (VtlParser.DIMENSION - 102))
                        | (1 << (VtlParser.MEASURE - 102))
                        | (1 << (VtlParser.ATTRIBUTE - 102))
                        | (1 << (VtlParser.VIRAL - 102))
                    )
                )
                != 0
            ) or _la == VtlParser.COMPONENT:
                self.state = 1251
                self.componentRole()

            self.state = 1254
            self.match(VtlParser.AGGREGATE)
            self.state = 1255
            self.joinAggClauseItem()
            self.state = 1260
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == VtlParser.CARTESIAN_PER:
                self.state = 1256
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 1257
                self.joinAggClauseItem()
                self.state = 1262
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1264
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.GROUP:
                self.state = 1263
                self.groupingClause()

            self.state = 1267
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.HAVING:
                self.state = 1266
                self.havingClause()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class JoinAggClauseItemContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def joinAggExpr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.JoinAggExprContext)
            else:
                return self.getTypedRuleContext(VtlParser.JoinAggExprContext, i)

        def componentRole(self):
            return self.getTypedRuleContext(VtlParser.ComponentRoleContext, 0)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def getRuleIndex(self):
            return VtlParser.RULE_joinAggClauseItem

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterJoinAggClauseItem"):
                listener.enterJoinAggClauseItem(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitJoinAggClauseItem"):
                listener.exitJoinAggClauseItem(self)

    def joinAggClauseItem(self):

        localctx = VtlParser.JoinAggClauseItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_joinAggClauseItem)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1270
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (
                (((_la - 102)) & ~0x3F) == 0
                and (
                    (1 << (_la - 102))
                    & (
                        (1 << (VtlParser.DIMENSION - 102))
                        | (1 << (VtlParser.MEASURE - 102))
                        | (1 << (VtlParser.ATTRIBUTE - 102))
                        | (1 << (VtlParser.VIRAL - 102))
                    )
                )
                != 0
            ) or _la == VtlParser.COMPONENT:
                self.state = 1269
                self.componentRole()

            self.state = 1272
            self.joinAggExpr()
            self.state = 1277
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 127, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1273
                    self.match(VtlParser.CARTESIAN_PER)
                    self.state = 1274
                    self.joinAggExpr()
                self.state = 1279
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 127, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class JoinAggExprContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def componentID(self):
            return self.getTypedRuleContext(VtlParser.ComponentIDContext, 0)

        def ASSIGN(self):
            return self.getToken(VtlParser.ASSIGN, 0)

        def aggrFunction(self):
            return self.getTypedRuleContext(VtlParser.AggrFunctionContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_joinAggExpr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterJoinAggExpr"):
                listener.enterJoinAggExpr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitJoinAggExpr"):
                listener.exitJoinAggExpr(self)

    def joinAggExpr(self):

        localctx = VtlParser.JoinAggExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_joinAggExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1280
            self.componentID()
            self.state = 1281
            self.match(VtlParser.ASSIGN)
            self.state = 1282
            self.aggrFunction()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class JoinKeepClauseContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KEEP(self):
            return self.getToken(VtlParser.KEEP, 0)

        def keepClauseItem(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.KeepClauseItemContext)
            else:
                return self.getTypedRuleContext(VtlParser.KeepClauseItemContext, i)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def getRuleIndex(self):
            return VtlParser.RULE_joinKeepClause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterJoinKeepClause"):
                listener.enterJoinKeepClause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitJoinKeepClause"):
                listener.exitJoinKeepClause(self)

    def joinKeepClause(self):

        localctx = VtlParser.JoinKeepClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_joinKeepClause)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1284
            self.match(VtlParser.KEEP)
            self.state = 1285
            self.keepClauseItem()
            self.state = 1290
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == VtlParser.CARTESIAN_PER:
                self.state = 1286
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 1287
                self.keepClauseItem()
                self.state = 1292
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class JoinDropClauseContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DROP(self):
            return self.getToken(VtlParser.DROP, 0)

        def dropClauseItem(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.DropClauseItemContext)
            else:
                return self.getTypedRuleContext(VtlParser.DropClauseItemContext, i)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def getRuleIndex(self):
            return VtlParser.RULE_joinDropClause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterJoinDropClause"):
                listener.enterJoinDropClause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitJoinDropClause"):
                listener.exitJoinDropClause(self)

    def joinDropClause(self):

        localctx = VtlParser.JoinDropClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_joinDropClause)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1293
            self.match(VtlParser.DROP)
            self.state = 1294
            self.dropClauseItem()
            self.state = 1299
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == VtlParser.CARTESIAN_PER:
                self.state = 1295
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 1296
                self.dropClauseItem()
                self.state = 1301
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class JoinFilterClauseContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FILTER(self):
            return self.getToken(VtlParser.FILTER, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def rulesetID(self):
            return self.getTypedRuleContext(VtlParser.RulesetIDContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_joinFilterClause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterJoinFilterClause"):
                listener.enterJoinFilterClause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitJoinFilterClause"):
                listener.exitJoinFilterClause(self)

    def joinFilterClause(self):

        localctx = VtlParser.JoinFilterClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_joinFilterClause)
        try:
            self.state = 1305
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [VtlParser.FILTER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1302
                self.match(VtlParser.FILTER)
                self.state = 1303
                self.expr(0)
                pass
            elif token in [VtlParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1304
                self.rulesetID()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class JoinRenameClauseContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RENAME(self):
            return self.getToken(VtlParser.RENAME, 0)

        def varID(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.VarIDContext)
            else:
                return self.getTypedRuleContext(VtlParser.VarIDContext, i)

        def TO(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.TO)
            else:
                return self.getToken(VtlParser.TO, i)

        def componentID(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ComponentIDContext)
            else:
                return self.getTypedRuleContext(VtlParser.ComponentIDContext, i)

        def MEMBERSHIP(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.MEMBERSHIP)
            else:
                return self.getToken(VtlParser.MEMBERSHIP, i)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def getRuleIndex(self):
            return VtlParser.RULE_joinRenameClause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterJoinRenameClause"):
                listener.enterJoinRenameClause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitJoinRenameClause"):
                listener.exitJoinRenameClause(self)

    def joinRenameClause(self):

        localctx = VtlParser.JoinRenameClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_joinRenameClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1307
            self.match(VtlParser.RENAME)
            self.state = 1311
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 131, self._ctx)
            if la_ == 1:
                self.state = 1308
                self.componentID()
                self.state = 1309
                self.match(VtlParser.MEMBERSHIP)

            self.state = 1313
            self.varID()
            self.state = 1314
            self.match(VtlParser.TO)
            self.state = 1318
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 132, self._ctx)
            if la_ == 1:
                self.state = 1315
                self.componentID()
                self.state = 1316
                self.match(VtlParser.MEMBERSHIP)

            self.state = 1320
            self.varID()
            self.state = 1338
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 135, self._ctx)
            while _alt != 1 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1 + 1:
                    self.state = 1321
                    self.match(VtlParser.CARTESIAN_PER)
                    self.state = 1325
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input, 133, self._ctx)
                    if la_ == 1:
                        self.state = 1322
                        self.componentID()
                        self.state = 1323
                        self.match(VtlParser.MEMBERSHIP)

                    self.state = 1327
                    self.varID()
                    self.state = 1328
                    self.match(VtlParser.TO)
                    self.state = 1332
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input, 134, self._ctx)
                    if la_ == 1:
                        self.state = 1329
                        self.componentID()
                        self.state = 1330
                        self.match(VtlParser.MEMBERSHIP)

                    self.state = 1334
                    self.varID()
                self.state = 1340
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 135, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class JoinApplyClauseContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def APPLY(self):
            return self.getToken(VtlParser.APPLY, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_joinApplyClause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterJoinApplyClause"):
                listener.enterJoinApplyClause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitJoinApplyClause"):
                listener.exitJoinApplyClause(self)

    def joinApplyClause(self):

        localctx = VtlParser.JoinApplyClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_joinApplyClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1341
            self.match(VtlParser.APPLY)
            self.state = 1342
            self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AnFunctionContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FIRST_VALUE(self):
            return self.getToken(VtlParser.FIRST_VALUE, 0)

        def LAG(self):
            return self.getToken(VtlParser.LAG, 0)

        def LAST_VALUE(self):
            return self.getToken(VtlParser.LAST_VALUE, 0)

        def RANK(self):
            return self.getToken(VtlParser.RANK, 0)

        def RATIO_TO_REPORT(self):
            return self.getToken(VtlParser.RATIO_TO_REPORT, 0)

        def LEAD(self):
            return self.getToken(VtlParser.LEAD, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_anFunction

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAnFunction"):
                listener.enterAnFunction(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAnFunction"):
                listener.exitAnFunction(self)

    def anFunction(self):

        localctx = VtlParser.AnFunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_anFunction)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1344
            _la = self._input.LA(1)
            if not (
                _la == VtlParser.RANK
                or (
                    (((_la - 146)) & ~0x3F) == 0
                    and (
                        (1 << (_la - 146))
                        & (
                            (1 << (VtlParser.FIRST_VALUE - 146))
                            | (1 << (VtlParser.LAST_VALUE - 146))
                            | (1 << (VtlParser.LAG - 146))
                            | (1 << (VtlParser.LEAD - 146))
                            | (1 << (VtlParser.RATIO_TO_REPORT - 146))
                        )
                    )
                    != 0
                )
            ):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AggregateClauseContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def aggrFunctionClause(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.AggrFunctionClauseContext)
            else:
                return self.getTypedRuleContext(VtlParser.AggrFunctionClauseContext, i)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def getRuleIndex(self):
            return VtlParser.RULE_aggregateClause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAggregateClause"):
                listener.enterAggregateClause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAggregateClause"):
                listener.exitAggregateClause(self)

    def aggregateClause(self):

        localctx = VtlParser.AggregateClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_aggregateClause)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1346
            self.aggrFunctionClause()
            self.state = 1351
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == VtlParser.CARTESIAN_PER:
                self.state = 1347
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 1348
                self.aggrFunctionClause()
                self.state = 1353
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AggrFunctionClauseContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def componentID(self):
            return self.getTypedRuleContext(VtlParser.ComponentIDContext, 0)

        def ASSIGN(self):
            return self.getToken(VtlParser.ASSIGN, 0)

        def aggrFunction(self):
            return self.getTypedRuleContext(VtlParser.AggrFunctionContext, 0)

        def componentRole(self):
            return self.getTypedRuleContext(VtlParser.ComponentRoleContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_aggrFunctionClause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAggrFunctionClause"):
                listener.enterAggrFunctionClause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAggrFunctionClause"):
                listener.exitAggrFunctionClause(self)

    def aggrFunctionClause(self):

        localctx = VtlParser.AggrFunctionClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_aggrFunctionClause)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1355
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (
                (((_la - 102)) & ~0x3F) == 0
                and (
                    (1 << (_la - 102))
                    & (
                        (1 << (VtlParser.DIMENSION - 102))
                        | (1 << (VtlParser.MEASURE - 102))
                        | (1 << (VtlParser.ATTRIBUTE - 102))
                        | (1 << (VtlParser.VIRAL - 102))
                    )
                )
                != 0
            ) or _la == VtlParser.COMPONENT:
                self.state = 1354
                self.componentRole()

            self.state = 1357
            self.componentID()
            self.state = 1358
            self.match(VtlParser.ASSIGN)
            self.state = 1359
            self.aggrFunction()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class GetFiltersClauseContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def getFilterClause(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.GetFilterClauseContext)
            else:
                return self.getTypedRuleContext(VtlParser.GetFilterClauseContext, i)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def getRuleIndex(self):
            return VtlParser.RULE_getFiltersClause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterGetFiltersClause"):
                listener.enterGetFiltersClause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitGetFiltersClause"):
                listener.exitGetFiltersClause(self)

    def getFiltersClause(self):

        localctx = VtlParser.GetFiltersClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_getFiltersClause)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1361
            self.getFilterClause()
            self.state = 1366
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == VtlParser.CARTESIAN_PER:
                self.state = 1362
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 1363
                self.getFilterClause()
                self.state = 1368
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class GetFilterClauseContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def FILTER(self):
            return self.getToken(VtlParser.FILTER, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_getFilterClause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterGetFilterClause"):
                listener.enterGetFilterClause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitGetFilterClause"):
                listener.exitGetFilterClause(self)

    def getFilterClause(self):

        localctx = VtlParser.GetFilterClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_getFilterClause)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1370
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.FILTER:
                self.state = 1369
                self.match(VtlParser.FILTER)

            self.state = 1372
            self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AggrClauseContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AGGREGATE(self):
            return self.getToken(VtlParser.AGGREGATE, 0)

        def aggregateClause(self):
            return self.getTypedRuleContext(VtlParser.AggregateClauseContext, 0)

        def groupingClause(self):
            return self.getTypedRuleContext(VtlParser.GroupingClauseContext, 0)

        def havingClause(self):
            return self.getTypedRuleContext(VtlParser.HavingClauseContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_aggrClause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAggrClause"):
                listener.enterAggrClause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAggrClause"):
                listener.exitAggrClause(self)

    def aggrClause(self):

        localctx = VtlParser.AggrClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_aggrClause)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1374
            self.match(VtlParser.AGGREGATE)
            self.state = 1375
            self.aggregateClause()
            self.state = 1377
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.GROUP:
                self.state = 1376
                self.groupingClause()

            self.state = 1380
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.HAVING:
                self.state = 1379
                self.havingClause()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FilterClauseContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FILTER(self):
            return self.getToken(VtlParser.FILTER, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_filterClause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFilterClause"):
                listener.enterFilterClause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFilterClause"):
                listener.exitFilterClause(self)

    def filterClause(self):

        localctx = VtlParser.FilterClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_filterClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1382
            self.match(VtlParser.FILTER)
            self.state = 1383
            self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RenameClauseContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def varID(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.VarIDContext)
            else:
                return self.getTypedRuleContext(VtlParser.VarIDContext, i)

        def TO(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.TO)
            else:
                return self.getToken(VtlParser.TO, i)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def getRuleIndex(self):
            return VtlParser.RULE_renameClause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRenameClause"):
                listener.enterRenameClause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRenameClause"):
                listener.exitRenameClause(self)

    def renameClause(self):

        localctx = VtlParser.RenameClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_renameClause)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1385
            self.varID()
            self.state = 1386
            self.match(VtlParser.TO)
            self.state = 1387
            self.varID()
            self.state = 1395
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == VtlParser.CARTESIAN_PER:
                self.state = 1388
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 1389
                self.varID()
                self.state = 1390
                self.match(VtlParser.TO)
                self.state = 1391
                self.varID()
                self.state = 1397
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AggrFunctionContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SUM(self):
            return self.getToken(VtlParser.SUM, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def AVG(self):
            return self.getToken(VtlParser.AVG, 0)

        def COUNT(self):
            return self.getToken(VtlParser.COUNT, 0)

        def MEDIAN(self):
            return self.getToken(VtlParser.MEDIAN, 0)

        def MIN(self):
            return self.getToken(VtlParser.MIN, 0)

        def MAX(self):
            return self.getToken(VtlParser.MAX, 0)

        def RANK(self):
            return self.getToken(VtlParser.RANK, 0)

        def STDDEV_POP(self):
            return self.getToken(VtlParser.STDDEV_POP, 0)

        def STDDEV_SAMP(self):
            return self.getToken(VtlParser.STDDEV_SAMP, 0)

        def VAR_POP(self):
            return self.getToken(VtlParser.VAR_POP, 0)

        def VAR_SAMP(self):
            return self.getToken(VtlParser.VAR_SAMP, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_aggrFunction

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAggrFunction"):
                listener.enterAggrFunction(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAggrFunction"):
                listener.exitAggrFunction(self)

    def aggrFunction(self):

        localctx = VtlParser.AggrFunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_aggrFunction)
        self._la = 0  # Token type
        try:
            self.state = 1454
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [VtlParser.SUM]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1398
                self.match(VtlParser.SUM)
                self.state = 1399
                self.match(VtlParser.T__12)
                self.state = 1400
                self.expr(0)
                self.state = 1401
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.AVG]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1403
                self.match(VtlParser.AVG)
                self.state = 1404
                self.match(VtlParser.T__12)
                self.state = 1405
                self.expr(0)
                self.state = 1406
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.COUNT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1408
                self.match(VtlParser.COUNT)
                self.state = 1409
                self.match(VtlParser.T__12)
                self.state = 1411
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (
                    (
                        ((_la) & ~0x3F) == 0
                        and (
                            (1 << _la)
                            & (
                                (1 << VtlParser.T__2)
                                | (1 << VtlParser.T__3)
                                | (1 << VtlParser.T__12)
                                | (1 << VtlParser.EVAL)
                                | (1 << VtlParser.IF)
                                | (1 << VtlParser.CASE)
                                | (1 << VtlParser.CURRENT_DATE)
                                | (1 << VtlParser.DATEDIFF)
                                | (1 << VtlParser.DATEADD)
                                | (1 << VtlParser.YEAR_OP)
                                | (1 << VtlParser.MONTH_OP)
                                | (1 << VtlParser.DAYOFMONTH)
                                | (1 << VtlParser.DAYOFYEAR)
                                | (1 << VtlParser.DAYTOYEAR)
                                | (1 << VtlParser.DAYTOMONTH)
                                | (1 << VtlParser.YEARTODAY)
                                | (1 << VtlParser.MONTHTODAY)
                                | (1 << VtlParser.NOT)
                                | (1 << VtlParser.BETWEEN)
                                | (1 << VtlParser.ISNULL)
                                | (1 << VtlParser.UNION)
                                | (1 << VtlParser.SYMDIFF)
                                | (1 << VtlParser.INTERSECT)
                                | (1 << VtlParser.RANDOM)
                            )
                        )
                        != 0
                    )
                    or (
                        (((_la - 65)) & ~0x3F) == 0
                        and (
                            (1 << (_la - 65))
                            & (
                                (1 << (VtlParser.CHECK - 65))
                                | (1 << (VtlParser.EXISTS_IN - 65))
                                | (1 << (VtlParser.RANK - 65))
                                | (1 << (VtlParser.MIN - 65))
                                | (1 << (VtlParser.MAX - 65))
                                | (1 << (VtlParser.ABS - 65))
                                | (1 << (VtlParser.LN - 65))
                                | (1 << (VtlParser.LOG - 65))
                                | (1 << (VtlParser.TRUNC - 65))
                                | (1 << (VtlParser.ROUND - 65))
                                | (1 << (VtlParser.POWER - 65))
                                | (1 << (VtlParser.MOD - 65))
                                | (1 << (VtlParser.LEN - 65))
                                | (1 << (VtlParser.TRIM - 65))
                                | (1 << (VtlParser.UCASE - 65))
                                | (1 << (VtlParser.LCASE - 65))
                                | (1 << (VtlParser.SUBSTR - 65))
                                | (1 << (VtlParser.SUM - 65))
                                | (1 << (VtlParser.AVG - 65))
                                | (1 << (VtlParser.MEDIAN - 65))
                                | (1 << (VtlParser.COUNT - 65))
                                | (1 << (VtlParser.EXP - 65))
                                | (1 << (VtlParser.CHARSET_MATCH - 65))
                                | (1 << (VtlParser.NVL - 65))
                                | (1 << (VtlParser.HIERARCHY - 65))
                                | (1 << (VtlParser.DEFINE - 65))
                            )
                        )
                        != 0
                    )
                    or (
                        (((_la - 130)) & ~0x3F) == 0
                        and (
                            (1 << (_la - 130))
                            & (
                                (1 << (VtlParser.LTRIM - 130))
                                | (1 << (VtlParser.RTRIM - 130))
                                | (1 << (VtlParser.INSTR - 130))
                                | (1 << (VtlParser.REPLACE - 130))
                                | (1 << (VtlParser.CEIL - 130))
                                | (1 << (VtlParser.FLOOR - 130))
                                | (1 << (VtlParser.SQRT - 130))
                                | (1 << (VtlParser.SETDIFF - 130))
                                | (1 << (VtlParser.STDDEV_POP - 130))
                                | (1 << (VtlParser.STDDEV_SAMP - 130))
                                | (1 << (VtlParser.VAR_POP - 130))
                                | (1 << (VtlParser.VAR_SAMP - 130))
                                | (1 << (VtlParser.FIRST_VALUE - 130))
                                | (1 << (VtlParser.LAST_VALUE - 130))
                                | (1 << (VtlParser.LAG - 130))
                                | (1 << (VtlParser.LEAD - 130))
                                | (1 << (VtlParser.RATIO_TO_REPORT - 130))
                                | (1 << (VtlParser.FILL_TIME_SERIES - 130))
                                | (1 << (VtlParser.FLOW_TO_STOCK - 130))
                                | (1 << (VtlParser.STOCK_TO_FLOW - 130))
                                | (1 << (VtlParser.TIMESHIFT - 130))
                                | (1 << (VtlParser.INNER_JOIN - 130))
                                | (1 << (VtlParser.LEFT_JOIN - 130))
                                | (1 << (VtlParser.CROSS_JOIN - 130))
                            )
                        )
                        != 0
                    )
                    or (
                        (((_la - 194)) & ~0x3F) == 0
                        and (
                            (1 << (_la - 194))
                            & (
                                (1 << (VtlParser.FULL_JOIN - 194))
                                | (1 << (VtlParser.PERIOD_INDICATOR - 194))
                                | (1 << (VtlParser.TIME_AGG - 194))
                                | (1 << (VtlParser.CAST - 194))
                                | (1 << (VtlParser.CHECK_DATAPOINT - 194))
                                | (1 << (VtlParser.CHECK_HIERARCHY - 194))
                                | (1 << (VtlParser.INTEGER_CONSTANT - 194))
                                | (1 << (VtlParser.FLOAT_CONSTANT - 194))
                                | (1 << (VtlParser.BOOLEAN_CONSTANT - 194))
                                | (1 << (VtlParser.NULL_CONSTANT - 194))
                                | (1 << (VtlParser.STRING_CONSTANT - 194))
                                | (1 << (VtlParser.IDENTIFIER - 194))
                            )
                        )
                        != 0
                    )
                ):
                    self.state = 1410
                    self.expr(0)

                self.state = 1413
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.MEDIAN]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1414
                self.match(VtlParser.MEDIAN)
                self.state = 1415
                self.match(VtlParser.T__12)
                self.state = 1416
                self.expr(0)
                self.state = 1417
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.MIN]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1419
                self.match(VtlParser.MIN)
                self.state = 1420
                self.match(VtlParser.T__12)
                self.state = 1421
                self.expr(0)
                self.state = 1422
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.MAX]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1424
                self.match(VtlParser.MAX)
                self.state = 1425
                self.match(VtlParser.T__12)
                self.state = 1426
                self.expr(0)
                self.state = 1427
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.RANK]:
                self.enterOuterAlt(localctx, 7)
                self.state = 1429
                self.match(VtlParser.RANK)
                self.state = 1430
                self.match(VtlParser.T__12)
                self.state = 1431
                self.expr(0)
                self.state = 1432
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.STDDEV_POP]:
                self.enterOuterAlt(localctx, 8)
                self.state = 1434
                self.match(VtlParser.STDDEV_POP)
                self.state = 1435
                self.match(VtlParser.T__12)
                self.state = 1436
                self.expr(0)
                self.state = 1437
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.STDDEV_SAMP]:
                self.enterOuterAlt(localctx, 9)
                self.state = 1439
                self.match(VtlParser.STDDEV_SAMP)
                self.state = 1440
                self.match(VtlParser.T__12)
                self.state = 1441
                self.expr(0)
                self.state = 1442
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.VAR_POP]:
                self.enterOuterAlt(localctx, 10)
                self.state = 1444
                self.match(VtlParser.VAR_POP)
                self.state = 1445
                self.match(VtlParser.T__12)
                self.state = 1446
                self.expr(0)
                self.state = 1447
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.VAR_SAMP]:
                self.enterOuterAlt(localctx, 11)
                self.state = 1449
                self.match(VtlParser.VAR_SAMP)
                self.state = 1450
                self.match(VtlParser.T__12)
                self.state = 1451
                self.expr(0)
                self.state = 1452
                self.match(VtlParser.T__13)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CalcClauseContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CALC(self):
            return self.getToken(VtlParser.CALC, 0)

        def calcClauseItem(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.CalcClauseItemContext)
            else:
                return self.getTypedRuleContext(VtlParser.CalcClauseItemContext, i)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def getRuleIndex(self):
            return VtlParser.RULE_calcClause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCalcClause"):
                listener.enterCalcClause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCalcClause"):
                listener.exitCalcClause(self)

    def calcClause(self):

        localctx = VtlParser.CalcClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_calcClause)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1456
            self.match(VtlParser.CALC)
            self.state = 1457
            self.calcClauseItem()
            self.state = 1462
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == VtlParser.CARTESIAN_PER:
                self.state = 1458
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 1459
                self.calcClauseItem()
                self.state = 1464
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CalcClauseItemContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def componentID(self):
            return self.getTypedRuleContext(VtlParser.ComponentIDContext, 0)

        def ASSIGN(self):
            return self.getToken(VtlParser.ASSIGN, 0)

        def calcExpr(self):
            return self.getTypedRuleContext(VtlParser.CalcExprContext, 0)

        def componentRole(self):
            return self.getTypedRuleContext(VtlParser.ComponentRoleContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_calcClauseItem

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCalcClauseItem"):
                listener.enterCalcClauseItem(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCalcClauseItem"):
                listener.exitCalcClauseItem(self)

    def calcClauseItem(self):

        localctx = VtlParser.CalcClauseItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_calcClauseItem)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1466
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (
                (((_la - 102)) & ~0x3F) == 0
                and (
                    (1 << (_la - 102))
                    & (
                        (1 << (VtlParser.DIMENSION - 102))
                        | (1 << (VtlParser.MEASURE - 102))
                        | (1 << (VtlParser.ATTRIBUTE - 102))
                        | (1 << (VtlParser.VIRAL - 102))
                    )
                )
                != 0
            ) or _la == VtlParser.COMPONENT:
                self.state = 1465
                self.componentRole()

            self.state = 1468
            self.componentID()
            self.state = 1469
            self.match(VtlParser.ASSIGN)
            self.state = 1470
            self.calcExpr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CalcExprContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def aggrFunction(self):
            return self.getTypedRuleContext(VtlParser.AggrFunctionContext, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_calcExpr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCalcExpr"):
                listener.enterCalcExpr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCalcExpr"):
                listener.exitCalcExpr(self)

    def calcExpr(self):

        localctx = VtlParser.CalcExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_calcExpr)
        try:
            self.state = 1478
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 147, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1472
                self.aggrFunction()
                self.state = 1473
                self.match(VtlParser.T__12)
                self.state = 1474
                self.expr(0)
                self.state = 1475
                self.match(VtlParser.T__13)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1477
                self.expr(0)
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DropClauseContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DROP(self):
            return self.getToken(VtlParser.DROP, 0)

        def dropClauseItem(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.DropClauseItemContext)
            else:
                return self.getTypedRuleContext(VtlParser.DropClauseItemContext, i)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def getRuleIndex(self):
            return VtlParser.RULE_dropClause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDropClause"):
                listener.enterDropClause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDropClause"):
                listener.exitDropClause(self)

    def dropClause(self):

        localctx = VtlParser.DropClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_dropClause)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1480
            self.match(VtlParser.DROP)
            self.state = 1481
            self.dropClauseItem()
            self.state = 1486
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == VtlParser.CARTESIAN_PER:
                self.state = 1482
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 1483
                self.dropClauseItem()
                self.state = 1488
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DropClauseItemContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def componentID(self):
            return self.getTypedRuleContext(VtlParser.ComponentIDContext, 0)

        def datasetID(self):
            return self.getTypedRuleContext(VtlParser.DatasetIDContext, 0)

        def MEMBERSHIP(self):
            return self.getToken(VtlParser.MEMBERSHIP, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_dropClauseItem

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDropClauseItem"):
                listener.enterDropClauseItem(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDropClauseItem"):
                listener.exitDropClauseItem(self)

    def dropClauseItem(self):

        localctx = VtlParser.DropClauseItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_dropClauseItem)
        try:
            self.state = 1494
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 149, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1489
                self.componentID()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1490
                self.datasetID()
                self.state = 1491
                self.match(VtlParser.MEMBERSHIP)
                self.state = 1492
                self.componentID()
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class KeepClauseContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KEEP(self):
            return self.getToken(VtlParser.KEEP, 0)

        def keepClauseItem(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.KeepClauseItemContext)
            else:
                return self.getTypedRuleContext(VtlParser.KeepClauseItemContext, i)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def getRuleIndex(self):
            return VtlParser.RULE_keepClause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterKeepClause"):
                listener.enterKeepClause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitKeepClause"):
                listener.exitKeepClause(self)

    def keepClause(self):

        localctx = VtlParser.KeepClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_keepClause)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1496
            self.match(VtlParser.KEEP)
            self.state = 1497
            self.keepClauseItem()
            self.state = 1502
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == VtlParser.CARTESIAN_PER:
                self.state = 1498
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 1499
                self.keepClauseItem()
                self.state = 1504
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class KeepClauseItemContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def componentID(self):
            return self.getTypedRuleContext(VtlParser.ComponentIDContext, 0)

        def datasetID(self):
            return self.getTypedRuleContext(VtlParser.DatasetIDContext, 0)

        def MEMBERSHIP(self):
            return self.getToken(VtlParser.MEMBERSHIP, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_keepClauseItem

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterKeepClauseItem"):
                listener.enterKeepClauseItem(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitKeepClauseItem"):
                listener.exitKeepClauseItem(self)

    def keepClauseItem(self):

        localctx = VtlParser.KeepClauseItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_keepClauseItem)
        try:
            self.state = 1510
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 151, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1505
                self.componentID()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1506
                self.datasetID()
                self.state = 1507
                self.match(VtlParser.MEMBERSHIP)
                self.state = 1508
                self.componentID()
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnpivotExprContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNPIVOT(self):
            return self.getToken(VtlParser.UNPIVOT, 0)

        def varID(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.VarIDContext)
            else:
                return self.getTypedRuleContext(VtlParser.VarIDContext, i)

        def CARTESIAN_PER(self):
            return self.getToken(VtlParser.CARTESIAN_PER, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_unpivotExpr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUnpivotExpr"):
                listener.enterUnpivotExpr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUnpivotExpr"):
                listener.exitUnpivotExpr(self)

    def unpivotExpr(self):

        localctx = VtlParser.UnpivotExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_unpivotExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1512
            self.match(VtlParser.UNPIVOT)
            self.state = 1513
            self.varID()
            self.state = 1514
            self.match(VtlParser.CARTESIAN_PER)
            self.state = 1515
            self.varID()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PivotExprContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PIVOT(self):
            return self.getToken(VtlParser.PIVOT, 0)

        def varID(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.VarIDContext)
            else:
                return self.getTypedRuleContext(VtlParser.VarIDContext, i)

        def CARTESIAN_PER(self):
            return self.getToken(VtlParser.CARTESIAN_PER, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_pivotExpr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPivotExpr"):
                listener.enterPivotExpr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPivotExpr"):
                listener.exitPivotExpr(self)

    def pivotExpr(self):

        localctx = VtlParser.PivotExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_pivotExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1517
            self.match(VtlParser.PIVOT)
            self.state = 1518
            self.varID()
            self.state = 1519
            self.match(VtlParser.CARTESIAN_PER)
            self.state = 1520
            self.varID()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SubspaceExprContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SUBSPACE(self):
            return self.getToken(VtlParser.SUBSPACE, 0)

        def varID(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.VarIDContext)
            else:
                return self.getTypedRuleContext(VtlParser.VarIDContext, i)

        def constant(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ConstantContext)
            else:
                return self.getTypedRuleContext(VtlParser.ConstantContext, i)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def getRuleIndex(self):
            return VtlParser.RULE_subspaceExpr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSubspaceExpr"):
                listener.enterSubspaceExpr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSubspaceExpr"):
                listener.exitSubspaceExpr(self)

    def subspaceExpr(self):

        localctx = VtlParser.SubspaceExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_subspaceExpr)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1522
            self.match(VtlParser.SUBSPACE)
            self.state = 1523
            self.varID()
            self.state = 1524
            self.match(VtlParser.T__10)
            self.state = 1525
            self.constant()
            self.state = 1533
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == VtlParser.CARTESIAN_PER:
                self.state = 1526
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 1527
                self.varID()
                self.state = 1528
                self.match(VtlParser.T__10)
                self.state = 1529
                self.constant()
                self.state = 1535
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InBetweenClauseContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IN(self):
            return self.getToken(VtlParser.IN, 0)

        def setExpr(self):
            return self.getTypedRuleContext(VtlParser.SetExprContext, 0)

        def IDENTIFIER(self):
            return self.getToken(VtlParser.IDENTIFIER, 0)

        def NOT_IN(self):
            return self.getToken(VtlParser.NOT_IN, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_inBetweenClause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInBetweenClause"):
                listener.enterInBetweenClause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInBetweenClause"):
                listener.exitInBetweenClause(self)

    def inBetweenClause(self):

        localctx = VtlParser.InBetweenClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_inBetweenClause)
        try:
            self.state = 1546
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [VtlParser.IN]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1536
                self.match(VtlParser.IN)
                self.state = 1539
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [
                    VtlParser.UNION,
                    VtlParser.SYMDIFF,
                    VtlParser.INTERSECT,
                    VtlParser.SETDIFF,
                ]:
                    self.state = 1537
                    self.setExpr()
                    pass
                elif token in [VtlParser.IDENTIFIER]:
                    self.state = 1538
                    self.match(VtlParser.IDENTIFIER)
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [VtlParser.NOT_IN]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1541
                self.match(VtlParser.NOT_IN)
                self.state = 1544
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [
                    VtlParser.UNION,
                    VtlParser.SYMDIFF,
                    VtlParser.INTERSECT,
                    VtlParser.SETDIFF,
                ]:
                    self.state = 1542
                    self.setExpr()
                    pass
                elif token in [VtlParser.IDENTIFIER]:
                    self.state = 1543
                    self.match(VtlParser.IDENTIFIER)
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SetExprContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNION(self):
            return self.getToken(VtlParser.UNION, 0)

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ExprContext)
            else:
                return self.getTypedRuleContext(VtlParser.ExprContext, i)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def SYMDIFF(self):
            return self.getToken(VtlParser.SYMDIFF, 0)

        def SETDIFF(self):
            return self.getToken(VtlParser.SETDIFF, 0)

        def INTERSECT(self):
            return self.getToken(VtlParser.INTERSECT, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_setExpr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSetExpr"):
                listener.enterSetExpr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSetExpr"):
                listener.exitSetExpr(self)

    def setExpr(self):

        localctx = VtlParser.SetExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_setExpr)
        self._la = 0  # Token type
        try:
            self.state = 1586
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [VtlParser.UNION]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1548
                self.match(VtlParser.UNION)
                self.state = 1549
                self.match(VtlParser.T__12)
                self.state = 1550
                self.expr(0)
                self.state = 1555
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == VtlParser.CARTESIAN_PER:
                    self.state = 1551
                    self.match(VtlParser.CARTESIAN_PER)
                    self.state = 1552
                    self.expr(0)
                    self.state = 1557
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1558
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.SYMDIFF]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1560
                self.match(VtlParser.SYMDIFF)
                self.state = 1561
                self.match(VtlParser.T__12)
                self.state = 1562
                self.expr(0)
                self.state = 1563
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 1564
                self.expr(0)
                self.state = 1565
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.SETDIFF]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1567
                self.match(VtlParser.SETDIFF)
                self.state = 1568
                self.match(VtlParser.T__12)
                self.state = 1569
                self.expr(0)
                self.state = 1570
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 1571
                self.expr(0)
                self.state = 1572
                self.match(VtlParser.T__13)
                pass
            elif token in [VtlParser.INTERSECT]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1574
                self.match(VtlParser.INTERSECT)
                self.state = 1575
                self.match(VtlParser.T__12)
                self.state = 1576
                self.expr(0)
                self.state = 1581
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == VtlParser.CARTESIAN_PER:
                    self.state = 1577
                    self.match(VtlParser.CARTESIAN_PER)
                    self.state = 1578
                    self.expr(0)
                    self.state = 1583
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1584
                self.match(VtlParser.T__13)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RandExprContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.seed = None  # ExprContext
            self.index = None  # ExprContext

        def RANDOM(self):
            return self.getToken(VtlParser.RANDOM, 0)

        def CARTESIAN_PER(self):
            return self.getToken(VtlParser.CARTESIAN_PER, 0)

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ExprContext)
            else:
                return self.getTypedRuleContext(VtlParser.ExprContext, i)

        def getRuleIndex(self):
            return VtlParser.RULE_randExpr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRandExpr"):
                listener.enterRandExpr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRandExpr"):
                listener.exitRandExpr(self)

    def randExpr(self):

        localctx = VtlParser.RandExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_randExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1588
            self.match(VtlParser.RANDOM)
            self.state = 1589
            self.match(VtlParser.T__12)
            self.state = 1590
            localctx.seed = self.expr(0)
            self.state = 1591
            self.match(VtlParser.CARTESIAN_PER)
            self.state = 1592
            localctx.index = self.expr(0)
            self.state = 1593
            self.match(VtlParser.T__13)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SubscriptExprContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def persistentDatasetID(self):
            return self.getTypedRuleContext(VtlParser.PersistentDatasetIDContext, 0)

        def componentID(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ComponentIDContext)
            else:
                return self.getTypedRuleContext(VtlParser.ComponentIDContext, i)

        def constant(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ConstantContext)
            else:
                return self.getTypedRuleContext(VtlParser.ConstantContext, i)

        def CARTESIAN_PER(self):
            return self.getToken(VtlParser.CARTESIAN_PER, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_subscriptExpr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSubscriptExpr"):
                listener.enterSubscriptExpr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSubscriptExpr"):
                listener.exitSubscriptExpr(self)

    def subscriptExpr(self):

        localctx = VtlParser.SubscriptExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_subscriptExpr)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1595
            self.persistentDatasetID()
            self.state = 1596
            self.match(VtlParser.T__0)
            self.state = 1597
            self.componentID()
            self.state = 1598
            self.match(VtlParser.T__10)
            self.state = 1599
            self.constant()
            self.state = 1605
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.CARTESIAN_PER:
                self.state = 1600
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 1601
                self.componentID()
                self.state = 1602
                self.match(VtlParser.T__10)
                self.state = 1603
                self.constant()

            self.state = 1607
            self.match(VtlParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AggrInvocationContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def aggrFunctionName(self):
            return self.getTypedRuleContext(VtlParser.AggrFunctionNameContext, 0)

        def IDENTIFIER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.IDENTIFIER)
            else:
                return self.getToken(VtlParser.IDENTIFIER, i)

        def MEMBERSHIP(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.MEMBERSHIP)
            else:
                return self.getToken(VtlParser.MEMBERSHIP, i)

        def componentID(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ComponentIDContext)
            else:
                return self.getTypedRuleContext(VtlParser.ComponentIDContext, i)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def groupingClause(self):
            return self.getTypedRuleContext(VtlParser.GroupingClauseContext, 0)

        def havingClause(self):
            return self.getTypedRuleContext(VtlParser.HavingClauseContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_aggrInvocation

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAggrInvocation"):
                listener.enterAggrInvocation(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAggrInvocation"):
                listener.exitAggrInvocation(self)

    def aggrInvocation(self):

        localctx = VtlParser.AggrInvocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_aggrInvocation)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1609
            self.aggrFunctionName()
            self.state = 1610
            self.match(VtlParser.T__12)
            self.state = 1611
            self.match(VtlParser.IDENTIFIER)
            self.state = 1614
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.MEMBERSHIP:
                self.state = 1612
                self.match(VtlParser.MEMBERSHIP)
                self.state = 1613
                self.componentID()

            self.state = 1624
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == VtlParser.CARTESIAN_PER:
                self.state = 1616
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 1617
                self.match(VtlParser.IDENTIFIER)
                self.state = 1620
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == VtlParser.MEMBERSHIP:
                    self.state = 1618
                    self.match(VtlParser.MEMBERSHIP)
                    self.state = 1619
                    self.componentID()

                self.state = 1626
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1628
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.GROUP:
                self.state = 1627
                self.groupingClause()

            self.state = 1631
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.HAVING:
                self.state = 1630
                self.havingClause()

            self.state = 1633
            self.match(VtlParser.T__13)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AggrInvocationCompExprContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def aggrFunctionName(self):
            return self.getTypedRuleContext(VtlParser.AggrFunctionNameContext, 0)

        def IDENTIFIER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.IDENTIFIER)
            else:
                return self.getToken(VtlParser.IDENTIFIER, i)

        def MEMBERSHIP(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.MEMBERSHIP)
            else:
                return self.getToken(VtlParser.MEMBERSHIP, i)

        def componentID(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ComponentIDContext)
            else:
                return self.getTypedRuleContext(VtlParser.ComponentIDContext, i)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def groupingClause(self):
            return self.getTypedRuleContext(VtlParser.GroupingClauseContext, 0)

        def havingClause(self):
            return self.getTypedRuleContext(VtlParser.HavingClauseContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_aggrInvocationCompExpr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAggrInvocationCompExpr"):
                listener.enterAggrInvocationCompExpr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAggrInvocationCompExpr"):
                listener.exitAggrInvocationCompExpr(self)

    def aggrInvocationCompExpr(self):

        localctx = VtlParser.AggrInvocationCompExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_aggrInvocationCompExpr)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1635
            self.aggrFunctionName()
            self.state = 1636
            self.match(VtlParser.T__12)
            self.state = 1637
            self.match(VtlParser.IDENTIFIER)
            self.state = 1640
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.MEMBERSHIP:
                self.state = 1638
                self.match(VtlParser.MEMBERSHIP)
                self.state = 1639
                self.componentID()

            self.state = 1650
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == VtlParser.CARTESIAN_PER:
                self.state = 1642
                self.match(VtlParser.CARTESIAN_PER)
                self.state = 1643
                self.match(VtlParser.IDENTIFIER)
                self.state = 1646
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == VtlParser.MEMBERSHIP:
                    self.state = 1644
                    self.match(VtlParser.MEMBERSHIP)
                    self.state = 1645
                    self.componentID()

                self.state = 1652
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1653
            self.match(VtlParser.T__13)
            self.state = 1655
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 168, self._ctx)
            if la_ == 1:
                self.state = 1654
                self.groupingClause()

            self.state = 1658
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 169, self._ctx)
            if la_ == 1:
                self.state = 1657
                self.havingClause()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AggrFunctionNameContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SUM(self):
            return self.getToken(VtlParser.SUM, 0)

        def AVG(self):
            return self.getToken(VtlParser.AVG, 0)

        def COUNT(self):
            return self.getToken(VtlParser.COUNT, 0)

        def MEDIAN(self):
            return self.getToken(VtlParser.MEDIAN, 0)

        def MIN(self):
            return self.getToken(VtlParser.MIN, 0)

        def MAX(self):
            return self.getToken(VtlParser.MAX, 0)

        def STDDEV_POP(self):
            return self.getToken(VtlParser.STDDEV_POP, 0)

        def STDDEV_SAMP(self):
            return self.getToken(VtlParser.STDDEV_SAMP, 0)

        def VAR_POP(self):
            return self.getToken(VtlParser.VAR_POP, 0)

        def VAR_SAMP(self):
            return self.getToken(VtlParser.VAR_SAMP, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_aggrFunctionName

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAggrFunctionName"):
                listener.enterAggrFunctionName(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAggrFunctionName"):
                listener.exitAggrFunctionName(self)

    def aggrFunctionName(self):

        localctx = VtlParser.AggrFunctionNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_aggrFunctionName)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1660
            _la = self._input.LA(1)
            if not (
                (
                    (((_la - 79)) & ~0x3F) == 0
                    and (
                        (1 << (_la - 79))
                        & (
                            (1 << (VtlParser.MIN - 79))
                            | (1 << (VtlParser.MAX - 79))
                            | (1 << (VtlParser.SUM - 79))
                            | (1 << (VtlParser.AVG - 79))
                            | (1 << (VtlParser.MEDIAN - 79))
                            | (1 << (VtlParser.COUNT - 79))
                            | (1 << (VtlParser.STDDEV_POP - 79))
                            | (1 << (VtlParser.STDDEV_SAMP - 79))
                            | (1 << (VtlParser.VAR_POP - 79))
                            | (1 << (VtlParser.VAR_SAMP - 79))
                        )
                    )
                    != 0
                )
            ):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class GroupingClauseContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def groupKeyword(self):
            return self.getTypedRuleContext(VtlParser.GroupKeywordContext, 0)

        def IDENTIFIER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.IDENTIFIER)
            else:
                return self.getToken(VtlParser.IDENTIFIER, i)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def getRuleIndex(self):
            return VtlParser.RULE_groupingClause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterGroupingClause"):
                listener.enterGroupingClause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitGroupingClause"):
                listener.exitGroupingClause(self)

    def groupingClause(self):

        localctx = VtlParser.GroupingClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_groupingClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1662
            self.groupKeyword()
            self.state = 1672
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 171, self._ctx)
            if la_ == 1:
                self.state = 1663
                self.match(VtlParser.IDENTIFIER)
                self.state = 1668
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 170, self._ctx)
                while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 1664
                        self.match(VtlParser.CARTESIAN_PER)
                        self.state = 1665
                        self.match(VtlParser.IDENTIFIER)
                    self.state = 1670
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input, 170, self._ctx)

                pass

            elif la_ == 2:
                self.state = 1671
                self.expr(0)
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class HavingClauseContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HAVING(self):
            return self.getToken(VtlParser.HAVING, 0)

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def aggrFunction(self):
            return self.getTypedRuleContext(VtlParser.AggrFunctionContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_havingClause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterHavingClause"):
                listener.enterHavingClause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitHavingClause"):
                listener.exitHavingClause(self)

    def havingClause(self):

        localctx = VtlParser.HavingClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_havingClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1674
            self.match(VtlParser.HAVING)
            self.state = 1676
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 172, self._ctx)
            if la_ == 1:
                self.state = 1675
                self.match(VtlParser.T__12)

            self.state = 1679
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 173, self._ctx)
            if la_ == 1:
                self.state = 1678
                self.aggrFunction()

            self.state = 1681
            self.expr(0)
            self.state = 1683
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 174, self._ctx)
            if la_ == 1:
                self.state = 1682
                self.match(VtlParser.T__13)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ReturnAllContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETURN(self):
            return self.getToken(VtlParser.RETURN, 0)

        def ALL(self):
            return self.getToken(VtlParser.ALL, 0)

        def DATA(self):
            return self.getToken(VtlParser.DATA, 0)

        def POINTS(self):
            return self.getToken(VtlParser.POINTS, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_returnAll

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterReturnAll"):
                listener.enterReturnAll(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitReturnAll"):
                listener.exitReturnAll(self)

    def returnAll(self):

        localctx = VtlParser.ReturnAllContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_returnAll)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1685
            self.match(VtlParser.RETURN)
            self.state = 1686
            self.match(VtlParser.ALL)
            self.state = 1687
            self.match(VtlParser.DATA)
            self.state = 1688
            self.match(VtlParser.POINTS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ComponentRoleContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MEASURE(self):
            return self.getToken(VtlParser.MEASURE, 0)

        def COMPONENT(self):
            return self.getToken(VtlParser.COMPONENT, 0)

        def DIMENSION(self):
            return self.getToken(VtlParser.DIMENSION, 0)

        def ATTRIBUTE(self):
            return self.getToken(VtlParser.ATTRIBUTE, 0)

        def viralAttribute(self):
            return self.getTypedRuleContext(VtlParser.ViralAttributeContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_componentRole

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterComponentRole"):
                listener.enterComponentRole(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitComponentRole"):
                listener.exitComponentRole(self)

    def componentRole(self):

        localctx = VtlParser.ComponentRoleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_componentRole)
        try:
            self.state = 1695
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [VtlParser.MEASURE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1690
                self.match(VtlParser.MEASURE)
                pass
            elif token in [VtlParser.COMPONENT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1691
                self.match(VtlParser.COMPONENT)
                pass
            elif token in [VtlParser.DIMENSION]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1692
                self.match(VtlParser.DIMENSION)
                pass
            elif token in [VtlParser.ATTRIBUTE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1693
                self.match(VtlParser.ATTRIBUTE)
                pass
            elif token in [VtlParser.VIRAL]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1694
                self.viralAttribute()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ViralAttributeContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VIRAL(self):
            return self.getToken(VtlParser.VIRAL, 0)

        def ATTRIBUTE(self):
            return self.getToken(VtlParser.ATTRIBUTE, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_viralAttribute

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterViralAttribute"):
                listener.enterViralAttribute(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitViralAttribute"):
                listener.exitViralAttribute(self)

    def viralAttribute(self):

        localctx = VtlParser.ViralAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_viralAttribute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1697
            self.match(VtlParser.VIRAL)
            self.state = 1698
            self.match(VtlParser.ATTRIBUTE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LogBaseContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_logBase

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLogBase"):
                listener.enterLogBase(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLogBase"):
                listener.exitLogBase(self)

    def logBase(self):

        localctx = VtlParser.LogBaseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_logBase)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1700
            self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExponentContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTEGER_CONSTANT(self):
            return self.getToken(VtlParser.INTEGER_CONSTANT, 0)

        def FLOAT_CONSTANT(self):
            return self.getToken(VtlParser.FLOAT_CONSTANT, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_exponent

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExponent"):
                listener.enterExponent(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExponent"):
                listener.exitExponent(self)

    def exponent(self):

        localctx = VtlParser.ExponentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_exponent)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1702
            _la = self._input.LA(1)
            if not (_la == VtlParser.INTEGER_CONSTANT or _la == VtlParser.FLOAT_CONSTANT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PersistentDatasetIDContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING_CONSTANT(self):
            return self.getToken(VtlParser.STRING_CONSTANT, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_persistentDatasetID

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPersistentDatasetID"):
                listener.enterPersistentDatasetID(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPersistentDatasetID"):
                listener.exitPersistentDatasetID(self)

    def persistentDatasetID(self):

        localctx = VtlParser.PersistentDatasetIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 186, self.RULE_persistentDatasetID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1704
            self.match(VtlParser.STRING_CONSTANT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DatasetIDContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(VtlParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_datasetID

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDatasetID"):
                listener.enterDatasetID(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDatasetID"):
                listener.exitDatasetID(self)

    def datasetID(self):

        localctx = VtlParser.DatasetIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 188, self.RULE_datasetID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1706
            self.match(VtlParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RulesetIDContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(VtlParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_rulesetID

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRulesetID"):
                listener.enterRulesetID(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRulesetID"):
                listener.exitRulesetID(self)

    def rulesetID(self):

        localctx = VtlParser.RulesetIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 190, self.RULE_rulesetID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1708
            self.match(VtlParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VarIDContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(VtlParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_varID

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterVarID"):
                listener.enterVarID(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitVarID"):
                listener.exitVarID(self)

    def varID(self):

        localctx = VtlParser.VarIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 192, self.RULE_varID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1710
            self.match(VtlParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ComponentIDContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(VtlParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_componentID

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterComponentID"):
                listener.enterComponentID(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitComponentID"):
                listener.exitComponentID(self)

    def componentID(self):

        localctx = VtlParser.ComponentIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 194, self.RULE_componentID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1712
            self.match(VtlParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OperatorIDContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(VtlParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_operatorID

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterOperatorID"):
                listener.enterOperatorID(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitOperatorID"):
                listener.exitOperatorID(self)

    def operatorID(self):

        localctx = VtlParser.OperatorIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 196, self.RULE_operatorID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1714
            self.match(VtlParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RoutineNameContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(VtlParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_routineName

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRoutineName"):
                listener.enterRoutineName(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRoutineName"):
                listener.exitRoutineName(self)

    def routineName(self):

        localctx = VtlParser.RoutineNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 198, self.RULE_routineName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1716
            self.match(VtlParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class JoinKeywordContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INNER_JOIN(self):
            return self.getToken(VtlParser.INNER_JOIN, 0)

        def LEFT_JOIN(self):
            return self.getToken(VtlParser.LEFT_JOIN, 0)

        def FULL_JOIN(self):
            return self.getToken(VtlParser.FULL_JOIN, 0)

        def CROSS_JOIN(self):
            return self.getToken(VtlParser.CROSS_JOIN, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_joinKeyword

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterJoinKeyword"):
                listener.enterJoinKeyword(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitJoinKeyword"):
                listener.exitJoinKeyword(self)

    def joinKeyword(self):

        localctx = VtlParser.JoinKeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 200, self.RULE_joinKeyword)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1718
            _la = self._input.LA(1)
            if not (
                (
                    (((_la - 191)) & ~0x3F) == 0
                    and (
                        (1 << (_la - 191))
                        & (
                            (1 << (VtlParser.INNER_JOIN - 191))
                            | (1 << (VtlParser.LEFT_JOIN - 191))
                            | (1 << (VtlParser.CROSS_JOIN - 191))
                            | (1 << (VtlParser.FULL_JOIN - 191))
                        )
                    )
                    != 0
                )
            ):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class GroupKeywordContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GROUP(self):
            return self.getToken(VtlParser.GROUP, 0)

        def BY(self):
            return self.getToken(VtlParser.BY, 0)

        def EXCEPT(self):
            return self.getToken(VtlParser.EXCEPT, 0)

        def ALL(self):
            return self.getToken(VtlParser.ALL, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_groupKeyword

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterGroupKeyword"):
                listener.enterGroupKeyword(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitGroupKeyword"):
                listener.exitGroupKeyword(self)

    def groupKeyword(self):

        localctx = VtlParser.GroupKeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 202, self.RULE_groupKeyword)
        try:
            self.state = 1726
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 176, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1720
                self.match(VtlParser.GROUP)
                self.state = 1721
                self.match(VtlParser.BY)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1722
                self.match(VtlParser.GROUP)
                self.state = 1723
                self.match(VtlParser.EXCEPT)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1724
                self.match(VtlParser.GROUP)
                self.state = 1725
                self.match(VtlParser.ALL)
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstantContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTEGER_CONSTANT(self):
            return self.getToken(VtlParser.INTEGER_CONSTANT, 0)

        def FLOAT_CONSTANT(self):
            return self.getToken(VtlParser.FLOAT_CONSTANT, 0)

        def BOOLEAN_CONSTANT(self):
            return self.getToken(VtlParser.BOOLEAN_CONSTANT, 0)

        def STRING_CONSTANT(self):
            return self.getToken(VtlParser.STRING_CONSTANT, 0)

        def NULL_CONSTANT(self):
            return self.getToken(VtlParser.NULL_CONSTANT, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_constant

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConstant"):
                listener.enterConstant(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConstant"):
                listener.exitConstant(self)

    def constant(self):

        localctx = VtlParser.ConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 204, self.RULE_constant)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1728
            _la = self._input.LA(1)
            if not (
                (
                    (((_la - 238)) & ~0x3F) == 0
                    and (
                        (1 << (_la - 238))
                        & (
                            (1 << (VtlParser.INTEGER_CONSTANT - 238))
                            | (1 << (VtlParser.FLOAT_CONSTANT - 238))
                            | (1 << (VtlParser.BOOLEAN_CONSTANT - 238))
                            | (1 << (VtlParser.NULL_CONSTANT - 238))
                            | (1 << (VtlParser.STRING_CONSTANT - 238))
                        )
                    )
                    != 0
                )
            ):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ComponentType2Context(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(VtlParser.STRING, 0)

        def INTEGER(self):
            return self.getToken(VtlParser.INTEGER, 0)

        def FLOAT(self):
            return self.getToken(VtlParser.FLOAT, 0)

        def BOOLEAN(self):
            return self.getToken(VtlParser.BOOLEAN, 0)

        def DATE(self):
            return self.getToken(VtlParser.DATE, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_componentType2

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterComponentType2"):
                listener.enterComponentType2(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitComponentType2"):
                listener.exitComponentType2(self)

    def componentType2(self):

        localctx = VtlParser.ComponentType2Context(self, self._ctx, self.state)
        self.enterRule(localctx, 206, self.RULE_componentType2)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1730
            _la = self._input.LA(1)
            if not (
                (
                    (((_la - 167)) & ~0x3F) == 0
                    and (
                        (1 << (_la - 167))
                        & (
                            (1 << (VtlParser.BOOLEAN - 167))
                            | (1 << (VtlParser.DATE - 167))
                            | (1 << (VtlParser.STRING - 167))
                            | (1 << (VtlParser.INTEGER - 167))
                            | (1 << (VtlParser.FLOAT - 167))
                        )
                    )
                    != 0
                )
            ):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ScalarTypeContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def basicScalarType(self):
            return self.getTypedRuleContext(VtlParser.BasicScalarTypeContext, 0)

        def valueDomainName(self):
            return self.getTypedRuleContext(VtlParser.ValueDomainNameContext, 0)

        def setName(self):
            return self.getTypedRuleContext(VtlParser.SetNameContext, 0)

        def scalarTypeConstraint(self):
            return self.getTypedRuleContext(VtlParser.ScalarTypeConstraintContext, 0)

        def NULL_CONSTANT(self):
            return self.getToken(VtlParser.NULL_CONSTANT, 0)

        def NOT(self):
            return self.getToken(VtlParser.NOT, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_scalarType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterScalarType"):
                listener.enterScalarType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitScalarType"):
                listener.exitScalarType(self)

    def scalarType(self):

        localctx = VtlParser.ScalarTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 208, self.RULE_scalarType)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1735
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 177, self._ctx)
            if la_ == 1:
                self.state = 1732
                self.basicScalarType()
                pass

            elif la_ == 2:
                self.state = 1733
                self.valueDomainName()
                pass

            elif la_ == 3:
                self.state = 1734
                self.setName()
                pass

            self.state = 1738
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.T__0 or _la == VtlParser.T__15:
                self.state = 1737
                self.scalarTypeConstraint()

            self.state = 1744
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.NOT or _la == VtlParser.NULL_CONSTANT:
                self.state = 1741
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == VtlParser.NOT:
                    self.state = 1740
                    self.match(VtlParser.NOT)

                self.state = 1743
                self.match(VtlParser.NULL_CONSTANT)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BasicScalarTypeContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(VtlParser.STRING, 0)

        def INTEGER(self):
            return self.getToken(VtlParser.INTEGER, 0)

        def NUMBER(self):
            return self.getToken(VtlParser.NUMBER, 0)

        def BOOLEAN(self):
            return self.getToken(VtlParser.BOOLEAN, 0)

        def DATE(self):
            return self.getToken(VtlParser.DATE, 0)

        def TIME_PERIOD(self):
            return self.getToken(VtlParser.TIME_PERIOD, 0)

        def DURATION(self):
            return self.getToken(VtlParser.DURATION, 0)

        def SCALAR(self):
            return self.getToken(VtlParser.SCALAR, 0)

        def TIME(self):
            return self.getToken(VtlParser.TIME, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_basicScalarType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterBasicScalarType"):
                listener.enterBasicScalarType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitBasicScalarType"):
                listener.exitBasicScalarType(self)

    def basicScalarType(self):

        localctx = VtlParser.BasicScalarTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 210, self.RULE_basicScalarType)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1746
            _la = self._input.LA(1)
            if not (
                (
                    (((_la - 167)) & ~0x3F) == 0
                    and (
                        (1 << (_la - 167))
                        & (
                            (1 << (VtlParser.BOOLEAN - 167))
                            | (1 << (VtlParser.DATE - 167))
                            | (1 << (VtlParser.TIME_PERIOD - 167))
                            | (1 << (VtlParser.NUMBER - 167))
                            | (1 << (VtlParser.STRING - 167))
                            | (1 << (VtlParser.INTEGER - 167))
                            | (1 << (VtlParser.DURATION - 167))
                            | (1 << (VtlParser.SCALAR - 167))
                        )
                    )
                    != 0
                )
                or _la == VtlParser.TIME
            ):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ValueDomainNameContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(VtlParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_valueDomainName

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterValueDomainName"):
                listener.enterValueDomainName(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitValueDomainName"):
                listener.exitValueDomainName(self)

    def valueDomainName(self):

        localctx = VtlParser.ValueDomainNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 212, self.RULE_valueDomainName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1748
            self.match(VtlParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SetNameContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(VtlParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_setName

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSetName"):
                listener.enterSetName(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSetName"):
                listener.exitSetName(self)

    def setName(self):

        localctx = VtlParser.SetNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 214, self.RULE_setName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1750
            self.match(VtlParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ScalarTypeConstraintContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(VtlParser.ExprContext, 0)

        def constant(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.ConstantContext)
            else:
                return self.getTypedRuleContext(VtlParser.ConstantContext, i)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def getRuleIndex(self):
            return VtlParser.RULE_scalarTypeConstraint

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterScalarTypeConstraint"):
                listener.enterScalarTypeConstraint(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitScalarTypeConstraint"):
                listener.exitScalarTypeConstraint(self)

    def scalarTypeConstraint(self):

        localctx = VtlParser.ScalarTypeConstraintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 216, self.RULE_scalarTypeConstraint)
        self._la = 0  # Token type
        try:
            self.state = 1767
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [VtlParser.T__0]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1752
                self.match(VtlParser.T__0)
                self.state = 1753
                self.expr(0)
                self.state = 1754
                self.match(VtlParser.T__1)
                pass
            elif token in [VtlParser.T__15]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1756
                self.match(VtlParser.T__15)
                self.state = 1757
                self.constant()
                self.state = 1762
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == VtlParser.CARTESIAN_PER:
                    self.state = 1758
                    self.match(VtlParser.CARTESIAN_PER)
                    self.state = 1759
                    self.constant()
                    self.state = 1764
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1765
                self.match(VtlParser.T__16)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DataTypeContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def scalarType(self):
            return self.getTypedRuleContext(VtlParser.ScalarTypeContext, 0)

        def componentType(self):
            return self.getTypedRuleContext(VtlParser.ComponentTypeContext, 0)

        def datasetType(self):
            return self.getTypedRuleContext(VtlParser.DatasetTypeContext, 0)

        def scalarSetType(self):
            return self.getTypedRuleContext(VtlParser.ScalarSetTypeContext, 0)

        def operatorType(self):
            return self.getTypedRuleContext(VtlParser.OperatorTypeContext, 0)

        def rulesetType(self):
            return self.getTypedRuleContext(VtlParser.RulesetTypeContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_dataType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDataType"):
                listener.enterDataType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDataType"):
                listener.exitDataType(self)

    def dataType(self):

        localctx = VtlParser.DataTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 218, self.RULE_dataType)
        try:
            self.state = 1775
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 183, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1769
                self.scalarType()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1770
                self.componentType()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1771
                self.datasetType()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1772
                self.scalarSetType()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1773
                self.operatorType()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1774
                self.rulesetType()
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ComponentTypeContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def componentRole(self):
            return self.getTypedRuleContext(VtlParser.ComponentRoleContext, 0)

        def scalarType(self):
            return self.getTypedRuleContext(VtlParser.ScalarTypeContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_componentType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterComponentType"):
                listener.enterComponentType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitComponentType"):
                listener.exitComponentType(self)

    def componentType(self):

        localctx = VtlParser.ComponentTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 220, self.RULE_componentType)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1777
            self.componentRole()
            self.state = 1782
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.T__7:
                self.state = 1778
                self.match(VtlParser.T__7)
                self.state = 1779
                self.scalarType()
                self.state = 1780
                self.match(VtlParser.T__6)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DatasetTypeContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATASET(self):
            return self.getToken(VtlParser.DATASET, 0)

        def compConstraint(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.CompConstraintContext)
            else:
                return self.getTypedRuleContext(VtlParser.CompConstraintContext, i)

        def CARTESIAN_PER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.CARTESIAN_PER)
            else:
                return self.getToken(VtlParser.CARTESIAN_PER, i)

        def getRuleIndex(self):
            return VtlParser.RULE_datasetType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDatasetType"):
                listener.enterDatasetType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDatasetType"):
                listener.exitDatasetType(self)

    def datasetType(self):

        localctx = VtlParser.DatasetTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 222, self.RULE_datasetType)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1784
            self.match(VtlParser.DATASET)
            self.state = 1796
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.T__15:
                self.state = 1785
                self.match(VtlParser.T__15)
                self.state = 1786
                self.compConstraint()
                self.state = 1791
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == VtlParser.CARTESIAN_PER:
                    self.state = 1787
                    self.match(VtlParser.CARTESIAN_PER)
                    self.state = 1788
                    self.compConstraint()
                    self.state = 1793
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1794
                self.match(VtlParser.T__16)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CompConstraintContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def componentType(self):
            return self.getTypedRuleContext(VtlParser.ComponentTypeContext, 0)

        def componentID(self):
            return self.getTypedRuleContext(VtlParser.ComponentIDContext, 0)

        def multModifier(self):
            return self.getTypedRuleContext(VtlParser.MultModifierContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_compConstraint

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCompConstraint"):
                listener.enterCompConstraint(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCompConstraint"):
                listener.exitCompConstraint(self)

    def compConstraint(self):

        localctx = VtlParser.CompConstraintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 224, self.RULE_compConstraint)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1798
            self.componentType()
            self.state = 1801
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [VtlParser.IDENTIFIER]:
                self.state = 1799
                self.componentID()
                pass
            elif token in [VtlParser.OPTIONAL]:
                self.state = 1800
                self.multModifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MultModifierContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPTIONAL(self):
            return self.getToken(VtlParser.OPTIONAL, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_multModifier

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMultModifier"):
                listener.enterMultModifier(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMultModifier"):
                listener.exitMultModifier(self)

    def multModifier(self):

        localctx = VtlParser.MultModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 226, self.RULE_multModifier)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1803
            self.match(VtlParser.OPTIONAL)
            self.state = 1805
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.T__2 or _la == VtlParser.T__4:
                self.state = 1804
                _la = self._input.LA(1)
                if not (_la == VtlParser.T__2 or _la == VtlParser.T__4):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RulesetTypeContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RULESET(self):
            return self.getToken(VtlParser.RULESET, 0)

        def dpRuleset(self):
            return self.getTypedRuleContext(VtlParser.DpRulesetContext, 0)

        def hrRuleset(self):
            return self.getTypedRuleContext(VtlParser.HrRulesetContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_rulesetType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRulesetType"):
                listener.enterRulesetType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRulesetType"):
                listener.exitRulesetType(self)

    def rulesetType(self):

        localctx = VtlParser.RulesetTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 228, self.RULE_rulesetType)
        try:
            self.state = 1810
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [VtlParser.RULESET]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1807
                self.match(VtlParser.RULESET)
                pass
            elif token in [
                VtlParser.DATAPOINT,
                VtlParser.DATAPOINT_ON_VD,
                VtlParser.DATAPOINT_ON_VAR,
            ]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1808
                self.dpRuleset()
                pass
            elif token in [
                VtlParser.HIERARCHICAL,
                VtlParser.HIERARCHICAL_ON_VD,
                VtlParser.HIERARCHICAL_ON_VAR,
            ]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1809
                self.hrRuleset()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DpRulesetContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATAPOINT(self):
            return self.getToken(VtlParser.DATAPOINT, 0)

        def DATAPOINT_ON_VD(self):
            return self.getToken(VtlParser.DATAPOINT_ON_VD, 0)

        def prodValueDomains(self):
            return self.getTypedRuleContext(VtlParser.ProdValueDomainsContext, 0)

        def DATAPOINT_ON_VAR(self):
            return self.getToken(VtlParser.DATAPOINT_ON_VAR, 0)

        def prodVariables(self):
            return self.getTypedRuleContext(VtlParser.ProdVariablesContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_dpRuleset

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDpRuleset"):
                listener.enterDpRuleset(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDpRuleset"):
                listener.exitDpRuleset(self)

    def dpRuleset(self):

        localctx = VtlParser.DpRulesetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 230, self.RULE_dpRuleset)
        try:
            self.state = 1823
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [VtlParser.DATAPOINT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1812
                self.match(VtlParser.DATAPOINT)
                pass
            elif token in [VtlParser.DATAPOINT_ON_VD]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1813
                self.match(VtlParser.DATAPOINT_ON_VD)
                self.state = 1814
                self.match(VtlParser.T__15)
                self.state = 1815
                self.prodValueDomains()
                self.state = 1816
                self.match(VtlParser.T__16)
                pass
            elif token in [VtlParser.DATAPOINT_ON_VAR]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1818
                self.match(VtlParser.DATAPOINT_ON_VAR)
                self.state = 1819
                self.match(VtlParser.T__15)
                self.state = 1820
                self.prodVariables()
                self.state = 1821
                self.match(VtlParser.T__16)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class HrRulesetContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HIERARCHICAL(self):
            return self.getToken(VtlParser.HIERARCHICAL, 0)

        def HIERARCHICAL_ON_VD(self):
            return self.getToken(VtlParser.HIERARCHICAL_ON_VD, 0)

        def IDENTIFIER(self):
            return self.getToken(VtlParser.IDENTIFIER, 0)

        def prodValueDomains(self):
            return self.getTypedRuleContext(VtlParser.ProdValueDomainsContext, 0)

        def HIERARCHICAL_ON_VAR(self):
            return self.getToken(VtlParser.HIERARCHICAL_ON_VAR, 0)

        def varID(self):
            return self.getTypedRuleContext(VtlParser.VarIDContext, 0)

        def prodVariables(self):
            return self.getTypedRuleContext(VtlParser.ProdVariablesContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_hrRuleset

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterHrRuleset"):
                listener.enterHrRuleset(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitHrRuleset"):
                listener.exitHrRuleset(self)

    def hrRuleset(self):

        localctx = VtlParser.HrRulesetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 232, self.RULE_hrRuleset)
        self._la = 0  # Token type
        try:
            self.state = 1851
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [VtlParser.HIERARCHICAL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1825
                self.match(VtlParser.HIERARCHICAL)
                pass
            elif token in [VtlParser.HIERARCHICAL_ON_VD]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1826
                self.match(VtlParser.HIERARCHICAL_ON_VD)
                self.state = 1836
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == VtlParser.T__15:
                    self.state = 1827
                    self.match(VtlParser.T__15)
                    self.state = 1828
                    self.match(VtlParser.IDENTIFIER)
                    self.state = 1833
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la == VtlParser.T__12:
                        self.state = 1829
                        self.match(VtlParser.T__12)
                        self.state = 1830
                        self.prodValueDomains()
                        self.state = 1831
                        self.match(VtlParser.T__13)

                    self.state = 1835
                    self.match(VtlParser.T__16)

                pass
            elif token in [VtlParser.HIERARCHICAL_ON_VAR]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1838
                self.match(VtlParser.HIERARCHICAL_ON_VAR)
                self.state = 1849
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == VtlParser.T__15:
                    self.state = 1839
                    self.match(VtlParser.T__15)
                    self.state = 1840
                    self.varID()
                    self.state = 1845
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la == VtlParser.T__12:
                        self.state = 1841
                        self.match(VtlParser.T__12)
                        self.state = 1842
                        self.prodVariables()
                        self.state = 1843
                        self.match(VtlParser.T__13)

                    self.state = 1847
                    self.match(VtlParser.T__16)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ProdValueDomainsContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i: int = None):
            if i is None:
                return self.getTokens(VtlParser.IDENTIFIER)
            else:
                return self.getToken(VtlParser.IDENTIFIER, i)

        def getRuleIndex(self):
            return VtlParser.RULE_prodValueDomains

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterProdValueDomains"):
                listener.enterProdValueDomains(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitProdValueDomains"):
                listener.exitProdValueDomains(self)

    def prodValueDomains(self):

        localctx = VtlParser.ProdValueDomainsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 234, self.RULE_prodValueDomains)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1853
            self.match(VtlParser.IDENTIFIER)
            self.state = 1858
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == VtlParser.T__4:
                self.state = 1854
                self.match(VtlParser.T__4)
                self.state = 1855
                self.match(VtlParser.IDENTIFIER)
                self.state = 1860
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ProdVariablesContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def varID(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.VarIDContext)
            else:
                return self.getTypedRuleContext(VtlParser.VarIDContext, i)

        def getRuleIndex(self):
            return VtlParser.RULE_prodVariables

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterProdVariables"):
                listener.enterProdVariables(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitProdVariables"):
                listener.exitProdVariables(self)

    def prodVariables(self):

        localctx = VtlParser.ProdVariablesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 236, self.RULE_prodVariables)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1861
            self.varID()
            self.state = 1866
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == VtlParser.T__4:
                self.state = 1862
                self.match(VtlParser.T__4)
                self.state = 1863
                self.varID()
                self.state = 1868
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OperatorTypeContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def inputParameterType(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(VtlParser.InputParameterTypeContext)
            else:
                return self.getTypedRuleContext(VtlParser.InputParameterTypeContext, i)

        def outputParameterType(self):
            return self.getTypedRuleContext(VtlParser.OutputParameterTypeContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_operatorType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterOperatorType"):
                listener.enterOperatorType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitOperatorType"):
                listener.exitOperatorType(self)

    def operatorType(self):

        localctx = VtlParser.OperatorTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 238, self.RULE_operatorType)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1869
            self.inputParameterType()
            self.state = 1874
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == VtlParser.T__4:
                self.state = 1870
                self.match(VtlParser.T__4)
                self.state = 1871
                self.inputParameterType()
                self.state = 1876
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1877
            self.match(VtlParser.T__17)
            self.state = 1878
            self.outputParameterType()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InputParameterTypeContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def scalarType(self):
            return self.getTypedRuleContext(VtlParser.ScalarTypeContext, 0)

        def datasetType(self):
            return self.getTypedRuleContext(VtlParser.DatasetTypeContext, 0)

        def componentType(self):
            return self.getTypedRuleContext(VtlParser.ComponentTypeContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_inputParameterType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInputParameterType"):
                listener.enterInputParameterType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInputParameterType"):
                listener.exitInputParameterType(self)

    def inputParameterType(self):

        localctx = VtlParser.InputParameterTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 240, self.RULE_inputParameterType)
        try:
            self.state = 1883
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [
                VtlParser.BOOLEAN,
                VtlParser.DATE,
                VtlParser.TIME_PERIOD,
                VtlParser.NUMBER,
                VtlParser.STRING,
                VtlParser.INTEGER,
                VtlParser.DURATION,
                VtlParser.SCALAR,
                VtlParser.IDENTIFIER,
                VtlParser.TIME,
            ]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1880
                self.scalarType()
                pass
            elif token in [VtlParser.DATASET]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1881
                self.datasetType()
                pass
            elif token in [
                VtlParser.DIMENSION,
                VtlParser.MEASURE,
                VtlParser.ATTRIBUTE,
                VtlParser.VIRAL,
                VtlParser.COMPONENT,
            ]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1882
                self.componentType()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OutputParameterTypeContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def scalarType(self):
            return self.getTypedRuleContext(VtlParser.ScalarTypeContext, 0)

        def datasetType(self):
            return self.getTypedRuleContext(VtlParser.DatasetTypeContext, 0)

        def scalarSetType(self):
            return self.getTypedRuleContext(VtlParser.ScalarSetTypeContext, 0)

        def rulesetType(self):
            return self.getTypedRuleContext(VtlParser.RulesetTypeContext, 0)

        def componentType(self):
            return self.getTypedRuleContext(VtlParser.ComponentTypeContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_outputParameterType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterOutputParameterType"):
                listener.enterOutputParameterType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitOutputParameterType"):
                listener.exitOutputParameterType(self)

    def outputParameterType(self):

        localctx = VtlParser.OutputParameterTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 242, self.RULE_outputParameterType)
        try:
            self.state = 1890
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [
                VtlParser.BOOLEAN,
                VtlParser.DATE,
                VtlParser.TIME_PERIOD,
                VtlParser.NUMBER,
                VtlParser.STRING,
                VtlParser.INTEGER,
                VtlParser.DURATION,
                VtlParser.SCALAR,
                VtlParser.IDENTIFIER,
                VtlParser.TIME,
            ]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1885
                self.scalarType()
                pass
            elif token in [VtlParser.DATASET]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1886
                self.datasetType()
                pass
            elif token in [VtlParser.SET]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1887
                self.scalarSetType()
                pass
            elif token in [
                VtlParser.DATAPOINT,
                VtlParser.HIERARCHICAL,
                VtlParser.RULESET,
                VtlParser.DATAPOINT_ON_VD,
                VtlParser.DATAPOINT_ON_VAR,
                VtlParser.HIERARCHICAL_ON_VD,
                VtlParser.HIERARCHICAL_ON_VAR,
            ]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1888
                self.rulesetType()
                pass
            elif token in [
                VtlParser.DIMENSION,
                VtlParser.MEASURE,
                VtlParser.ATTRIBUTE,
                VtlParser.VIRAL,
                VtlParser.COMPONENT,
            ]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1889
                self.componentType()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ScalarSetTypeContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET(self):
            return self.getToken(VtlParser.SET, 0)

        def scalarType(self):
            return self.getTypedRuleContext(VtlParser.ScalarTypeContext, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_scalarSetType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterScalarSetType"):
                listener.enterScalarSetType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitScalarSetType"):
                listener.exitScalarSetType(self)

    def scalarSetType(self):

        localctx = VtlParser.ScalarSetTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 244, self.RULE_scalarSetType)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1892
            self.match(VtlParser.SET)
            self.state = 1897
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == VtlParser.T__7:
                self.state = 1893
                self.match(VtlParser.T__7)
                self.state = 1894
                self.scalarType()
                self.state = 1895
                self.match(VtlParser.T__6)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RetainTypeContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOOLEAN_CONSTANT(self):
            return self.getToken(VtlParser.BOOLEAN_CONSTANT, 0)

        def ALL(self):
            return self.getToken(VtlParser.ALL, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_retainType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRetainType"):
                listener.enterRetainType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRetainType"):
                listener.exitRetainType(self)

    def retainType(self):

        localctx = VtlParser.RetainTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 246, self.RULE_retainType)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1899
            _la = self._input.LA(1)
            if not (_la == VtlParser.ALL or _la == VtlParser.BOOLEAN_CONSTANT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DefineDatapointRulesetContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFINE(self):
            return self.getToken(VtlParser.DEFINE, 0)

        def DATAPOINT(self):
            return self.getToken(VtlParser.DATAPOINT, 0)

        def RULESET(self):
            return self.getToken(VtlParser.RULESET, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_defineDatapointRuleset

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDefineDatapointRuleset"):
                listener.enterDefineDatapointRuleset(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDefineDatapointRuleset"):
                listener.exitDefineDatapointRuleset(self)

    def defineDatapointRuleset(self):

        localctx = VtlParser.DefineDatapointRulesetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 248, self.RULE_defineDatapointRuleset)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1901
            self.match(VtlParser.DEFINE)
            self.state = 1902
            self.match(VtlParser.DATAPOINT)
            self.state = 1903
            self.match(VtlParser.RULESET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DefineHierarchicalRulesetContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFINE(self):
            return self.getToken(VtlParser.DEFINE, 0)

        def HIERARCHICAL(self):
            return self.getToken(VtlParser.HIERARCHICAL, 0)

        def RULESET(self):
            return self.getToken(VtlParser.RULESET, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_defineHierarchicalRuleset

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDefineHierarchicalRuleset"):
                listener.enterDefineHierarchicalRuleset(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDefineHierarchicalRuleset"):
                listener.exitDefineHierarchicalRuleset(self)

    def defineHierarchicalRuleset(self):

        localctx = VtlParser.DefineHierarchicalRulesetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 250, self.RULE_defineHierarchicalRuleset)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1905
            self.match(VtlParser.DEFINE)
            self.state = 1906
            self.match(VtlParser.HIERARCHICAL)
            self.state = 1907
            self.match(VtlParser.RULESET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EndDatapointRulesetContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def END(self):
            return self.getToken(VtlParser.END, 0)

        def DATAPOINT(self):
            return self.getToken(VtlParser.DATAPOINT, 0)

        def RULESET(self):
            return self.getToken(VtlParser.RULESET, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_endDatapointRuleset

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEndDatapointRuleset"):
                listener.enterEndDatapointRuleset(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEndDatapointRuleset"):
                listener.exitEndDatapointRuleset(self)

    def endDatapointRuleset(self):

        localctx = VtlParser.EndDatapointRulesetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 252, self.RULE_endDatapointRuleset)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1909
            self.match(VtlParser.END)
            self.state = 1910
            self.match(VtlParser.DATAPOINT)
            self.state = 1911
            self.match(VtlParser.RULESET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EndHierarchicalRulesetContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def END(self):
            return self.getToken(VtlParser.END, 0)

        def HIERARCHICAL(self):
            return self.getToken(VtlParser.HIERARCHICAL, 0)

        def RULESET(self):
            return self.getToken(VtlParser.RULESET, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_endHierarchicalRuleset

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEndHierarchicalRuleset"):
                listener.enterEndHierarchicalRuleset(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEndHierarchicalRuleset"):
                listener.exitEndHierarchicalRuleset(self)

    def endHierarchicalRuleset(self):

        localctx = VtlParser.EndHierarchicalRulesetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 254, self.RULE_endHierarchicalRuleset)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1913
            self.match(VtlParser.END)
            self.state = 1914
            self.match(VtlParser.HIERARCHICAL)
            self.state = 1915
            self.match(VtlParser.RULESET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DefineDataStructureContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFINE(self):
            return self.getToken(VtlParser.DEFINE, 0)

        def DATA(self):
            return self.getToken(VtlParser.DATA, 0)

        def STRUCTURE(self):
            return self.getToken(VtlParser.STRUCTURE, 0)

        def getRuleIndex(self):
            return VtlParser.RULE_defineDataStructure

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDefineDataStructure"):
                listener.enterDefineDataStructure(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDefineDataStructure"):
                listener.exitDefineDataStructure(self)

    def defineDataStructure(self):

        localctx = VtlParser.DefineDataStructureContext(self, self._ctx, self.state)
        self.enterRule(localctx, 256, self.RULE_defineDataStructure)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1917
            self.match(VtlParser.DEFINE)
            self.state = 1918
            self.match(VtlParser.DATA)
            self.state = 1919
            self.match(VtlParser.STRUCTURE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    def sempred(self, localctx: RuleContext, ruleIndex: int, predIndex: int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[4] = self.expr_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expr_sempred(self, localctx: ExprContext, predIndex: int):
        if predIndex == 0:
            return self.precpred(self._ctx, 16)

        if predIndex == 1:
            return self.precpred(self._ctx, 15)

        if predIndex == 2:
            return self.precpred(self._ctx, 14)

        if predIndex == 3:
            return self.precpred(self._ctx, 10)

        if predIndex == 4:
            return self.precpred(self._ctx, 9)

        if predIndex == 5:
            return self.precpred(self._ctx, 8)

        if predIndex == 6:
            return self.precpred(self._ctx, 3)

        if predIndex == 7:
            return self.precpred(self._ctx, 13)

        if predIndex == 8:
            return self.precpred(self._ctx, 12)
