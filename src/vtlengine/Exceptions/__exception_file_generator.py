from pathlib import Path
from typing import Any, Dict

output_filepath = Path(__file__).parent.parent.parent.parent / "Docs" / "error_messages.rst"


def generate_errors_rst(file_path: Path, messages: Dict[str, Any]) -> None:
    """
    Generates an RST file with a list-table of error codes, messages, and descriptions.
    Uses list-table format for better rendering and text wrapping in Sphinx.
    """

    def sort_key(code: str) -> Any:
        return tuple(int(part) for part in code.split("-"))

    def escape_for_sphinx(text: str) -> str:
        """
        Scapes placeholders for Sphinx formatting.
        """
        placeholders = ["{type}", "{type_}", "{format}", "{format_}", "{param}", "{op}", "{value}"]
        for ph in placeholders:
            text = text.replace(ph, f"``{ph}``")
        return text

    path = Path(file_path)
    lines = []
    lines.append("Error Messages")
    lines.append("################")
    lines.append("")
    lines.append(
        "This document provides a complete list of all error messages generated by the VTL engine. "
        "Each entry includes the error code, the corresponding message, and a brief description "
        "to help users to understand the cause of the issue."
    )
    lines.append("")
    lines.append("The following legend explains the error code patterns used in the VTL engine:")
    lines.append("")
    category_header = "Category"
    pattern_header = "Pattern"
    legend_rows = [
        ("INPUT ERRORS", "0-1-X-X = Input Validation Errors\n"),
        ("", "0-2-X-X = JSON Schema Errors\n"),
        ("", "0-3-X-X = DataLoad Errors"),
        ("SEMANTIC ERRORS", "1-1-X-X = Operators Semantic Errors\n"),
        ("", "1-2-X-X = Semantic Analyzer Errors\n"),
        ("", "1-3-X-X = AST Errors"),
        ("RUNTIME ERRORS", "2-X-X-X = RunTime Operator Errors"),
    ]

    max_cat = max(len(category_header), max(len(row[0]) for row in legend_rows))
    max_pat = max(len(pattern_header), max(len(row[1]) for row in legend_rows))
    sep_legend = f"{'=' * max_cat}  {'=' * max_pat}"

    lines.append(sep_legend)
    lines.append(f"{category_header.ljust(max_cat)}  {pattern_header.ljust(max_pat)}")
    lines.append(sep_legend)
    for cat, pat in legend_rows:
        lines.append(f"{cat.ljust(max_cat)}  {pat.ljust(max_pat)}")
    lines.append(sep_legend)
    lines.append("")
    lines.append("The following table contains all available error codes:")
    lines.append("")

    # Use list-table for better text wrapping and responsive display
    lines.append(".. list-table::")
    lines.append("   :header-rows: 1")
    lines.append("   :widths: 10 45 45")
    lines.append("   :class: error-messages-table")
    lines.append("")
    lines.append("   * - Code")
    lines.append("     - Message")
    lines.append("     - Description")

    for code in sorted(messages.keys(), key=sort_key):
        info = messages[code]
        if isinstance(info, dict):
            message = escape_for_sphinx(info.get("message", ""))
            description = escape_for_sphinx(info.get("description", ""))
        else:
            message = escape_for_sphinx(str(info))
            description = ""
        lines.append(f"   * - {code}")
        lines.append(f"     - {message}")
        lines.append(f"     - {description}")

    path.write_text("\n".join(lines), encoding="utf-8")
    print(f"RST generated in {path}")
